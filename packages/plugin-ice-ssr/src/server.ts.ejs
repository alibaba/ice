import '@/app';
import * as cheerio from 'cheerio';
import * as queryString from 'query-string';
import { matchPath } from 'ice';
import { setInitialData } from 'react-app-renderer';
import reactAppRendererWithSSR from 'react-app-renderer/lib/server';
import { getAppConfig } from './appConfig';
import loadStaticModules from './loadStaticModules';
import app from './runApp';
import routes from '@/routes';

const chalk = require('chalk');
const parseurl = require('parseurl');
const { createBaseApp, emitLifeCycles } = app;

// appConfig set by: import '@/app'
const appConfig = getAppConfig();

const serverRender = async ({ ctx = {}, pathname, initialData, htmlTemplate }) => {

  const htmlTemplateContent = htmlTemplate || `__ICE_SERVER_HTML_TEMPLATE__`;
  // get html template
  const $ = cheerio.load(htmlTemplateContent, { decodeEntities: false });

  // load module to run before createApp ready
  loadStaticModules(appConfig);

  let pageInitialProps;
  let error;

  const { req, res } = ctx as any;
  const { search, hash, path } = parseurl(req);
  const parsedQuery = queryString.parse(search);
  const initialContext = {
    req,
    res,
    pathname,
    query: parsedQuery,
    path,
    location: { pathname, search, hash, state: null },
  }

  try {
    // get initial data
    if (!initialData) {
      const getInitialData = appConfig.app && appConfig.app.getInitialData;
      if (getInitialData) {
        console.log('[SSR]', 'getting initial data of app');
        initialData = await getInitialData(initialContext);
      }
    }

    // set initial data
    setInitialData(initialData);

    // get page initial props
    const PageComponent = getComponentByPath(routes, pathname);
    const getInitialProps = PageComponent && PageComponent.getInitialProps;
    if (getInitialProps) {
      console.log('[SSR]', 'getting initial props of page component');
      pageInitialProps = await getInitialProps(initialContext);
    }

    // generate bundle content and register global variables in html
    console.log('[SSR]', 'generating html content');
    const bundleContent = reactAppRendererWithSSR({
      initialContext,
      initialData,
      pageInitialProps
    }, {
      appConfig,
      createBaseApp,
      emitLifeCycles
    });

    const titleSelector = 'head>title', descriptionSelector = 'head>meta[name=description]', keywordsSelector='head>meta[name=keywords]';
    const appTitle = $(titleSelector).text();
    const appDescription = $(descriptionSelector).attr('content');
    const appKeywords = $(keywordsSelector).attr('content');
    const appTDKData = {
      title: appTitle,
      description: appDescription,
      keywords: appKeywords
    };
    $('#ice-container').append(bundleContent);
    $('head').append(`<script>
      window.__ICE_SSR_ENABLED__=true;
      window.__ICE_APP_DATA__=${JSON.stringify(initialData)};
      window.__ICE_PAGE_PROPS__=${JSON.stringify(pageInitialProps)};
      window.__ICE_APP_TDK__=${JSON.stringify(appTDKData)};
    </script>`)
    if (pageInitialProps && pageInitialProps.__SSR_PAGE_TDK__) {
      const { title, description, keywords } = pageInitialProps.__SSR_PAGE_TDK__;

      $(titleSelector).text(title || appTitle);
      modifyMetaElement(descriptionSelector, 'description', description);
      modifyMetaElement(keywordsSelector, 'keywords', keywords);
    }

    function modifyMetaElement(selector: string, name: string, content: string) {
      if (content) {
        if ($('head>meta').is(`[name=${name}]`)) {
          // update the meta element
          $(selector).attr('content', content);
        } else {
          // add new meta element to the head
          const head = $('head');
          head.append(`<meta name="${name}" content="${content}">`);
        }
      }
    }
  } catch (e) {
    error = e;
    $('head').append(`
    <script>
      window.__ICE_SSR_ERROR__ = '${error}';
    </script>`)
    logError('[SSR] generate html template error');
  }

  const html = $.html();
  return { html, error, redirectUrl: initialContext.url };
}

function getComponentByPath(routes, currPath)  {
  function findMatchRoute(routeList) {
    const matchedRoute = routeList.find(route => {
      return matchPath(currPath, route);
    });
    if (matchedRoute) {
      return matchedRoute.children ? findMatchRoute(matchedRoute.children) : matchedRoute;
    }
  }
  const matchedRoute = findMatchRoute(routes);
  return matchedRoute && matchedRoute.component;
}

function logError(msg) {
  console.log(
    chalk.red('ERR!'),
    chalk.magenta(msg),
  );
}

export default serverRender;
