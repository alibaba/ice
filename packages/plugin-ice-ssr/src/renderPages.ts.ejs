import '@/app';
import { join } from 'path';
import routes from '<%- routesPath %>/routes';
import loadable from '@loadable/component';
import { pathToRegexp } from '@ice/runtime';
import { renderStatic } from './server';

export default async function ssgRender(options) {
  const { htmlTemplate } = options;
  const loadableStatsPath = join(process.cwd(), '<%- outputDir %>', 'loadable-stats.json');
  const buildConfig = { 
    loadableStatsPath,
    locale: { defaultLocale: '<%- defaultLocale %>', locales: <%- JSON.stringify(locales) %> },
  };
  const htmlTemplateContent = htmlTemplate || 'global.__ICE_SERVER_HTML_TEMPLATE__';
  const pagesData = [];

  let allRoutes = routes;
  if (buildConfig.locale.locales?.length > 0 && buildConfig.locale.defaultLocale) {
    allRoutes = addRoutesByLocales(routes, <%- JSON.stringify(locales) %>, '<%- defaultLocale %>');
  }

  const flatRoutes = await getFlatRoutes(allRoutes);

  for (const flatRoute of flatRoutes) {
    const { path = '', getInitialProps, ...rest } = flatRoute;

    const keys = [];
    pathToRegexp(path, keys);
    if (keys.length > 0) {
      // don't render and export static page when the route is dynamic, e.g.: /news/:id, /*
      continue;
    }

    const initialContext = { pathname: path, location: { pathname: path } };
    const { html } = await renderStatic({ htmlTemplateContent, buildConfig, initialContext });

    delete rest.component;
    delete rest.routeWrappers;
    pagesData.push({ html, path, ...rest });
  }

  return pagesData;
};

async function getFlatRoutes(routes, parentPath = '') {
  return await routes.reduce(async (asyncPrev, originRoute) => {
    let prev = await asyncPrev;

    // must clone new object to avoid using the same route
    const route = { ...originRoute };

    const { children, path: currentPath = '', redirect } = route;
    if (children) {
      prev = prev.concat(await getFlatRoutes(children, currentPath));
    } else if (!redirect) {
      route.path = join(parentPath, currentPath);
      if (route?.component?.__LOADABLE__) {
        route.component = loadable(route.component.dynamicImport);
      }
      prev.push(route);
      const getStaticPaths = route.getStaticPaths || route.component.getStaticPaths;
      if (typeof getStaticPaths === 'function') {
        const staticPaths = await getStaticPaths();
        if (Array.isArray(staticPaths)) {
          // add static paths to render
          staticPaths.forEach((staticPath) => {
            prev.push({
              ...route,
              path: staticPath
            })
          })
        }
      }
    }
    return prev;
  }, Promise.resolve([]));
}

function addRoutesByLocales(originRoutes: any[], locales: string[], defaultLocale: string) {
  const modifiedRoutes = [...originRoutes];

  // the locales which are need to add the prefix to the route(e.g.: /home -> /en-US/home).
  const prefixRouteLocales = locales.filter(locale => locale !== defaultLocale);

  originRoutes.forEach((route) => {
    const { path, redirect } = route;
    if(path && !redirect && typeof path === 'string') {
      prefixRouteLocales.forEach((prefixRouteLocale: string) => {
        modifiedRoutes.unshift({ 
          ...route, 
          path: `/${prefixRouteLocale}${path[0] === '/' ? path :`/${path}`}`,
        });
      });
    }
  });

  return modifiedRoutes;
}