import '@/app';
import { join } from 'path';
import { matchPath } from 'ice';
import { pathToRegexp } from 'path-to-regexp';
import * as cheerio from 'cheerio';
import { Helmet } from 'react-helmet';
import * as queryString from 'query-string';
import reactAppRendererWithSSR from 'react-app-renderer/lib/server';
import { getAppConfig } from './core/appConfig';
import { emitLifeCycles } from './core/publicAPI';
import app from './core/runApp';
import routes from '<%- routesPath %>/routes';
import loadable from '@loadable/component';

const parseurl = require('parseurl');

const { createBaseApp } = app;

// appConfig set by: import '@/app'
const appConfig = getAppConfig();

export default async function render(options: any = {}) {
  let {
    htmlTemplate,
    command,
    ctx,
  } = options;
  const loadableStatsPath = join(process.cwd(), '<%- outputDir %>', 'loadable-stats.json');

  const buildConfig = { loadableStatsPath, publicPath: '<%- publicPath %>' };

  const htmlTemplateContent = htmlTemplate || `__ICE_SERVER_HTML_TEMPLATE__`;

  if (command === 'build') {
    return await renderStaticInProd({ htmlTemplateContent, buildConfig });
  } else {
    return await renderStaticInDev({ htmlTemplateContent, buildConfig, ctx });
  }
};

async function renderStaticInProd({ htmlTemplateContent, buildConfig }) {
  const routesHtml = [];
  const flatRoutes = await getFlatRoutes(routes || []);
  const defaultRoutePath = '/__ice_default_route__';
  const defaultRoute = { path: defaultRoutePath };
  flatRoutes.push(defaultRoute);
  for (const flatRoute of flatRoutes) {
    const { path = '', getInitialProps, ...rest } = flatRoute;

    const keys = [];
    let appendContent = true;
    if (path === defaultRoutePath) {
      appendContent = false;
    } else {
      try {
        pathToRegexp(path, keys);
        if (keys.length > 0) {
          // don't render and export static page when the route is dynamic
          continue;
        }
      } catch {
        continue;
      }
    }

    const initialContext = { pathname: path, location: { pathname: path } } as any;
    const { html } = await renderStatic({ htmlTemplateContent, buildConfig, getInitialProps, initialContext, appendContent });

    delete rest.component;
    delete rest.routeWrappers;
    routesHtml.push({ html, path, ...rest });
  }
  return routesHtml;
}

async function renderStaticInDev({ htmlTemplateContent, buildConfig, ctx }) {
  console.log();
  const { req, res } = ctx;
  const { search, hash, path, pathname } = parseurl(req);
  const parsedQuery = queryString.parse(search);
  const initialContext = {
    req,
    res,
    pathname,
    query: parsedQuery,
    path,
    location: { pathname, search, hash, state: null },
  }
  let { getInitialProps } = await getComponentByPath(routes, pathname);

  return await renderStatic({ htmlTemplateContent, getInitialProps, buildConfig, initialContext });
}

async function renderStatic({ htmlTemplateContent, getInitialProps, buildConfig, initialContext, appendContent = true }) {
  let html = htmlTemplateContent;
  try {
    let pageInitialProps = {};
      if (getInitialProps) {
        pageInitialProps = await getInitialProps(initialContext);
      }
      const { bundleContent, loadableComponentExtractor } =
        reactAppRendererWithSSR(
          {
            initialContext,
            pageInitialProps,
          },
          {
            appConfig,
            buildConfig,
            appLifecycle: { createBaseApp, emitLifeCycles },
          }
        );

      const helmet = Helmet.renderStatic();

      html = generateHtml({
        htmlTemplateContent,
        loadableComponentExtractor,
        helmet,
        bundleContent,
        pageInitialProps,
        appendContent
      });
  } catch (error) {
    console.error(error);
  }

  return { html, redirectUrl: initialContext.redirectUrl };
}

function generateHtml({
  htmlTemplateContent,
  loadableComponentExtractor,
  helmet,
  bundleContent,
  pageInitialProps,
  appendContent
 }) {
  const $ = cheerio.load(htmlTemplateContent, { decodeEntities: false });
  if (appendContent) {
    $(`#${appConfig?.app?.rootId || 'ice-container'}`).append(bundleContent);
    $('head').append(`<script>
      window.__ICE_SSR_ENABLED__=true;
      window.__ICE_PAGE_PROPS__=${JSON.stringify(pageInitialProps)};
    </script>`);
  }
  // inject assets
  $('head').append(`${loadableComponentExtractor.getLinkTags()}`);
  $('head').append(`${loadableComponentExtractor.getStyleTags()}`);
  $('body').append(`${loadableComponentExtractor.getScriptTags()}`);
  // inject tags to header
  $('head').append(`${helmet.title.toString()}`);
  $('head').append(`${helmet.meta.toString()}`);
  $('head').append(`${helmet.link.toString()}`);
  $('head').append(`${helmet.script.toString()}`);

  return $.html();
}

async function getFlatRoutes(routes, parentPath = '') {
  return await routes.reduce(async (asyncPrev, route) => {
    let prev = await asyncPrev;
    const { children, path: currentPath, redirect, getStaticPaths } = route;
    if (children) {
      prev = prev.concat(await getFlatRoutes(children, currentPath));
    } else if (!redirect) {
      route.path = join(parentPath, currentPath);
      if (route?.component?.__LOADABLE__) {
        route.component = loadable(route.component.dynamicImport);
      }
      prev.push(route);
      if (typeof getStaticPaths === 'function') {
        const staticPaths = await getStaticPaths();
        if (Array.isArray(staticPaths)) {
          // add static paths to render
          staticPaths.forEach((staticPath) => {
            prev.push({
              ...route,
              path: staticPath
            })
          })
        }
      }
    }
    return prev;
  }, Promise.resolve([]));
}

async function getComponentByPath(routes, currentPath)  {
  async function findMatchRoute(routeList) {
    let matchedRoute = routeList.find(route => {
      return matchPath(currentPath, route);
    });
    if (matchedRoute?.component?.__LOADABLE__) {
      matchedRoute.component = loadable(matchedRoute.component.dynamicImport);
    }
    if (matchedRoute) {
      return matchedRoute.children ? await findMatchRoute(matchedRoute.children) : matchedRoute;
    }
  }
  const routeData = await findMatchRoute(routes)
  return {
    component: routeData?.component,
    getInitialProps: routeData?.getInitialProps
  };
}
