{"version":3,"sources":["webpack:///./src/pages/ui-features/buttons/action-groups/action-groups.component.scss","webpack:///./src/pages/ui-features/grid/grid.component.scss","webpack:///./src/pages/ui-features/buttons/default-buttons/default-buttons.component.html","webpack:///./src/pages/ui-features/buttons/size-buttons/size-buttons.component.scss","webpack:///./src/pages/ui-features/buttons/dropdown-buttons/dropdown-button.component.html","webpack:///./src/pages/ui-features/popovers/popovers.component.html","webpack:///./src/pages/ui-features/tabs/tabs.component.html","webpack:///./src/pages/ui-features/modals/modals.component.scss","webpack:///./src/pages/ui-features/modals/modals.component.html","webpack:///./src/pages/ui-features/buttons/icon-buttons/icon-buttons.component.html","webpack:///./src/pages/ui-features/typography/typography.component.html","webpack:///./src/pages/ui-features/buttons/default-buttons/default-buttons.component.scss","webpack:///./src/pages/ui-features/buttons/block-level-buttons/block-level-buttons.component.html","webpack:///./src/pages/ui-features/buttons/default-buttons/default-buttons.component.ts","webpack:///./src/pages/ui-features/buttons/hero-buttons/hero-buttons.component.ts","webpack:///./src/pages/ui-features/buttons/shape-buttons/shape-buttons.component.ts","webpack:///./src/pages/ui-features/buttons/size-buttons/size-buttons.component.ts","webpack:///./src/pages/ui-features/buttons/buttons.component.ts","webpack:///./src/pages/ui-features/buttons/buttons.module.ts","webpack:///./src/pages/ui-features/buttons/action-groups/action-groups.component.ts","webpack:///./src/pages/ui-features/buttons/dropdown-buttons/dropdown-button.component.ts","webpack:///./src/pages/ui-features/buttons/block-level-buttons/block-level-buttons.component.ts","webpack:///./src/pages/ui-features/buttons/button-groups/button-groups.component.ts","webpack:///./src/pages/ui-features/buttons/icon-buttons/icon-buttons.component.ts","webpack:///./src/pages/ui-features/buttons/labeled-actions-group/labeled-actions-group.component.ts","webpack:///./src/pages/ui-features/ui-features.component.ts","webpack:///./src/pages/ui-features/grid/grid.component.ts","webpack:///./src/pages/ui-features/icons/icons.component.ts","webpack:///./src/pages/ui-features/modals/modal/modal.component.ts","webpack:///./src/pages/ui-features/modals/modals.component.ts","webpack:///./src/pages/ui-features/typography/typography.component.ts","webpack:///./src/pages/ui-features/tabs/tabs.component.ts","webpack:///./src/pages/ui-features/search-fields/search-fields.component.ts","webpack:///./src/pages/ui-features/popovers/popover-examples.component.ts","webpack:///./src/pages/ui-features/popovers/popovers.component.ts","webpack:///./src/pages/ui-features/ui-features-routing.module.ts","webpack:///./src/pages/ui-features/ui-features.module.ts","webpack:///./src/pages/ui-features/buttons/size-buttons/size-buttons.component.html","webpack:///./src/pages/ui-features/icons/icons.component.scss","webpack:///./src/pages/ui-features/grid/grid.component.html","webpack:///./src/pages/ui-features/buttons/buttons.component.html","webpack:///./src/pages/ui-features/buttons/icon-buttons/icon-buttons.component.scss","webpack:///./src/pages/ui-features/popovers/popovers.component.scss","webpack:///./src/pages/ui-features/icons/icons.component.html","webpack:///./src/pages/ui-features/buttons/button-groups/button-groups.component.scss","webpack:///./src/pages/ui-features/typography/typography.component.scss","webpack:///./src/pages/ui-features/buttons/action-groups/action-groups.component.html","webpack:///./src/pages/ui-features/buttons/labeled-actions-group/labeled-actions-group.component.html","webpack:///./src/pages/ui-features/buttons/hero-buttons/hero-buttons.component.scss","webpack:///./src/pages/ui-features/buttons/labeled-actions-group/labeled-actions-group.component.scss","webpack:///./src/pages/ui-features/buttons/hero-buttons/hero-buttons.component.html","webpack:///./src/pages/ui-features/buttons/buttons.component.scss","webpack:///./src/pages/ui-features/buttons/shape-buttons/shape-buttons.component.scss","webpack:///./src/pages/ui-features/buttons/shape-buttons/shape-buttons.component.html","webpack:///./src/pages/ui-features/buttons/button-groups/button-groups.component.html","webpack:///./src/pages/ui-features/buttons/dropdown-buttons/dropdown-button.component.scss","webpack:///./src/pages/ui-features/tabs/tabs.component.scss","webpack:///./src/pages/ui-features/search-fields/search-fields.component.html"],"names":["module","exports","default_buttons_component_DefaultButtonsComponent","DefaultButtonsComponent","this","buttonsViews","title","key","selectedView","buttons","default","class","container","containerTitle","outline","__decorate","Object","core","selector","hero_buttons_component_HeroButtonComponent","HeroButtonComponent","themeService","_this","themeName","themeSubscription","getJsTheme","subscribe","theme","name","init","variables","prototype","colors","settings","buttonTitle","gradientLeft","primary","gradientRight","corporate","color","glow","params","cosmic","bevel","shadow","warning","success","info","danger","border","ngOnDestroy","unsubscribe","hero_buttons_component_decorate","shape_buttons_component_ShapeButtonsComponent","ShapeButtonsComponent","shape_buttons_component_decorate","size_buttons_component_SizeButtonsComponent","SizeButtonsComponent","size_buttons_component_decorate","buttons_component_ButtonsComponent","ButtonsComponent","buttons_component_decorate","components","ActionGroupsComponent","action_groups_component_decorate","DropdownButtonsComponent","dropdown_button_component_decorate","BlockLevelButtonsComponent","block_level_buttons_component_decorate","ButtonGroupsComponent","radioModel","checkboxModel","left","middle","right","dividedCheckboxModel","monday","tuesday","wednesday","thursday","friday","saturday","paginationModel","iconToolbarModel","one","two","three","four","five","dividedButtonGroupOne","dividedButtonGroupTwo","button_groups_component_decorate","IconButtonsComponent","icon_buttons_component_decorate","LabeledActionsGroupComponent","labeled_actions_group_component_decorate","buttons_module_ButtonsModule","ButtonsModule","buttons_module_decorate","imports","theme_module","slice","declarations","providers","ui_features_component_UiFeaturesComponent","UiFeaturesComponent","ui_features_component_decorate","template","grid_component_GridComponent","GridComponent","grid_component_decorate","icons_component_IconsComponent","IconsComponent","icons","nebular","ionicons","fontAwesome","icons_component_decorate","modal_component_ModalComponent","ModalComponent","activeModal","modalContent","closeModal","close","modal_component_decorate","ng_bootstrap","modals_component_ModalsComponent","ModalsComponent","modalService","showLargeModal","open","size","componentInstance","modalHeader","showSmallModal","showStaticModal","backdrop","modals_component_decorate","typography_component_TypographyComponent","TypographyComponent","breakpointService","breakpoints","getBreakpointsMap","onMediaQueryChange","_a","newValue","breakpoint","typography_component_decorate","tabs_component_Tab1Component","Tab1Component","tabs_component_decorate","tabs_component_Tab2Component","Tab2Component","tabs_component_TabsComponent","TabsComponent","tabs","route","search_fields_component_SearchComponent","SearchComponent","search_fields_component_decorate","popover_examples_component_NgxPopoverTabsComponent","NgxPopoverTabsComponent","popover_examples_component_decorate","popover_examples_component_NgxPopoverFormComponent","NgxPopoverFormComponent","popover_examples_component_NgxPopoverCardComponent","NgxPopoverCardComponent","popovers_component_PopoversComponent","PopoversComponent","tabsComponent","cardComponent","formComponent","popovers_component_decorate","routes","path","component","children","redirectTo","pathMatch","ui_features_routing_module_UiFeaturesRoutingModule","UiFeaturesRoutingModule","ui_features_routing_module_decorate","router","forChild","ui_features_module_components","ui_features_module_UiFeaturesModule","UiFeaturesModule","ui_features_module_decorate","entryComponents"],"mappings":"8EAAAA,EAAAC,QAAA,izlCCAAD,EAAAC,QAAA,ms9BCAAD,EAAAC,QAAA,0vDCAAD,EAAAC,QAAA,08+BCAAD,EAAAC,QAAA,8rDCAAD,EAAAC,QAAA,8gNCAAD,EAAAC,QAAA,s+KCAAD,EAAAC,QAAA,wxICAAD,EAAAC,QAAA,+dCAAD,EAAAC,QAAA,0pDCAAD,EAAAC,QAAA,+vWCAAD,EAAAC,QAAA,ix5CCAAD,EAAAC,QAAA,4gCCOAC,EAAA,WALA,SAAAC,IAOEC,KAAAC,eACEC,MAAO,kBACPC,IAAK,YAELD,MAAO,kBACPC,IAAK,YAGPH,KAAAI,aAAeJ,KAAKC,aAAa,GAEjCD,KAAAK,SACEC,UAEIC,MAAO,cACPC,UAAW,oBACXC,eAAgB,iBAChBP,MAAO,UACPI,QAAS,YAETC,MAAO,cACPC,UAAW,oBACXC,eAAgB,iBAChBP,MAAO,UACPI,QAAS,YAETC,MAAO,cACPC,UAAW,oBACXC,eAAgB,iBAChBP,MAAO,UACPI,QAAS,YAETC,MAAO,WACPC,UAAW,iBACXC,eAAgB,cAChBP,MAAO,OACPI,QAAS,YAETC,MAAO,aACPC,UAAW,mBACXC,eAAgB,gBAChBP,MAAO,SACPI,QAAS,YAETC,MAAO,gBACPC,UAAW,sBACXC,eAAgB,iBAChBP,MAAO,UACPI,QAAS,YAIbI,UAEIH,MAAO,sBACPC,UAAW,4BACXC,eAAgB,iBAChBP,MAAO,UACPI,QAAS,YAETC,MAAO,sBACPC,UAAW,4BACXC,eAAgB,iBAChBP,MAAO,UACPI,QAAS,YAETC,MAAO,sBACPC,UAAW,4BACXC,eAAgB,iBAChBP,MAAO,UACPI,QAAS,YAETC,MAAO,mBACPC,UAAW,iBACXC,eAAgB,cAChBP,MAAO,OACPI,QAAS,YAETC,MAAO,qBACPC,UAAW,2BACXC,eAAgB,gBAChBP,MAAO,SACPI,QAAS,YAETC,MAAO,wBACPC,UAAW,8BACXC,eAAgB,iBAChBP,MAAO,UACPI,QAAS,aAIjB,OA7FaP,EAAuBY,GALnCC,OAAAC,EAAA,UAAAD,EACCE,SAAU,+DAICf,GAAb,ocCEAgB,EAAA,WAME,SAAAC,EAAoBC,GAApB,IAAAC,EAAAlB,KAAoBA,KAAAiB,eAJpBjB,KAAAmB,UAAY,UAKVnB,KAAKoB,kBAAoBpB,KAAKiB,aAAaI,aAAaC,UAAU,SAAAC,GAChEL,EAAKC,UAAYI,EAAMC,KACvBN,EAAKO,KAAKF,EAAMG,aAiKtB,OA7JEV,EAAAW,UAAAF,KAAA,SAAKG,GACH5B,KAAK6B,WACHtB,MAAO,mBACPC,UAAW,oBACXN,MAAO,iBACP4B,YAAa,UACbxB,SACEyB,aAAc,cAAcH,EAAOI,QAAO,WAC1CC,cAAeL,EAAOI,SAExBE,WACEC,MAAOP,EAAOI,QACdI,MACEC,OAAQ,aACRF,MAAO,8BAGXG,QACEP,aAAc,cAAcH,EAAOI,QAAO,WAC1CC,cAAeL,EAAOI,QACtBO,MAAO,SAASX,EAAOI,QAAO,SAC9BQ,OAAQ,uBACRJ,MACEC,OAAQ,eACRF,MAAO,cAAcP,EAAOI,QAAO,eAIvCzB,MAAO,mBACPC,UAAW,oBACXN,MAAO,iBACP4B,YAAa,UACbxB,SACEyB,aAAc,cAAcH,EAAOa,QAAO,WAC1CR,cAAeL,EAAOa,SAExBP,WACEC,MAAOP,EAAOa,QACdL,MACEC,OAAQ,aACRF,MAAO,8BAGXG,QACEP,aAAc,cAAcH,EAAOa,QAAO,WAC1CR,cAAeL,EAAOa,QACtBF,MAAO,SAASX,EAAOa,QAAO,SAC9BD,OAAQ,wBACRJ,MACEC,OAAQ,eACRF,MAAO,cAAcP,EAAOa,QAAO,cAIvClC,MAAO,mBACPC,UAAW,oBACXN,MAAO,iBACP4B,YAAa,UACbxB,SACEyB,aAAc,cAAcH,EAAOc,QAAO,WAC1CT,cAAeL,EAAOc,SAExBR,WACEC,MAAOP,EAAOc,QACdN,MACEC,OAAQ,aACRF,MAAO,6BAGXG,QACEP,aAAc,cAAcH,EAAOc,QAAO,WAC1CT,cAAeL,EAAOc,QACtBH,MAAO,SAASX,EAAOc,QAAO,SAC9BF,OAAQ,wBACRJ,MACEC,OAAQ,eACRF,MAAO,cAAcP,EAAOc,QAAO,eAIvCnC,MAAO,gBACPC,UAAW,iBACXN,MAAO,cACP4B,YAAa,OACbxB,SACEyB,aAAc,cAAcH,EAAOe,KAAI,YACvCV,cAAeL,EAAOe,MAExBT,WACEC,MAAOP,EAAOe,KACdP,MACEC,OAAQ,aACRF,MAAO,8BAGXG,QACEP,aAAc,cAAcH,EAAOe,KAAI,YACvCV,cAAeL,EAAOe,KACtBJ,MAAO,SAASX,EAAOe,KAAI,SAC3BH,OAAQ,wBACRJ,MACEC,OAAQ,eACRF,MAAO,cAAcP,EAAOe,KAAI,eAIpCpC,MAAO,kBACPC,UAAW,mBACXN,MAAO,gBACP4B,YAAa,SACbxB,SACEyB,aAAc,cAAcH,EAAOgB,OAAM,YACzCX,cAAeL,EAAOgB,QAExBV,WACEC,MAAOP,EAAOgB,OACdR,MACEC,OAAQ,aACRF,MAAO,8BAGXG,QACEP,aAAc,cAAcH,EAAOgB,OAAM,YACzCX,cAAeL,EAAOgB,OACtBL,MAAO,SAASX,EAAOgB,OAAM,SAC7BJ,OAAQ,wBACRJ,MACEC,OAAQ,eACRF,MAAO,cAAcP,EAAOgB,OAAM,gBAItCrC,MAAO,qBACPC,UAAW,sBACXN,MAAO,eACP4B,YAAa,QACbxB,SACEuC,OAAQ,WAEVX,WACEC,MAAO,WAETG,QACEO,OAAQjB,EAAOI,QACfO,MAAO,UACPC,OAAQ,wBACRJ,MACEC,OAAQ,eACRF,MAAO,+BAMfnB,EAAAW,UAAAmB,YAAA,WACE9C,KAAKoB,kBAAkB2B,eAxKd/B,EAAmBgC,GAL/BpC,OAAAC,EAAA,UAAAD,EACCE,SAAU,kFAUwBS,EAAA,KANvBP,GAAb,yUCFAiC,EAAA,oBAAAC,KACA,OADaA,EAAqBC,GALjCvC,OAAAC,EAAA,UAAAD,EACCE,SAAU,6DAICoC,GAAb,yUCAAE,EAAA,oBAAAC,KACA,OADaA,EAAoBC,GALhC1C,OAAAC,EAAA,UAAAD,EACCE,SAAU,4DAICuC,GAAb,yUCAAE,EAAA,oBAAAC,KACA,OADaA,EAAgBC,GAL5B7C,OAAAC,EAAA,UAAAD,EACCE,SAAU,uDAIC0C,GAAb,6uECQME,GACJH,EACAzD,EACAiB,EACAkC,EACAG,ECbF,oBAAAO,KACA,OADaA,EAAqBC,GALjChD,OAAAC,EAAA,UAAAD,EACCE,SAAU,6DAIC6C,GAAb,GCCA,oBAAAE,KACA,OADaA,EAAwBC,GANpClD,OAAAC,EAAA,UAAAD,EACCE,SAAU,gEAKC+C,GAAb,GCFA,oBAAAE,KACA,OADaA,EAA0BC,GAJtCpD,OAAAC,EAAA,UAAAD,EACCE,SAAU,gDAGCiD,GAAb,GCCA,WALA,SAAAE,IAOEjE,KAAAkE,WAAa,OAEblE,KAAAmE,eACEC,MAAM,EACNC,QAAQ,EACRC,OAAO,GAGTtE,KAAAuE,sBACEC,QAAQ,EACRC,SAAS,EACTC,WAAW,EACXC,UAAU,EACVC,QAAQ,EACRC,UAAU,GAGZ7E,KAAA8E,gBAAkB,EAElB9E,KAAA+E,kBACEC,KAAK,EACLC,KAAK,EACLC,OAAO,EACPC,MAAM,EACNC,MAAM,GAGRpF,KAAAqF,sBAAwB,OAExBrF,KAAAsF,uBACElB,MAAM,EACNC,QAAQ,EACRC,OAAO,GAEX,OApCaL,EAAqBsB,GALjC3E,OAAAC,EAAA,UAAAD,EACCE,SAAU,6DAICmD,GAAb,GCAA,oBAAAuB,KACA,OADaA,EAAoBC,GALhC7E,OAAAC,EAAA,UAAAD,EACCE,SAAU,4DAIC0E,GAAb,GCAA,oBAAAE,KACA,OADaA,EAA4BC,GALxC/E,OAAAC,EAAA,UAAAD,EACCE,SAAU,qEAIC4E,GAAb,IN4BAE,EAAA,oBAAAC,KAA4B,OAAfA,EAAaC,GANzBlF,OAAAC,EAAA,SAAAD,EACCmF,SAAUC,EAAA,GACVnG,QAAa6D,EAAUuC,QACvBC,aAAkBxC,EAAUuC,QAC5BE,gBAEWN,GAAb,qVO3BAO,EAAA,oBAAAC,KACA,OADaA,EAAmBC,GAN/B1F,OAAAC,EAAA,UAAAD,EACCE,SAAU,kBACVyF,SAAU,+CAICF,GAAb,yUCDAG,EAAA,oBAAAC,KAEA,OAFaA,EAAaC,GALzB9F,OAAAC,EAAA,UAAAD,EACCE,SAAU,oDAIC2F,GAAb,yUCAAE,EAAA,WALA,SAAAC,IAOE5G,KAAA6G,OAEEC,SAAU,WAAY,uBAAwB,gBAAiB,oBAAqB,oBAClF,qBAAsB,kBAAmB,gBAAiB,mBAAoB,iBAC9E,qBAAsB,qBAAsB,sBAAuB,mBACnE,cAAe,WAAY,eAAgB,eAAgB,kBAC3D,0BAA2B,kBAAmB,0BAA2B,mBACzE,2BAA4B,gBAAiB,wBAAyB,WACtE,mBAAoB,YAAa,kBAAmB,aAAc,UAAW,WAC7E,mBAAoB,UAAW,YAAa,oBAAqB,YAAa,oBAC9E,WAAY,UAAW,YAAa,mBAAoB,oBAAqB,uBAC7E,yBAA0B,0BAA2B,uBAAwB,eAC7E,UAAW,cAAe,YAAa,UAAW,kBAAmB,UAAW,mBAChF,iBAAkB,iBAAkB,WAAY,mBAAoB,YAAa,WACjF,UAAW,kBAAmB,UAAW,kBAAmB,WAAY,mBACxE,WAAY,mBAAoB,YAAa,aAAc,mBAC3D,2BAA4B,kBAAmB,0BAA2B,mBAC1E,YAAa,oBAAqB,UAAW,WAAY,mBAAoB,YAAa,WAC1F,WAAY,iBAAkB,iBAAkB,UAAW,WAAY,WAEzEC,UACE,YAAa,oBAAqB,mBAAoB,mBAAoB,iBAAkB,oBAC5F,mBAAoB,mBAAoB,yBAA0B,wBAAyB,iBAC3F,mBAAoB,mBAAoB,iBAAkB,mBAAoB,iBAC9E,oBAAqB,mBAAoB,mBAAoB,oBAAqB,cAClF,WAAY,aAAc,cAAe,sBAAuB,gBAAiB,wBACjF,kBAAmB,iBAAkB,kBAAmB,kBAAmB,WAC3E,wBAAyB,gBAAiB,eAAgB,YAAa,oBACvE,cAAe,WAAY,cAAe,WAAY,aAAc,WAAY,WAChF,YAAa,mBAAoB,aAAc,aAAc,oBAAqB,aAClF,eAAgB,aAAc,aAAc,WAAY,cAAe,cACvE,eAAgB,oBAAqB,gBAAiB,eAAgB,aACtE,eAAgB,YAAa,mBAAoB,aAAc,aAAc,cAC7E,YAAa,gBAAiB,eAGhCC,aACE,eAAgB,eAAgB,gBAAiB,mBAAoB,eAAgB,iBACrF,iBAAkB,iBAAkB,WAAY,mBAAoB,YAAa,aACjF,kBAAmB,oBAAqB,gBAAiB,aAAc,YAAa,aACpF,aAAc,eAAgB,mBAAoB,qBAAsB,gBAAiB,mBACzF,sBAAuB,aAAc,aAAc,aAAc,iBAAkB,mBACnF,kBAAmB,YAAa,iBAAkB,mBAAoB,mBAI5E,OAhDaJ,EAAcK,GAL1BrG,OAAAC,EAAA,UAAAD,EACCE,SAAU,qDAIC8F,GAAb,ocCaAM,EAAA,WAOE,SAAAC,EAAoBC,GAAApH,KAAAoH,cAJpBpH,KAAAqH,aAAe,6RASjB,OAHEF,EAAAxF,UAAA2F,WAAA,WACEtH,KAAKoH,YAAYG,SAVRJ,EAAcK,GAjB1B5G,OAAAC,EAAA,UAAAD,EACCE,SAAU,YACVyF,SAAU,ucAsBuBkB,EAAA,KAPtBN,GAAb,wbCVAO,EAAA,WAEE,SAAAC,EAAoBC,GAAA5H,KAAA4H,eAyBtB,OAvBED,EAAAhG,UAAAkG,eAAA,WACsB7H,KAAK4H,aAAaE,KAAKZ,GAAkBa,KAAM,KAAMvH,UAAW,cAExEwH,kBAAkBC,YAAc,eAE9CN,EAAAhG,UAAAuG,eAAA,WACsBlI,KAAK4H,aAAaE,KAAKZ,GAAkBa,KAAM,KAAMvH,UAAW,cAExEwH,kBAAkBC,YAAc,eAG9CN,EAAAhG,UAAAwG,gBAAA,WACE,IAAMf,EAAcpH,KAAK4H,aAAaE,KAAKZ,GACzCa,KAAM,KACNK,SAAU,SACV5H,UAAW,cAGb4G,EAAYY,kBAAkBC,YAAc,eAC5Cb,EAAYY,kBAAkBX,aAAe,kKAvBpCM,EAAeU,GAL3BzH,OAAAC,EAAA,UAAAD,EACCE,SAAU,4EAMwB2G,EAAA,KAFvBE,GAAb,wbCFAW,EAAA,WAKE,SAAAC,EAAoBtH,EACAuH,GADpB,IAAAtH,EAAAlB,KAAoBA,KAAAiB,eACAjB,KAAAwI,oBAElBxI,KAAKyI,YAAczI,KAAKwI,kBAAkBE,oBAC1C1I,KAAKoB,kBAAoBpB,KAAKiB,aAAa0H,qBACxCrH,UAAU,SAACsH,GAACA,EAAA,OAAUC,EAAAD,EAAA,GACrB1H,EAAK4H,WAAaD,IAO1B,OAHEN,EAAA5G,UAAAmB,YAAA,WACE9C,KAAKoB,kBAAkB2B,eAhBdwF,EAAmBQ,GAL/BnI,OAAAC,EAAA,UAAAD,EACCE,SAAU,gFASwBS,EAAA,EACKA,EAAA,KAN5BgH,GAAb,yUCMAS,EAAA,oBAAAC,KAA6B,OAAhBA,EAAaC,GAZzBtI,OAAAC,EAAA,UAAAD,EACCE,SAAU,WACVyF,SAAU,kjBAUC0C,GAAb,GAQAE,EAAA,oBAAAC,KAA6B,OAAhBA,EAAaF,GANzBtI,OAAAC,EAAA,UAAAD,EACCE,SAAU,WACVyF,SAAU,mCAIC6C,GAAb,GAOAC,EAAA,WALA,SAAAC,IAOEtJ,KAAAuJ,OAEIrJ,MAAO,eACPsJ,MAAO,iCAGPtJ,MAAO,eACPsJ,MAAO,iCAIb,OAbaF,EAAaJ,GALzBtI,OAAAC,EAAA,UAAAD,EACCE,SAAU,oDAICwI,GAAb,yUCvBAG,EAAA,oBAAAC,KACA,OADaA,EAAeC,GAJ3B/I,OAAAC,EAAA,UAAAD,EACGE,SAAU,0CAGD4I,GAAb,yUCaAE,EAAA,oBAAAC,KACA,OADaA,EAAuBC,GAjBnClJ,OAAAC,EAAA,UAAAD,EACCE,SAAU,mBACVyF,SAAU,sSAeCsD,GAAb,GAsBAE,EAAA,oBAAAC,KACA,OADaA,EAAuBF,GAnBnClJ,OAAAC,EAAA,UAAAD,EACCE,SAAU,mBACVyF,SAAU,8gBAiBCyD,GAAb,GAkBAC,EAAA,oBAAAC,KACA,OADaA,EAAuBJ,GAfnClJ,OAAAC,EAAA,UAAAD,EACCE,SAAU,mBACVyF,SAAU,gbAaC2D,GAAb,yUChDAC,GAAA,WALA,SAAAC,IAMEpK,KAAAqK,cAAgBT,EAChB5J,KAAAsK,cAAgBL,EAChBjK,KAAAuK,cAAgBR,EAClB,OAJaK,EAAiBI,GAL7B5J,OAAAC,EAAA,UAAAD,EACCE,SAAU,wDAICsJ,GAAb,0UCEMK,KACJC,KAAM,GACNC,UAAWvE,EACXwE,WACEF,KAAM,UACNC,UAAWpH,IAEXmH,KAAM,OACNC,UAAWnE,IAEXkE,KAAM,QACNC,UAAWhE,IAEX+D,KAAM,SACNC,UAAWjD,IAEXgD,KAAM,WACNC,UAAWR,KAEXO,KAAM,aACNC,UAAWrC,IAEXoC,KAAM,gBACNC,UAAWlB,IAEXiB,KAAM,OACNC,UAAWtB,EACXuB,WACEF,KAAM,GACNG,WAAY,OACZC,UAAW,SAEXJ,KAAM,OACNC,UAAW3B,IAEX0B,KAAM,OACNC,UAAWxB,QASjB4B,GAAA,oBAAAC,KAAuC,OAA1BA,EAAuBC,IAJnCrK,OAAAC,EAAA,SAAAD,EACCmF,SAAUmF,EAAA,EAAaC,SAASV,KAChC5K,SAAUqL,EAAA,MAECF,GAAb,8XClCMI,IACJhF,EACAI,EACAkB,EACAf,EACAO,EACAoB,EACAe,EACAL,EACAG,EACAM,EACAU,GACAF,EACAF,EACAH,GAaFyB,GAAA,oBAAAC,KAA+B,OAAlBA,EAAgBC,IAV5B3K,OAAAC,EAAA,SAAAD,EACCmF,SAAUC,EAAA,EAAa+E,GAAyBnF,GAChDM,aAAkBkF,GAAUnF,QAC5BuF,iBACEtE,EACA+C,EACAF,EACAH,MAGS0B,GAAb,yBCnDA1L,EAAAC,QAAA,81CCAAD,EAAAC,QAAA,mWCAAD,EAAAC,QAAA,o+PCAAD,EAAAC,QAAA,szBCAAD,EAAAC,QAAA,6jBCAAD,EAAAC,QAAA,qlJCAAD,EAAAC,QAAA,m1CCAAD,EAAAC,QAAA,gtkCCAAD,EAAAC,QAAA,86xCCAAD,EAAAC,QAAA,8hBCAAD,EAAAC,QAAA,mgBCAAD,EAAAC,QAAA,kk1CCAAD,EAAAC,QAAA,08gCCAAD,EAAAC,QAAA,6yGCAAD,EAAAC,QAAA,o2rCCAAD,EAAAC,QAAA,84/BCAAD,EAAAC,QAAA,8qCCAAD,EAAAC,QAAA,shQCAAD,EAAAC,QAAA,yt7BCAAD,EAAAC,QAAA,wz9BCAAD,EAAAC,QAAA","file":"ui-features-ui-features-module.js","sourcesContent":["module.exports = \"/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/**\\n * This is a starting point where we declare the maps of themes and globally available functions/mixins\\n */\\n/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/**\\n * This mixin generates keyfames.\\n * Because of all keyframes can't be scoped,\\n * we need to puts unique name in each btn-pulse call.\\n */\\n/*\\n\\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\\n:host and :host-context are pseudo-classes. So we assume they could be combined,\\nlike other pseudo-classes, even same ones.\\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\\n\\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\\nso direction could be overridden on any component level.\\n\\nImplementation code:\\n\\n@mixin nb-rtl() {\\n  // add # to scss interpolation statement.\\n  // it works in comments and we can't use it here\\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\\n    @content;\\n  }\\n}\\n\\nAnd when we call it somewhere:\\n\\n:host {\\n  .some-class {\\n    @include nb-rtl() {\\n      ...\\n    }\\n  }\\n}\\n:host-context(...) {\\n  .some-class {\\n    @include nb-rtl() {\\n      ...\\n    }\\n  }\\n}\\n\\nResult will look like:\\n\\n:host-context([dir=rtl]):host .some-class {\\n  ...\\n}\\n:host-context([dir=rtl]):host-context(...) .some-class {\\n  ...\\n}\\n\\n*\\n  Side note:\\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\\n\\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\\n  so order is not important.\\n*\\n\\n\\nCurrently, there're two problems with this approach:\\n\\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\\nFor the moment of writing, the only possible way is:\\n:host {\\n  :host-context(...) {\\n    ...\\n  }\\n}\\nIt doesn't work for us because mixin could be called somewhere deeper, like:\\n:host {\\n  p {\\n    @include nb-rtl() { ... }\\n  }\\n}\\nWe are not able to go up to :host level to place content passed to mixin.\\n\\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\\n  *\\n    Side note:\\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\\n    :host-context($theme) once we will be able to use multiple shadow selectors.\\n  *\\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\\n  ***\\n    Possible solution\\n    check if we in theme by some theme variables and if so append, otherwise nest like\\n    @at-root :host-context([dir=rtl]) {\\n      // add # to scss interpolation statement.\\n      // it works in comments and we can't use it here\\n      {&} {\\n        @content;\\n      }\\n    }\\n    What if :host specified? Can we add space in :host-context(...) :host?\\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\\n  ***\\n\\n\\nProblems with the current approach.\\n\\n1. Direction can be applied only on document level, because mixin prepends theme class,\\nwhich placed on the body.\\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\\nattribute to [dir=rtl] attribute as well.\\n\\n\\nGeneral problems.\\n\\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\\n*/\\n/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/**\\n * This mixin generates keyfames.\\n * Because of all keyframes can't be scoped,\\n * we need to puts unique name in each btn-pulse call.\\n */\\n/*\\n\\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\\n:host and :host-context are pseudo-classes. So we assume they could be combined,\\nlike other pseudo-classes, even same ones.\\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\\n\\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\\nso direction could be overridden on any component level.\\n\\nImplementation code:\\n\\n@mixin nb-rtl() {\\n  // add # to scss interpolation statement.\\n  // it works in comments and we can't use it here\\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\\n    @content;\\n  }\\n}\\n\\nAnd when we call it somewhere:\\n\\n:host {\\n  .some-class {\\n    @include nb-rtl() {\\n      ...\\n    }\\n  }\\n}\\n:host-context(...) {\\n  .some-class {\\n    @include nb-rtl() {\\n      ...\\n    }\\n  }\\n}\\n\\nResult will look like:\\n\\n:host-context([dir=rtl]):host .some-class {\\n  ...\\n}\\n:host-context([dir=rtl]):host-context(...) .some-class {\\n  ...\\n}\\n\\n*\\n  Side note:\\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\\n\\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\\n  so order is not important.\\n*\\n\\n\\nCurrently, there're two problems with this approach:\\n\\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\\nFor the moment of writing, the only possible way is:\\n:host {\\n  :host-context(...) {\\n    ...\\n  }\\n}\\nIt doesn't work for us because mixin could be called somewhere deeper, like:\\n:host {\\n  p {\\n    @include nb-rtl() { ... }\\n  }\\n}\\nWe are not able to go up to :host level to place content passed to mixin.\\n\\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\\n  *\\n    Side note:\\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\\n    :host-context($theme) once we will be able to use multiple shadow selectors.\\n  *\\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\\n  ***\\n    Possible solution\\n    check if we in theme by some theme variables and if so append, otherwise nest like\\n    @at-root :host-context([dir=rtl]) {\\n      // add # to scss interpolation statement.\\n      // it works in comments and we can't use it here\\n      {&} {\\n        @content;\\n      }\\n    }\\n    What if :host specified? Can we add space in :host-context(...) :host?\\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\\n  ***\\n\\n\\nProblems with the current approach.\\n\\n1. Direction can be applied only on document level, because mixin prepends theme class,\\nwhich placed on the body.\\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\\nattribute to [dir=rtl] attribute as well.\\n\\n\\nGeneral problems.\\n\\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\\n*/\\n/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/**\\n * This mixin generates keyfames.\\n * Because of all keyframes can't be scoped,\\n * we need to puts unique name in each btn-pulse call.\\n */\\n/*\\n\\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\\n:host and :host-context are pseudo-classes. So we assume they could be combined,\\nlike other pseudo-classes, even same ones.\\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\\n\\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\\nso direction could be overridden on any component level.\\n\\nImplementation code:\\n\\n@mixin nb-rtl() {\\n  // add # to scss interpolation statement.\\n  // it works in comments and we can't use it here\\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\\n    @content;\\n  }\\n}\\n\\nAnd when we call it somewhere:\\n\\n:host {\\n  .some-class {\\n    @include nb-rtl() {\\n      ...\\n    }\\n  }\\n}\\n:host-context(...) {\\n  .some-class {\\n    @include nb-rtl() {\\n      ...\\n    }\\n  }\\n}\\n\\nResult will look like:\\n\\n:host-context([dir=rtl]):host .some-class {\\n  ...\\n}\\n:host-context([dir=rtl]):host-context(...) .some-class {\\n  ...\\n}\\n\\n*\\n  Side note:\\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\\n\\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\\n  so order is not important.\\n*\\n\\n\\nCurrently, there're two problems with this approach:\\n\\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\\nFor the moment of writing, the only possible way is:\\n:host {\\n  :host-context(...) {\\n    ...\\n  }\\n}\\nIt doesn't work for us because mixin could be called somewhere deeper, like:\\n:host {\\n  p {\\n    @include nb-rtl() { ... }\\n  }\\n}\\nWe are not able to go up to :host level to place content passed to mixin.\\n\\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\\n  *\\n    Side note:\\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\\n    :host-context($theme) once we will be able to use multiple shadow selectors.\\n  *\\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\\n  ***\\n    Possible solution\\n    check if we in theme by some theme variables and if so append, otherwise nest like\\n    @at-root :host-context([dir=rtl]) {\\n      // add # to scss interpolation statement.\\n      // it works in comments and we can't use it here\\n      {&} {\\n        @content;\\n      }\\n    }\\n    What if :host specified? Can we add space in :host-context(...) :host?\\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\\n  ***\\n\\n\\nProblems with the current approach.\\n\\n1. Direction can be applied only on document level, because mixin prepends theme class,\\nwhich placed on the body.\\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\\nattribute to [dir=rtl] attribute as well.\\n\\n\\nGeneral problems.\\n\\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\\n*/\\n/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/**\\n * This mixin generates keyfames.\\n * Because of all keyframes can't be scoped,\\n * we need to puts unique name in each btn-pulse call.\\n */\\n/*\\n\\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\\n:host and :host-context are pseudo-classes. So we assume they could be combined,\\nlike other pseudo-classes, even same ones.\\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\\n\\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\\nso direction could be overridden on any component level.\\n\\nImplementation code:\\n\\n@mixin nb-rtl() {\\n  // add # to scss interpolation statement.\\n  // it works in comments and we can't use it here\\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\\n    @content;\\n  }\\n}\\n\\nAnd when we call it somewhere:\\n\\n:host {\\n  .some-class {\\n    @include nb-rtl() {\\n      ...\\n    }\\n  }\\n}\\n:host-context(...) {\\n  .some-class {\\n    @include nb-rtl() {\\n      ...\\n    }\\n  }\\n}\\n\\nResult will look like:\\n\\n:host-context([dir=rtl]):host .some-class {\\n  ...\\n}\\n:host-context([dir=rtl]):host-context(...) .some-class {\\n  ...\\n}\\n\\n*\\n  Side note:\\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\\n\\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\\n  so order is not important.\\n*\\n\\n\\nCurrently, there're two problems with this approach:\\n\\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\\nFor the moment of writing, the only possible way is:\\n:host {\\n  :host-context(...) {\\n    ...\\n  }\\n}\\nIt doesn't work for us because mixin could be called somewhere deeper, like:\\n:host {\\n  p {\\n    @include nb-rtl() { ... }\\n  }\\n}\\nWe are not able to go up to :host level to place content passed to mixin.\\n\\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\\n  *\\n    Side note:\\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\\n    :host-context($theme) once we will be able to use multiple shadow selectors.\\n  *\\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\\n  ***\\n    Possible solution\\n    check if we in theme by some theme variables and if so append, otherwise nest like\\n    @at-root :host-context([dir=rtl]) {\\n      // add # to scss interpolation statement.\\n      // it works in comments and we can't use it here\\n      {&} {\\n        @content;\\n      }\\n    }\\n    What if :host specified? Can we add space in :host-context(...) :host?\\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\\n  ***\\n\\n\\nProblems with the current approach.\\n\\n1. Direction can be applied only on document level, because mixin prepends theme class,\\nwhich placed on the body.\\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\\nattribute to [dir=rtl] attribute as well.\\n\\n\\nGeneral problems.\\n\\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\\n*/\\n/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/**\\n * This mixin generates keyfames.\\n * Because of all keyframes can't be scoped,\\n * we need to puts unique name in each btn-pulse call.\\n */\\n/*\\n\\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\\n:host and :host-context are pseudo-classes. So we assume they could be combined,\\nlike other pseudo-classes, even same ones.\\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\\n\\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\\nso direction could be overridden on any component level.\\n\\nImplementation code:\\n\\n@mixin nb-rtl() {\\n  // add # to scss interpolation statement.\\n  // it works in comments and we can't use it here\\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\\n    @content;\\n  }\\n}\\n\\nAnd when we call it somewhere:\\n\\n:host {\\n  .some-class {\\n    @include nb-rtl() {\\n      ...\\n    }\\n  }\\n}\\n:host-context(...) {\\n  .some-class {\\n    @include nb-rtl() {\\n      ...\\n    }\\n  }\\n}\\n\\nResult will look like:\\n\\n:host-context([dir=rtl]):host .some-class {\\n  ...\\n}\\n:host-context([dir=rtl]):host-context(...) .some-class {\\n  ...\\n}\\n\\n*\\n  Side note:\\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\\n\\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\\n  so order is not important.\\n*\\n\\n\\nCurrently, there're two problems with this approach:\\n\\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\\nFor the moment of writing, the only possible way is:\\n:host {\\n  :host-context(...) {\\n    ...\\n  }\\n}\\nIt doesn't work for us because mixin could be called somewhere deeper, like:\\n:host {\\n  p {\\n    @include nb-rtl() { ... }\\n  }\\n}\\nWe are not able to go up to :host level to place content passed to mixin.\\n\\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\\n  *\\n    Side note:\\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\\n    :host-context($theme) once we will be able to use multiple shadow selectors.\\n  *\\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\\n  ***\\n    Possible solution\\n    check if we in theme by some theme variables and if so append, otherwise nest like\\n    @at-root :host-context([dir=rtl]) {\\n      // add # to scss interpolation statement.\\n      // it works in comments and we can't use it here\\n      {&} {\\n        @content;\\n      }\\n    }\\n    What if :host specified? Can we add space in :host-context(...) :host?\\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\\n  ***\\n\\n\\nProblems with the current approach.\\n\\n1. Direction can be applied only on document level, because mixin prepends theme class,\\nwhich placed on the body.\\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\\nattribute to [dir=rtl] attribute as well.\\n\\n\\nGeneral problems.\\n\\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\\n*/\\n/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/**\\n * This mixin generates keyfames.\\n * Because of all keyframes can't be scoped,\\n * we need to puts unique name in each btn-pulse call.\\n */\\n/*\\n\\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\\n:host and :host-context are pseudo-classes. So we assume they could be combined,\\nlike other pseudo-classes, even same ones.\\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\\n\\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\\nso direction could be overridden on any component level.\\n\\nImplementation code:\\n\\n@mixin nb-rtl() {\\n  // add # to scss interpolation statement.\\n  // it works in comments and we can't use it here\\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\\n    @content;\\n  }\\n}\\n\\nAnd when we call it somewhere:\\n\\n:host {\\n  .some-class {\\n    @include nb-rtl() {\\n      ...\\n    }\\n  }\\n}\\n:host-context(...) {\\n  .some-class {\\n    @include nb-rtl() {\\n      ...\\n    }\\n  }\\n}\\n\\nResult will look like:\\n\\n:host-context([dir=rtl]):host .some-class {\\n  ...\\n}\\n:host-context([dir=rtl]):host-context(...) .some-class {\\n  ...\\n}\\n\\n*\\n  Side note:\\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\\n\\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\\n  so order is not important.\\n*\\n\\n\\nCurrently, there're two problems with this approach:\\n\\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\\nFor the moment of writing, the only possible way is:\\n:host {\\n  :host-context(...) {\\n    ...\\n  }\\n}\\nIt doesn't work for us because mixin could be called somewhere deeper, like:\\n:host {\\n  p {\\n    @include nb-rtl() { ... }\\n  }\\n}\\nWe are not able to go up to :host level to place content passed to mixin.\\n\\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\\n  *\\n    Side note:\\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\\n    :host-context($theme) once we will be able to use multiple shadow selectors.\\n  *\\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\\n  ***\\n    Possible solution\\n    check if we in theme by some theme variables and if so append, otherwise nest like\\n    @at-root :host-context([dir=rtl]) {\\n      // add # to scss interpolation statement.\\n      // it works in comments and we can't use it here\\n      {&} {\\n        @content;\\n      }\\n    }\\n    What if :host specified? Can we add space in :host-context(...) :host?\\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\\n  ***\\n\\n\\nProblems with the current approach.\\n\\n1. Direction can be applied only on document level, because mixin prepends theme class,\\nwhich placed on the body.\\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\\nattribute to [dir=rtl] attribute as well.\\n\\n\\nGeneral problems.\\n\\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\\n*/\\n/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/*\\n      :host can be prefixed\\n      https://github.com/angular/angular/blob/8d0ee34939f14c07876d222c25b405ed458a34d3/packages/compiler/src/shadow_css.ts#L441\\n\\n      We have to use :host insted of :host-context($theme), to be able to prefix theme class\\n      with something defined inside of @content, by prefixing &.\\n      For example this scss code:\\n        .nb-theme-default {\\n          .some-selector & {\\n            ...\\n          }\\n        }\\n      Will result in next css:\\n        .some-selector .nb-theme-default {\\n          ...\\n        }\\n\\n      It doesn't work with :host-context because angular splitting it in two selectors and removes\\n      prefix in one of the selectors.\\n    */\\n.nb-theme-default :host nb-card-body {\\n  display: -webkit-box;\\n  display: -ms-flexbox;\\n  display: flex;\\n  -webkit-box-align: center;\\n      -ms-flex-align: center;\\n          align-items: center; }\\n.nb-theme-default :host .action-groups-header {\\n  -ms-flex-preferred-size: 20%;\\n      flex-basis: 20%;\\n  color: #2a2a2a;\\n  font-family: Exo;\\n  font-size: 1.125rem;\\n  font-weight: 600; }\\n.nb-theme-default :host .nb-actions {\\n  -ms-flex-preferred-size: 80%;\\n      flex-basis: 80%; }\\n@media (max-width: 767.98px) {\\n  .nb-theme-default :host nb-card-body {\\n    -webkit-box-orient: vertical;\\n    -webkit-box-direction: normal;\\n        -ms-flex-direction: column;\\n            flex-direction: column;\\n    -webkit-box-align: start;\\n        -ms-flex-align: start;\\n            align-items: flex-start;\\n    padding: 0.75rem; }\\n    [dir=ltr] .nb-theme-default :host nb-card-body .action-groups-header {\\n      margin: 0 0 0.5rem 0.25rem; }\\n    [dir=rtl] .nb-theme-default :host nb-card-body .action-groups-header {\\n      margin: 0 0.25rem 0.5rem 0; }\\n  .nb-theme-default :host nb-action {\\n    padding: 0 0.5rem; }\\n    .nb-theme-default :host nb-action /deep/ .control-icon {\\n      font-size: 1.75rem; }\\n  .nb-theme-default :host nb-user /deep/ .user-container {\\n    font-size: 0.875rem; }\\n  .nb-theme-default :host nb-user /deep/ .user-picture {\\n    height: 1.75rem;\\n    width: 1.75rem; } }\\n@media (max-width: 399.98px) {\\n  .nb-theme-default :host nb-action {\\n    padding: 0 0.375rem; }\\n    .nb-theme-default :host nb-action /deep/ .control-icon {\\n      font-size: 1.5rem; }\\n  .nb-theme-default :host nb-user /deep/ .user-container {\\n    font-size: 0.75rem; }\\n  .nb-theme-default :host nb-user /deep/ .user-picture {\\n    height: 1.5rem;\\n    width: 1.5rem; }\\n  .nb-theme-default :host nb-card-body {\\n    padding-left: 0;\\n    padding-right: 0; } }\\n/*\\n      :host can be prefixed\\n      https://github.com/angular/angular/blob/8d0ee34939f14c07876d222c25b405ed458a34d3/packages/compiler/src/shadow_css.ts#L441\\n\\n      We have to use :host insted of :host-context($theme), to be able to prefix theme class\\n      with something defined inside of @content, by prefixing &.\\n      For example this scss code:\\n        .nb-theme-default {\\n          .some-selector & {\\n            ...\\n          }\\n        }\\n      Will result in next css:\\n        .some-selector .nb-theme-default {\\n          ...\\n        }\\n\\n      It doesn't work with :host-context because angular splitting it in two selectors and removes\\n      prefix in one of the selectors.\\n    */\\n.nb-theme-cosmic :host nb-card-body {\\n  display: -webkit-box;\\n  display: -ms-flexbox;\\n  display: flex;\\n  -webkit-box-align: center;\\n      -ms-flex-align: center;\\n          align-items: center; }\\n.nb-theme-cosmic :host .action-groups-header {\\n  -ms-flex-preferred-size: 20%;\\n      flex-basis: 20%;\\n  color: #ffffff;\\n  font-family: Exo;\\n  font-size: 1.125rem;\\n  font-weight: 500; }\\n.nb-theme-cosmic :host .nb-actions {\\n  -ms-flex-preferred-size: 80%;\\n      flex-basis: 80%; }\\n@media (max-width: 767.98px) {\\n  .nb-theme-cosmic :host nb-card-body {\\n    -webkit-box-orient: vertical;\\n    -webkit-box-direction: normal;\\n        -ms-flex-direction: column;\\n            flex-direction: column;\\n    -webkit-box-align: start;\\n        -ms-flex-align: start;\\n            align-items: flex-start;\\n    padding: 0.75rem; }\\n    [dir=ltr] .nb-theme-cosmic :host nb-card-body .action-groups-header {\\n      margin: 0 0 0.5rem 0.25rem; }\\n    [dir=rtl] .nb-theme-cosmic :host nb-card-body .action-groups-header {\\n      margin: 0 0.25rem 0.5rem 0; }\\n  .nb-theme-cosmic :host nb-action {\\n    padding: 0 0.5rem; }\\n    .nb-theme-cosmic :host nb-action /deep/ .control-icon {\\n      font-size: 1.75rem; }\\n  .nb-theme-cosmic :host nb-user /deep/ .user-container {\\n    font-size: 0.875rem; }\\n  .nb-theme-cosmic :host nb-user /deep/ .user-picture {\\n    height: 1.75rem;\\n    width: 1.75rem; } }\\n@media (max-width: 399.98px) {\\n  .nb-theme-cosmic :host nb-action {\\n    padding: 0 0.375rem; }\\n    .nb-theme-cosmic :host nb-action /deep/ .control-icon {\\n      font-size: 1.5rem; }\\n  .nb-theme-cosmic :host nb-user /deep/ .user-container {\\n    font-size: 0.75rem; }\\n  .nb-theme-cosmic :host nb-user /deep/ .user-picture {\\n    height: 1.5rem;\\n    width: 1.5rem; }\\n  .nb-theme-cosmic :host nb-card-body {\\n    padding-left: 0;\\n    padding-right: 0; } }\\n/*\\n      :host can be prefixed\\n      https://github.com/angular/angular/blob/8d0ee34939f14c07876d222c25b405ed458a34d3/packages/compiler/src/shadow_css.ts#L441\\n\\n      We have to use :host insted of :host-context($theme), to be able to prefix theme class\\n      with something defined inside of @content, by prefixing &.\\n      For example this scss code:\\n        .nb-theme-default {\\n          .some-selector & {\\n            ...\\n          }\\n        }\\n      Will result in next css:\\n        .some-selector .nb-theme-default {\\n          ...\\n        }\\n\\n      It doesn't work with :host-context because angular splitting it in two selectors and removes\\n      prefix in one of the selectors.\\n    */\\n.nb-theme-corporate :host nb-card-body {\\n  display: -webkit-box;\\n  display: -ms-flexbox;\\n  display: flex;\\n  -webkit-box-align: center;\\n      -ms-flex-align: center;\\n          align-items: center; }\\n.nb-theme-corporate :host .action-groups-header {\\n  -ms-flex-preferred-size: 20%;\\n      flex-basis: 20%;\\n  color: #181818;\\n  font-family: Exo;\\n  font-size: 1.125rem;\\n  font-weight: 600; }\\n.nb-theme-corporate :host .nb-actions {\\n  -ms-flex-preferred-size: 80%;\\n      flex-basis: 80%; }\\n@media (max-width: 767.98px) {\\n  .nb-theme-corporate :host nb-card-body {\\n    -webkit-box-orient: vertical;\\n    -webkit-box-direction: normal;\\n        -ms-flex-direction: column;\\n            flex-direction: column;\\n    -webkit-box-align: start;\\n        -ms-flex-align: start;\\n            align-items: flex-start;\\n    padding: 0.75rem; }\\n    [dir=ltr] .nb-theme-corporate :host nb-card-body .action-groups-header {\\n      margin: 0 0 0.5rem 0.25rem; }\\n    [dir=rtl] .nb-theme-corporate :host nb-card-body .action-groups-header {\\n      margin: 0 0.25rem 0.5rem 0; }\\n  .nb-theme-corporate :host nb-action {\\n    padding: 0 0.5rem; }\\n    .nb-theme-corporate :host nb-action /deep/ .control-icon {\\n      font-size: 1.75rem; }\\n  .nb-theme-corporate :host nb-user /deep/ .user-container {\\n    font-size: 0.875rem; }\\n  .nb-theme-corporate :host nb-user /deep/ .user-picture {\\n    height: 1.75rem;\\n    width: 1.75rem; } }\\n@media (max-width: 399.98px) {\\n  .nb-theme-corporate :host nb-action {\\n    padding: 0 0.375rem; }\\n    .nb-theme-corporate :host nb-action /deep/ .control-icon {\\n      font-size: 1.5rem; }\\n  .nb-theme-corporate :host nb-user /deep/ .user-container {\\n    font-size: 0.75rem; }\\n  .nb-theme-corporate :host nb-user /deep/ .user-picture {\\n    height: 1.5rem;\\n    width: 1.5rem; }\\n  .nb-theme-corporate :host nb-card-body {\\n    padding-left: 0;\\n    padding-right: 0; } }\\n\"","module.exports = \"/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/**\\n * This is a starting point where we declare the maps of themes and globally available functions/mixins\\n */\\n/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/**\\n * This mixin generates keyfames.\\n * Because of all keyframes can't be scoped,\\n * we need to puts unique name in each btn-pulse call.\\n */\\n/*\\n\\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\\n:host and :host-context are pseudo-classes. So we assume they could be combined,\\nlike other pseudo-classes, even same ones.\\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\\n\\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\\nso direction could be overridden on any component level.\\n\\nImplementation code:\\n\\n@mixin nb-rtl() {\\n  // add # to scss interpolation statement.\\n  // it works in comments and we can't use it here\\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\\n    @content;\\n  }\\n}\\n\\nAnd when we call it somewhere:\\n\\n:host {\\n  .some-class {\\n    @include nb-rtl() {\\n      ...\\n    }\\n  }\\n}\\n:host-context(...) {\\n  .some-class {\\n    @include nb-rtl() {\\n      ...\\n    }\\n  }\\n}\\n\\nResult will look like:\\n\\n:host-context([dir=rtl]):host .some-class {\\n  ...\\n}\\n:host-context([dir=rtl]):host-context(...) .some-class {\\n  ...\\n}\\n\\n*\\n  Side note:\\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\\n\\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\\n  so order is not important.\\n*\\n\\n\\nCurrently, there're two problems with this approach:\\n\\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\\nFor the moment of writing, the only possible way is:\\n:host {\\n  :host-context(...) {\\n    ...\\n  }\\n}\\nIt doesn't work for us because mixin could be called somewhere deeper, like:\\n:host {\\n  p {\\n    @include nb-rtl() { ... }\\n  }\\n}\\nWe are not able to go up to :host level to place content passed to mixin.\\n\\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\\n  *\\n    Side note:\\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\\n    :host-context($theme) once we will be able to use multiple shadow selectors.\\n  *\\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\\n  ***\\n    Possible solution\\n    check if we in theme by some theme variables and if so append, otherwise nest like\\n    @at-root :host-context([dir=rtl]) {\\n      // add # to scss interpolation statement.\\n      // it works in comments and we can't use it here\\n      {&} {\\n        @content;\\n      }\\n    }\\n    What if :host specified? Can we add space in :host-context(...) :host?\\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\\n  ***\\n\\n\\nProblems with the current approach.\\n\\n1. Direction can be applied only on document level, because mixin prepends theme class,\\nwhich placed on the body.\\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\\nattribute to [dir=rtl] attribute as well.\\n\\n\\nGeneral problems.\\n\\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\\n*/\\n/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/**\\n * This mixin generates keyfames.\\n * Because of all keyframes can't be scoped,\\n * we need to puts unique name in each btn-pulse call.\\n */\\n/*\\n\\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\\n:host and :host-context are pseudo-classes. So we assume they could be combined,\\nlike other pseudo-classes, even same ones.\\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\\n\\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\\nso direction could be overridden on any component level.\\n\\nImplementation code:\\n\\n@mixin nb-rtl() {\\n  // add # to scss interpolation statement.\\n  // it works in comments and we can't use it here\\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\\n    @content;\\n  }\\n}\\n\\nAnd when we call it somewhere:\\n\\n:host {\\n  .some-class {\\n    @include nb-rtl() {\\n      ...\\n    }\\n  }\\n}\\n:host-context(...) {\\n  .some-class {\\n    @include nb-rtl() {\\n      ...\\n    }\\n  }\\n}\\n\\nResult will look like:\\n\\n:host-context([dir=rtl]):host .some-class {\\n  ...\\n}\\n:host-context([dir=rtl]):host-context(...) .some-class {\\n  ...\\n}\\n\\n*\\n  Side note:\\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\\n\\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\\n  so order is not important.\\n*\\n\\n\\nCurrently, there're two problems with this approach:\\n\\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\\nFor the moment of writing, the only possible way is:\\n:host {\\n  :host-context(...) {\\n    ...\\n  }\\n}\\nIt doesn't work for us because mixin could be called somewhere deeper, like:\\n:host {\\n  p {\\n    @include nb-rtl() { ... }\\n  }\\n}\\nWe are not able to go up to :host level to place content passed to mixin.\\n\\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\\n  *\\n    Side note:\\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\\n    :host-context($theme) once we will be able to use multiple shadow selectors.\\n  *\\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\\n  ***\\n    Possible solution\\n    check if we in theme by some theme variables and if so append, otherwise nest like\\n    @at-root :host-context([dir=rtl]) {\\n      // add # to scss interpolation statement.\\n      // it works in comments and we can't use it here\\n      {&} {\\n        @content;\\n      }\\n    }\\n    What if :host specified? Can we add space in :host-context(...) :host?\\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\\n  ***\\n\\n\\nProblems with the current approach.\\n\\n1. Direction can be applied only on document level, because mixin prepends theme class,\\nwhich placed on the body.\\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\\nattribute to [dir=rtl] attribute as well.\\n\\n\\nGeneral problems.\\n\\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\\n*/\\n/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/**\\n * This mixin generates keyfames.\\n * Because of all keyframes can't be scoped,\\n * we need to puts unique name in each btn-pulse call.\\n */\\n/*\\n\\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\\n:host and :host-context are pseudo-classes. So we assume they could be combined,\\nlike other pseudo-classes, even same ones.\\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\\n\\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\\nso direction could be overridden on any component level.\\n\\nImplementation code:\\n\\n@mixin nb-rtl() {\\n  // add # to scss interpolation statement.\\n  // it works in comments and we can't use it here\\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\\n    @content;\\n  }\\n}\\n\\nAnd when we call it somewhere:\\n\\n:host {\\n  .some-class {\\n    @include nb-rtl() {\\n      ...\\n    }\\n  }\\n}\\n:host-context(...) {\\n  .some-class {\\n    @include nb-rtl() {\\n      ...\\n    }\\n  }\\n}\\n\\nResult will look like:\\n\\n:host-context([dir=rtl]):host .some-class {\\n  ...\\n}\\n:host-context([dir=rtl]):host-context(...) .some-class {\\n  ...\\n}\\n\\n*\\n  Side note:\\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\\n\\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\\n  so order is not important.\\n*\\n\\n\\nCurrently, there're two problems with this approach:\\n\\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\\nFor the moment of writing, the only possible way is:\\n:host {\\n  :host-context(...) {\\n    ...\\n  }\\n}\\nIt doesn't work for us because mixin could be called somewhere deeper, like:\\n:host {\\n  p {\\n    @include nb-rtl() { ... }\\n  }\\n}\\nWe are not able to go up to :host level to place content passed to mixin.\\n\\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\\n  *\\n    Side note:\\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\\n    :host-context($theme) once we will be able to use multiple shadow selectors.\\n  *\\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\\n  ***\\n    Possible solution\\n    check if we in theme by some theme variables and if so append, otherwise nest like\\n    @at-root :host-context([dir=rtl]) {\\n      // add # to scss interpolation statement.\\n      // it works in comments and we can't use it here\\n      {&} {\\n        @content;\\n      }\\n    }\\n    What if :host specified? Can we add space in :host-context(...) :host?\\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\\n  ***\\n\\n\\nProblems with the current approach.\\n\\n1. Direction can be applied only on document level, because mixin prepends theme class,\\nwhich placed on the body.\\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\\nattribute to [dir=rtl] attribute as well.\\n\\n\\nGeneral problems.\\n\\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\\n*/\\n/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/**\\n * This mixin generates keyfames.\\n * Because of all keyframes can't be scoped,\\n * we need to puts unique name in each btn-pulse call.\\n */\\n/*\\n\\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\\n:host and :host-context are pseudo-classes. So we assume they could be combined,\\nlike other pseudo-classes, even same ones.\\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\\n\\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\\nso direction could be overridden on any component level.\\n\\nImplementation code:\\n\\n@mixin nb-rtl() {\\n  // add # to scss interpolation statement.\\n  // it works in comments and we can't use it here\\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\\n    @content;\\n  }\\n}\\n\\nAnd when we call it somewhere:\\n\\n:host {\\n  .some-class {\\n    @include nb-rtl() {\\n      ...\\n    }\\n  }\\n}\\n:host-context(...) {\\n  .some-class {\\n    @include nb-rtl() {\\n      ...\\n    }\\n  }\\n}\\n\\nResult will look like:\\n\\n:host-context([dir=rtl]):host .some-class {\\n  ...\\n}\\n:host-context([dir=rtl]):host-context(...) .some-class {\\n  ...\\n}\\n\\n*\\n  Side note:\\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\\n\\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\\n  so order is not important.\\n*\\n\\n\\nCurrently, there're two problems with this approach:\\n\\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\\nFor the moment of writing, the only possible way is:\\n:host {\\n  :host-context(...) {\\n    ...\\n  }\\n}\\nIt doesn't work for us because mixin could be called somewhere deeper, like:\\n:host {\\n  p {\\n    @include nb-rtl() { ... }\\n  }\\n}\\nWe are not able to go up to :host level to place content passed to mixin.\\n\\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\\n  *\\n    Side note:\\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\\n    :host-context($theme) once we will be able to use multiple shadow selectors.\\n  *\\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\\n  ***\\n    Possible solution\\n    check if we in theme by some theme variables and if so append, otherwise nest like\\n    @at-root :host-context([dir=rtl]) {\\n      // add # to scss interpolation statement.\\n      // it works in comments and we can't use it here\\n      {&} {\\n        @content;\\n      }\\n    }\\n    What if :host specified? Can we add space in :host-context(...) :host?\\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\\n  ***\\n\\n\\nProblems with the current approach.\\n\\n1. Direction can be applied only on document level, because mixin prepends theme class,\\nwhich placed on the body.\\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\\nattribute to [dir=rtl] attribute as well.\\n\\n\\nGeneral problems.\\n\\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\\n*/\\n/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/**\\n * This mixin generates keyfames.\\n * Because of all keyframes can't be scoped,\\n * we need to puts unique name in each btn-pulse call.\\n */\\n/*\\n\\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\\n:host and :host-context are pseudo-classes. So we assume they could be combined,\\nlike other pseudo-classes, even same ones.\\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\\n\\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\\nso direction could be overridden on any component level.\\n\\nImplementation code:\\n\\n@mixin nb-rtl() {\\n  // add # to scss interpolation statement.\\n  // it works in comments and we can't use it here\\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\\n    @content;\\n  }\\n}\\n\\nAnd when we call it somewhere:\\n\\n:host {\\n  .some-class {\\n    @include nb-rtl() {\\n      ...\\n    }\\n  }\\n}\\n:host-context(...) {\\n  .some-class {\\n    @include nb-rtl() {\\n      ...\\n    }\\n  }\\n}\\n\\nResult will look like:\\n\\n:host-context([dir=rtl]):host .some-class {\\n  ...\\n}\\n:host-context([dir=rtl]):host-context(...) .some-class {\\n  ...\\n}\\n\\n*\\n  Side note:\\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\\n\\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\\n  so order is not important.\\n*\\n\\n\\nCurrently, there're two problems with this approach:\\n\\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\\nFor the moment of writing, the only possible way is:\\n:host {\\n  :host-context(...) {\\n    ...\\n  }\\n}\\nIt doesn't work for us because mixin could be called somewhere deeper, like:\\n:host {\\n  p {\\n    @include nb-rtl() { ... }\\n  }\\n}\\nWe are not able to go up to :host level to place content passed to mixin.\\n\\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\\n  *\\n    Side note:\\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\\n    :host-context($theme) once we will be able to use multiple shadow selectors.\\n  *\\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\\n  ***\\n    Possible solution\\n    check if we in theme by some theme variables and if so append, otherwise nest like\\n    @at-root :host-context([dir=rtl]) {\\n      // add # to scss interpolation statement.\\n      // it works in comments and we can't use it here\\n      {&} {\\n        @content;\\n      }\\n    }\\n    What if :host specified? Can we add space in :host-context(...) :host?\\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\\n  ***\\n\\n\\nProblems with the current approach.\\n\\n1. Direction can be applied only on document level, because mixin prepends theme class,\\nwhich placed on the body.\\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\\nattribute to [dir=rtl] attribute as well.\\n\\n\\nGeneral problems.\\n\\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\\n*/\\n/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/**\\n * This mixin generates keyfames.\\n * Because of all keyframes can't be scoped,\\n * we need to puts unique name in each btn-pulse call.\\n */\\n/*\\n\\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\\n:host and :host-context are pseudo-classes. So we assume they could be combined,\\nlike other pseudo-classes, even same ones.\\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\\n\\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\\nso direction could be overridden on any component level.\\n\\nImplementation code:\\n\\n@mixin nb-rtl() {\\n  // add # to scss interpolation statement.\\n  // it works in comments and we can't use it here\\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\\n    @content;\\n  }\\n}\\n\\nAnd when we call it somewhere:\\n\\n:host {\\n  .some-class {\\n    @include nb-rtl() {\\n      ...\\n    }\\n  }\\n}\\n:host-context(...) {\\n  .some-class {\\n    @include nb-rtl() {\\n      ...\\n    }\\n  }\\n}\\n\\nResult will look like:\\n\\n:host-context([dir=rtl]):host .some-class {\\n  ...\\n}\\n:host-context([dir=rtl]):host-context(...) .some-class {\\n  ...\\n}\\n\\n*\\n  Side note:\\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\\n\\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\\n  so order is not important.\\n*\\n\\n\\nCurrently, there're two problems with this approach:\\n\\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\\nFor the moment of writing, the only possible way is:\\n:host {\\n  :host-context(...) {\\n    ...\\n  }\\n}\\nIt doesn't work for us because mixin could be called somewhere deeper, like:\\n:host {\\n  p {\\n    @include nb-rtl() { ... }\\n  }\\n}\\nWe are not able to go up to :host level to place content passed to mixin.\\n\\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\\n  *\\n    Side note:\\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\\n    :host-context($theme) once we will be able to use multiple shadow selectors.\\n  *\\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\\n  ***\\n    Possible solution\\n    check if we in theme by some theme variables and if so append, otherwise nest like\\n    @at-root :host-context([dir=rtl]) {\\n      // add # to scss interpolation statement.\\n      // it works in comments and we can't use it here\\n      {&} {\\n        @content;\\n      }\\n    }\\n    What if :host specified? Can we add space in :host-context(...) :host?\\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\\n  ***\\n\\n\\nProblems with the current approach.\\n\\n1. Direction can be applied only on document level, because mixin prepends theme class,\\nwhich placed on the body.\\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\\nattribute to [dir=rtl] attribute as well.\\n\\n\\nGeneral problems.\\n\\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\\n*/\\n/*\\n      :host can be prefixed\\n      https://github.com/angular/angular/blob/8d0ee34939f14c07876d222c25b405ed458a34d3/packages/compiler/src/shadow_css.ts#L441\\n\\n      We have to use :host insted of :host-context($theme), to be able to prefix theme class\\n      with something defined inside of @content, by prefixing &.\\n      For example this scss code:\\n        .nb-theme-default {\\n          .some-selector & {\\n            ...\\n          }\\n        }\\n      Will result in next css:\\n        .some-selector .nb-theme-default {\\n          ...\\n        }\\n\\n      It doesn't work with :host-context because angular splitting it in two selectors and removes\\n      prefix in one of the selectors.\\n    */\\n.nb-theme-default :host .show-grid .row {\\n  margin: -0.5rem; }\\n.nb-theme-default :host .show-grid div[class^='col-'] {\\n  padding: 0.5rem;\\n  -webkit-box-sizing: border-box;\\n          box-sizing: border-box; }\\n.nb-theme-default :host .show-grid div[class^='col-'] div {\\n    text-align: center;\\n    background-color: #e9edf2;\\n    padding: 0.75rem 0.25rem;\\n    border-radius: 0.25rem; }\\n.nb-theme-default :host .grid-h {\\n  margin-top: 1.5rem; }\\n.nb-theme-default :host .grid-h:first-child {\\n    margin-top: 0; }\\n.nb-theme-default :host .table-responsive {\\n  margin-top: 1rem; }\\n/*\\n      :host can be prefixed\\n      https://github.com/angular/angular/blob/8d0ee34939f14c07876d222c25b405ed458a34d3/packages/compiler/src/shadow_css.ts#L441\\n\\n      We have to use :host insted of :host-context($theme), to be able to prefix theme class\\n      with something defined inside of @content, by prefixing &.\\n      For example this scss code:\\n        .nb-theme-default {\\n          .some-selector & {\\n            ...\\n          }\\n        }\\n      Will result in next css:\\n        .some-selector .nb-theme-default {\\n          ...\\n        }\\n\\n      It doesn't work with :host-context because angular splitting it in two selectors and removes\\n      prefix in one of the selectors.\\n    */\\n.nb-theme-cosmic :host .show-grid .row {\\n  margin: -0.5rem; }\\n.nb-theme-cosmic :host .show-grid div[class^='col-'] {\\n  padding: 0.5rem;\\n  -webkit-box-sizing: border-box;\\n          box-sizing: border-box; }\\n.nb-theme-cosmic :host .show-grid div[class^='col-'] div {\\n    text-align: center;\\n    background-color: #494299;\\n    padding: 0.75rem 0.25rem;\\n    border-radius: 0.25rem; }\\n.nb-theme-cosmic :host .grid-h {\\n  margin-top: 1.5rem; }\\n.nb-theme-cosmic :host .grid-h:first-child {\\n    margin-top: 0; }\\n.nb-theme-cosmic :host .table-responsive {\\n  margin-top: 1rem; }\\n/*\\n      :host can be prefixed\\n      https://github.com/angular/angular/blob/8d0ee34939f14c07876d222c25b405ed458a34d3/packages/compiler/src/shadow_css.ts#L441\\n\\n      We have to use :host insted of :host-context($theme), to be able to prefix theme class\\n      with something defined inside of @content, by prefixing &.\\n      For example this scss code:\\n        .nb-theme-default {\\n          .some-selector & {\\n            ...\\n          }\\n        }\\n      Will result in next css:\\n        .some-selector .nb-theme-default {\\n          ...\\n        }\\n\\n      It doesn't work with :host-context because angular splitting it in two selectors and removes\\n      prefix in one of the selectors.\\n    */\\n.nb-theme-corporate :host .show-grid .row {\\n  margin: -0.5rem; }\\n.nb-theme-corporate :host .show-grid div[class^='col-'] {\\n  padding: 0.5rem;\\n  -webkit-box-sizing: border-box;\\n          box-sizing: border-box; }\\n.nb-theme-corporate :host .show-grid div[class^='col-'] div {\\n    text-align: center;\\n    background-color: #e9edf2;\\n    padding: 0.75rem 0.25rem;\\n    border-radius: 0.25rem; }\\n.nb-theme-corporate :host .grid-h {\\n  margin-top: 1.5rem; }\\n.nb-theme-corporate :host .grid-h:first-child {\\n    margin-top: 0; }\\n.nb-theme-corporate :host .table-responsive {\\n  margin-top: 1rem; }\\n\"","module.exports = \"<nb-card>\\n  <nb-card-header>\\n    <span>Default Buttons</span>\\n    <div class=\\\"dropdown\\\" ngbDropdown>\\n      <button class=\\\"btn btn-primary\\\" type=\\\"button\\\" ngbDropdownToggle>\\n        {{ selectedView.title }}\\n      </button>\\n      <ul class=\\\"dropdown-menu\\\" ngbDropdownMenu>\\n        <li class=\\\"dropdown-item\\\" *ngFor=\\\"let v of buttonsViews\\\" (click)=\\\"this.selectedView = v\\\">{{ v.title }}</li>\\n      </ul>\\n    </div>\\n  </nb-card-header>\\n  <nb-card-body>\\n    <div class=\\\"row\\\">\\n      <div class=\\\"example-container col-md-4\\\" *ngFor=\\\"let b of buttons[selectedView.key]\\\">\\n        <div class=\\\"container-title\\\">\\n          <span>{{ b.containerTitle }}</span>\\n        </div>\\n        <div class=\\\"container-btn\\\">\\n          <button class=\\\"btn {{ b.class }} btn-demo\\\">{{ b.title }}</button>\\n        </div>\\n        <div class=\\\"{{ b.container }}\\\">\\n          <div class=\\\"state-container\\\">\\n            <div class=\\\"state-value original\\\"></div>\\n            <div class=\\\"state-details\\\">\\n              <span class=\\\"header\\\">Default</span>\\n              <span class=\\\"subheader\\\">{{ b.default }}</span>\\n            </div>\\n          </div>\\n          <div class=\\\"state-container\\\">\\n            <div class=\\\"state-value hover\\\"></div>\\n            <div class=\\\"state-details\\\">\\n              <span class=\\\"header\\\">Hover</span>\\n              <span class=\\\"subheader\\\">14% white</span>\\n            </div>\\n          </div>\\n          <div class=\\\"state-container\\\">\\n            <div class=\\\"state-value active\\\"></div>\\n            <div class=\\\"state-details\\\">\\n              <span class=\\\"header\\\">Active</span>\\n              <span class=\\\"subheader\\\">14% black</span>\\n            </div>\\n          </div>\\n        </div>\\n      </div>\\n    </div>\\n  </nb-card-body>\\n</nb-card>\\n\"","module.exports = \"/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/**\\n * This is a starting point where we declare the maps of themes and globally available functions/mixins\\n */\\n/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/**\\n * This mixin generates keyfames.\\n * Because of all keyframes can't be scoped,\\n * we need to puts unique name in each btn-pulse call.\\n */\\n/*\\n\\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\\n:host and :host-context are pseudo-classes. So we assume they could be combined,\\nlike other pseudo-classes, even same ones.\\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\\n\\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\\nso direction could be overridden on any component level.\\n\\nImplementation code:\\n\\n@mixin nb-rtl() {\\n  // add # to scss interpolation statement.\\n  // it works in comments and we can't use it here\\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\\n    @content;\\n  }\\n}\\n\\nAnd when we call it somewhere:\\n\\n:host {\\n  .some-class {\\n    @include nb-rtl() {\\n      ...\\n    }\\n  }\\n}\\n:host-context(...) {\\n  .some-class {\\n    @include nb-rtl() {\\n      ...\\n    }\\n  }\\n}\\n\\nResult will look like:\\n\\n:host-context([dir=rtl]):host .some-class {\\n  ...\\n}\\n:host-context([dir=rtl]):host-context(...) .some-class {\\n  ...\\n}\\n\\n*\\n  Side note:\\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\\n\\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\\n  so order is not important.\\n*\\n\\n\\nCurrently, there're two problems with this approach:\\n\\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\\nFor the moment of writing, the only possible way is:\\n:host {\\n  :host-context(...) {\\n    ...\\n  }\\n}\\nIt doesn't work for us because mixin could be called somewhere deeper, like:\\n:host {\\n  p {\\n    @include nb-rtl() { ... }\\n  }\\n}\\nWe are not able to go up to :host level to place content passed to mixin.\\n\\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\\n  *\\n    Side note:\\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\\n    :host-context($theme) once we will be able to use multiple shadow selectors.\\n  *\\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\\n  ***\\n    Possible solution\\n    check if we in theme by some theme variables and if so append, otherwise nest like\\n    @at-root :host-context([dir=rtl]) {\\n      // add # to scss interpolation statement.\\n      // it works in comments and we can't use it here\\n      {&} {\\n        @content;\\n      }\\n    }\\n    What if :host specified? Can we add space in :host-context(...) :host?\\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\\n  ***\\n\\n\\nProblems with the current approach.\\n\\n1. Direction can be applied only on document level, because mixin prepends theme class,\\nwhich placed on the body.\\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\\nattribute to [dir=rtl] attribute as well.\\n\\n\\nGeneral problems.\\n\\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\\n*/\\n/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/**\\n * This mixin generates keyfames.\\n * Because of all keyframes can't be scoped,\\n * we need to puts unique name in each btn-pulse call.\\n */\\n/*\\n\\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\\n:host and :host-context are pseudo-classes. So we assume they could be combined,\\nlike other pseudo-classes, even same ones.\\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\\n\\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\\nso direction could be overridden on any component level.\\n\\nImplementation code:\\n\\n@mixin nb-rtl() {\\n  // add # to scss interpolation statement.\\n  // it works in comments and we can't use it here\\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\\n    @content;\\n  }\\n}\\n\\nAnd when we call it somewhere:\\n\\n:host {\\n  .some-class {\\n    @include nb-rtl() {\\n      ...\\n    }\\n  }\\n}\\n:host-context(...) {\\n  .some-class {\\n    @include nb-rtl() {\\n      ...\\n    }\\n  }\\n}\\n\\nResult will look like:\\n\\n:host-context([dir=rtl]):host .some-class {\\n  ...\\n}\\n:host-context([dir=rtl]):host-context(...) .some-class {\\n  ...\\n}\\n\\n*\\n  Side note:\\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\\n\\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\\n  so order is not important.\\n*\\n\\n\\nCurrently, there're two problems with this approach:\\n\\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\\nFor the moment of writing, the only possible way is:\\n:host {\\n  :host-context(...) {\\n    ...\\n  }\\n}\\nIt doesn't work for us because mixin could be called somewhere deeper, like:\\n:host {\\n  p {\\n    @include nb-rtl() { ... }\\n  }\\n}\\nWe are not able to go up to :host level to place content passed to mixin.\\n\\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\\n  *\\n    Side note:\\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\\n    :host-context($theme) once we will be able to use multiple shadow selectors.\\n  *\\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\\n  ***\\n    Possible solution\\n    check if we in theme by some theme variables and if so append, otherwise nest like\\n    @at-root :host-context([dir=rtl]) {\\n      // add # to scss interpolation statement.\\n      // it works in comments and we can't use it here\\n      {&} {\\n        @content;\\n      }\\n    }\\n    What if :host specified? Can we add space in :host-context(...) :host?\\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\\n  ***\\n\\n\\nProblems with the current approach.\\n\\n1. Direction can be applied only on document level, because mixin prepends theme class,\\nwhich placed on the body.\\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\\nattribute to [dir=rtl] attribute as well.\\n\\n\\nGeneral problems.\\n\\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\\n*/\\n/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/**\\n * This mixin generates keyfames.\\n * Because of all keyframes can't be scoped,\\n * we need to puts unique name in each btn-pulse call.\\n */\\n/*\\n\\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\\n:host and :host-context are pseudo-classes. So we assume they could be combined,\\nlike other pseudo-classes, even same ones.\\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\\n\\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\\nso direction could be overridden on any component level.\\n\\nImplementation code:\\n\\n@mixin nb-rtl() {\\n  // add # to scss interpolation statement.\\n  // it works in comments and we can't use it here\\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\\n    @content;\\n  }\\n}\\n\\nAnd when we call it somewhere:\\n\\n:host {\\n  .some-class {\\n    @include nb-rtl() {\\n      ...\\n    }\\n  }\\n}\\n:host-context(...) {\\n  .some-class {\\n    @include nb-rtl() {\\n      ...\\n    }\\n  }\\n}\\n\\nResult will look like:\\n\\n:host-context([dir=rtl]):host .some-class {\\n  ...\\n}\\n:host-context([dir=rtl]):host-context(...) .some-class {\\n  ...\\n}\\n\\n*\\n  Side note:\\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\\n\\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\\n  so order is not important.\\n*\\n\\n\\nCurrently, there're two problems with this approach:\\n\\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\\nFor the moment of writing, the only possible way is:\\n:host {\\n  :host-context(...) {\\n    ...\\n  }\\n}\\nIt doesn't work for us because mixin could be called somewhere deeper, like:\\n:host {\\n  p {\\n    @include nb-rtl() { ... }\\n  }\\n}\\nWe are not able to go up to :host level to place content passed to mixin.\\n\\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\\n  *\\n    Side note:\\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\\n    :host-context($theme) once we will be able to use multiple shadow selectors.\\n  *\\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\\n  ***\\n    Possible solution\\n    check if we in theme by some theme variables and if so append, otherwise nest like\\n    @at-root :host-context([dir=rtl]) {\\n      // add # to scss interpolation statement.\\n      // it works in comments and we can't use it here\\n      {&} {\\n        @content;\\n      }\\n    }\\n    What if :host specified? Can we add space in :host-context(...) :host?\\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\\n  ***\\n\\n\\nProblems with the current approach.\\n\\n1. Direction can be applied only on document level, because mixin prepends theme class,\\nwhich placed on the body.\\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\\nattribute to [dir=rtl] attribute as well.\\n\\n\\nGeneral problems.\\n\\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\\n*/\\n/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/**\\n * This mixin generates keyfames.\\n * Because of all keyframes can't be scoped,\\n * we need to puts unique name in each btn-pulse call.\\n */\\n/*\\n\\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\\n:host and :host-context are pseudo-classes. So we assume they could be combined,\\nlike other pseudo-classes, even same ones.\\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\\n\\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\\nso direction could be overridden on any component level.\\n\\nImplementation code:\\n\\n@mixin nb-rtl() {\\n  // add # to scss interpolation statement.\\n  // it works in comments and we can't use it here\\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\\n    @content;\\n  }\\n}\\n\\nAnd when we call it somewhere:\\n\\n:host {\\n  .some-class {\\n    @include nb-rtl() {\\n      ...\\n    }\\n  }\\n}\\n:host-context(...) {\\n  .some-class {\\n    @include nb-rtl() {\\n      ...\\n    }\\n  }\\n}\\n\\nResult will look like:\\n\\n:host-context([dir=rtl]):host .some-class {\\n  ...\\n}\\n:host-context([dir=rtl]):host-context(...) .some-class {\\n  ...\\n}\\n\\n*\\n  Side note:\\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\\n\\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\\n  so order is not important.\\n*\\n\\n\\nCurrently, there're two problems with this approach:\\n\\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\\nFor the moment of writing, the only possible way is:\\n:host {\\n  :host-context(...) {\\n    ...\\n  }\\n}\\nIt doesn't work for us because mixin could be called somewhere deeper, like:\\n:host {\\n  p {\\n    @include nb-rtl() { ... }\\n  }\\n}\\nWe are not able to go up to :host level to place content passed to mixin.\\n\\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\\n  *\\n    Side note:\\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\\n    :host-context($theme) once we will be able to use multiple shadow selectors.\\n  *\\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\\n  ***\\n    Possible solution\\n    check if we in theme by some theme variables and if so append, otherwise nest like\\n    @at-root :host-context([dir=rtl]) {\\n      // add # to scss interpolation statement.\\n      // it works in comments and we can't use it here\\n      {&} {\\n        @content;\\n      }\\n    }\\n    What if :host specified? Can we add space in :host-context(...) :host?\\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\\n  ***\\n\\n\\nProblems with the current approach.\\n\\n1. Direction can be applied only on document level, because mixin prepends theme class,\\nwhich placed on the body.\\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\\nattribute to [dir=rtl] attribute as well.\\n\\n\\nGeneral problems.\\n\\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\\n*/\\n/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/**\\n * This mixin generates keyfames.\\n * Because of all keyframes can't be scoped,\\n * we need to puts unique name in each btn-pulse call.\\n */\\n/*\\n\\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\\n:host and :host-context are pseudo-classes. So we assume they could be combined,\\nlike other pseudo-classes, even same ones.\\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\\n\\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\\nso direction could be overridden on any component level.\\n\\nImplementation code:\\n\\n@mixin nb-rtl() {\\n  // add # to scss interpolation statement.\\n  // it works in comments and we can't use it here\\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\\n    @content;\\n  }\\n}\\n\\nAnd when we call it somewhere:\\n\\n:host {\\n  .some-class {\\n    @include nb-rtl() {\\n      ...\\n    }\\n  }\\n}\\n:host-context(...) {\\n  .some-class {\\n    @include nb-rtl() {\\n      ...\\n    }\\n  }\\n}\\n\\nResult will look like:\\n\\n:host-context([dir=rtl]):host .some-class {\\n  ...\\n}\\n:host-context([dir=rtl]):host-context(...) .some-class {\\n  ...\\n}\\n\\n*\\n  Side note:\\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\\n\\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\\n  so order is not important.\\n*\\n\\n\\nCurrently, there're two problems with this approach:\\n\\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\\nFor the moment of writing, the only possible way is:\\n:host {\\n  :host-context(...) {\\n    ...\\n  }\\n}\\nIt doesn't work for us because mixin could be called somewhere deeper, like:\\n:host {\\n  p {\\n    @include nb-rtl() { ... }\\n  }\\n}\\nWe are not able to go up to :host level to place content passed to mixin.\\n\\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\\n  *\\n    Side note:\\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\\n    :host-context($theme) once we will be able to use multiple shadow selectors.\\n  *\\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\\n  ***\\n    Possible solution\\n    check if we in theme by some theme variables and if so append, otherwise nest like\\n    @at-root :host-context([dir=rtl]) {\\n      // add # to scss interpolation statement.\\n      // it works in comments and we can't use it here\\n      {&} {\\n        @content;\\n      }\\n    }\\n    What if :host specified? Can we add space in :host-context(...) :host?\\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\\n  ***\\n\\n\\nProblems with the current approach.\\n\\n1. Direction can be applied only on document level, because mixin prepends theme class,\\nwhich placed on the body.\\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\\nattribute to [dir=rtl] attribute as well.\\n\\n\\nGeneral problems.\\n\\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\\n*/\\n/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/**\\n * This mixin generates keyfames.\\n * Because of all keyframes can't be scoped,\\n * we need to puts unique name in each btn-pulse call.\\n */\\n/*\\n\\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\\n:host and :host-context are pseudo-classes. So we assume they could be combined,\\nlike other pseudo-classes, even same ones.\\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\\n\\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\\nso direction could be overridden on any component level.\\n\\nImplementation code:\\n\\n@mixin nb-rtl() {\\n  // add # to scss interpolation statement.\\n  // it works in comments and we can't use it here\\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\\n    @content;\\n  }\\n}\\n\\nAnd when we call it somewhere:\\n\\n:host {\\n  .some-class {\\n    @include nb-rtl() {\\n      ...\\n    }\\n  }\\n}\\n:host-context(...) {\\n  .some-class {\\n    @include nb-rtl() {\\n      ...\\n    }\\n  }\\n}\\n\\nResult will look like:\\n\\n:host-context([dir=rtl]):host .some-class {\\n  ...\\n}\\n:host-context([dir=rtl]):host-context(...) .some-class {\\n  ...\\n}\\n\\n*\\n  Side note:\\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\\n\\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\\n  so order is not important.\\n*\\n\\n\\nCurrently, there're two problems with this approach:\\n\\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\\nFor the moment of writing, the only possible way is:\\n:host {\\n  :host-context(...) {\\n    ...\\n  }\\n}\\nIt doesn't work for us because mixin could be called somewhere deeper, like:\\n:host {\\n  p {\\n    @include nb-rtl() { ... }\\n  }\\n}\\nWe are not able to go up to :host level to place content passed to mixin.\\n\\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\\n  *\\n    Side note:\\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\\n    :host-context($theme) once we will be able to use multiple shadow selectors.\\n  *\\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\\n  ***\\n    Possible solution\\n    check if we in theme by some theme variables and if so append, otherwise nest like\\n    @at-root :host-context([dir=rtl]) {\\n      // add # to scss interpolation statement.\\n      // it works in comments and we can't use it here\\n      {&} {\\n        @content;\\n      }\\n    }\\n    What if :host specified? Can we add space in :host-context(...) :host?\\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\\n  ***\\n\\n\\nProblems with the current approach.\\n\\n1. Direction can be applied only on document level, because mixin prepends theme class,\\nwhich placed on the body.\\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\\nattribute to [dir=rtl] attribute as well.\\n\\n\\nGeneral problems.\\n\\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\\n*/\\n/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/*\\n      :host can be prefixed\\n      https://github.com/angular/angular/blob/8d0ee34939f14c07876d222c25b405ed458a34d3/packages/compiler/src/shadow_css.ts#L441\\n\\n      We have to use :host insted of :host-context($theme), to be able to prefix theme class\\n      with something defined inside of @content, by prefixing &.\\n      For example this scss code:\\n        .nb-theme-default {\\n          .some-selector & {\\n            ...\\n          }\\n        }\\n      Will result in next css:\\n        .some-selector .nb-theme-default {\\n          ...\\n        }\\n\\n      It doesn't work with :host-context because angular splitting it in two selectors and removes\\n      prefix in one of the selectors.\\n    */\\n.nb-theme-default :host nb-card-body {\\n  padding: 0 1.25rem 1.25rem 0;\\n  display: -webkit-box;\\n  display: -ms-flexbox;\\n  display: flex;\\n  -ms-flex-wrap: wrap;\\n      flex-wrap: wrap; }\\n.nb-theme-default :host .container-title {\\n  margin-bottom: 0.25rem; }\\n.nb-theme-default :host .size-container {\\n  margin: 1.25rem 0 0 1.25rem; }\\n.nb-theme-default :host .subheader {\\n  margin-bottom: 0.75rem;\\n  font-size: 0.875rem;\\n  font-weight: 500;\\n  color: #2a2a2a; }\\n/*\\n      :host can be prefixed\\n      https://github.com/angular/angular/blob/8d0ee34939f14c07876d222c25b405ed458a34d3/packages/compiler/src/shadow_css.ts#L441\\n\\n      We have to use :host insted of :host-context($theme), to be able to prefix theme class\\n      with something defined inside of @content, by prefixing &.\\n      For example this scss code:\\n        .nb-theme-default {\\n          .some-selector & {\\n            ...\\n          }\\n        }\\n      Will result in next css:\\n        .some-selector .nb-theme-default {\\n          ...\\n        }\\n\\n      It doesn't work with :host-context because angular splitting it in two selectors and removes\\n      prefix in one of the selectors.\\n    */\\n.nb-theme-cosmic :host nb-card-body {\\n  padding: 0 1.25rem 1.25rem 0;\\n  display: -webkit-box;\\n  display: -ms-flexbox;\\n  display: flex;\\n  -ms-flex-wrap: wrap;\\n      flex-wrap: wrap; }\\n.nb-theme-cosmic :host .container-title {\\n  margin-bottom: 0.25rem; }\\n.nb-theme-cosmic :host .size-container {\\n  margin: 1.25rem 0 0 1.25rem; }\\n.nb-theme-cosmic :host .subheader {\\n  margin-bottom: 0.75rem;\\n  font-size: 0.875rem;\\n  font-weight: 500;\\n  color: #ffffff; }\\n/*\\n      :host can be prefixed\\n      https://github.com/angular/angular/blob/8d0ee34939f14c07876d222c25b405ed458a34d3/packages/compiler/src/shadow_css.ts#L441\\n\\n      We have to use :host insted of :host-context($theme), to be able to prefix theme class\\n      with something defined inside of @content, by prefixing &.\\n      For example this scss code:\\n        .nb-theme-default {\\n          .some-selector & {\\n            ...\\n          }\\n        }\\n      Will result in next css:\\n        .some-selector .nb-theme-default {\\n          ...\\n        }\\n\\n      It doesn't work with :host-context because angular splitting it in two selectors and removes\\n      prefix in one of the selectors.\\n    */\\n.nb-theme-corporate :host nb-card-body {\\n  padding: 0 1.25rem 1.25rem 0;\\n  display: -webkit-box;\\n  display: -ms-flexbox;\\n  display: flex;\\n  -ms-flex-wrap: wrap;\\n      flex-wrap: wrap; }\\n.nb-theme-corporate :host .container-title {\\n  margin-bottom: 0.25rem; }\\n.nb-theme-corporate :host .size-container {\\n  margin: 1.25rem 0 0 1.25rem; }\\n.nb-theme-corporate :host .subheader {\\n  margin-bottom: 0.75rem;\\n  font-size: 0.875rem;\\n  font-weight: 500;\\n  color: #181818; }\\n\"","module.exports = \"<nb-card>\\n  <nb-card-header>Button Dropdowns</nb-card-header>\\n  <nb-card-body>\\n    <div class=\\\"dropdown btn-group\\\" ngbDropdown>\\n      <button type=\\\"button\\\" class=\\\"btn btn-primary\\\">Dropdown</button>\\n      <button type=\\\"button\\\" class=\\\"btn btn-primary\\\" ngbDropdownToggle></button>\\n      <ul class=\\\"dropdown-menu\\\" ngbDropdownMenu>\\n        <li class=\\\"dropdown-item\\\">Icon Button</li>\\n        <li class=\\\"dropdown-item\\\">Hero Button</li>\\n        <li class=\\\"dropdown-item\\\">Default</li>\\n      </ul>\\n    </div>\\n    <div class=\\\"dropdown\\\" ngbDropdown>\\n      <button class=\\\"btn btn-primary\\\" type=\\\"button\\\" ngbDropdownToggle>\\n        Dropdown\\n      </button>\\n      <ul class=\\\"dropdown-menu\\\" ngbDropdownMenu>\\n        <li class=\\\"dropdown-item\\\">Icon Button</li>\\n        <li class=\\\"dropdown-item\\\">Hero Button</li>\\n        <li class=\\\"dropdown-item\\\">Default</li>\\n      </ul>\\n    </div>\\n    <div class=\\\"dropdown\\\" placement=\\\"top\\\" ngbDropdown>\\n      <button class=\\\"btn btn-outline-primary\\\" type=\\\"button\\\" ngbDropdownToggle>\\n        Dropup\\n      </button>\\n      <ul class=\\\"dropdown-menu\\\" ngbDropdownMenu>\\n        <li class=\\\"dropdown-item\\\">Icon Button</li>\\n        <li class=\\\"dropdown-item\\\">Hero Button</li>\\n        <li class=\\\"dropdown-item\\\">Default</li>\\n      </ul>\\n    </div>\\n    <div class=\\\"dropdown ghost-dropdown\\\" ngbDropdown>\\n      <button class=\\\"btn btn-primary\\\" type=\\\"button\\\" ngbDropdownToggle>\\n        Dropdown\\n      </button>\\n      <ul class=\\\"dropdown-menu\\\" ngbDropdownMenu>\\n        <li class=\\\"dropdown-item\\\">Icon Button</li>\\n        <li class=\\\"dropdown-item\\\">Hero Button</li>\\n        <li class=\\\"dropdown-item\\\">Default</li>\\n      </ul>\\n    </div>\\n  </nb-card-body>\\n</nb-card>\\n\"","module.exports = \"<div class=\\\"row\\\">\\n  <div class=\\\"col-lg-6\\\">\\n    <nb-card size=\\\"small\\\">\\n      <nb-card-header>Popover Position</nb-card-header>\\n      <nb-card-body>\\n        <p>When popover has not enough space based on the configured placement, it will adjust accordingly trying to fit the screen.</p>\\n        <button class=\\\"btn btn-danger with-margins\\\" nbPopover=\\\"Hello, how are you today?\\\" nbPopoverMode=\\\"hint\\\" nbPopoverPlacement=\\\"left\\\">Left</button>\\n        <button class=\\\"btn btn-danger with-margins\\\" nbPopover=\\\"Hello, how are you today?\\\" nbPopoverMode=\\\"hint\\\" nbPopoverPlacement=\\\"top\\\">Top</button>\\n        <button class=\\\"btn btn-danger with-margins\\\" nbPopover=\\\"Hello, how are you today?\\\" nbPopoverMode=\\\"hint\\\" nbPopoverPlacement=\\\"bottom\\\">Bottom</button>\\n        <button class=\\\"btn btn-danger with-margins\\\" nbPopover=\\\"Hello, how are you today?\\\" nbPopoverMode=\\\"hint\\\" nbPopoverPlacement=\\\"right\\\">Right</button>\\n      </nb-card-body>\\n    </nb-card>\\n  </div>\\n\\n  <div class=\\\"col-lg-6\\\">\\n    <nb-card size=\\\"small\\\">\\n      <nb-card-header>Simple Popovers</nb-card-header>\\n      <nb-card-body>\\n        <p>In a simples form popover can take a string of text to render.</p>\\n        <button class=\\\"btn btn-success with-margins\\\" nbPopover=\\\"Hello, how are you today?\\\">on click</button>\\n        <button class=\\\"btn btn-success with-margins\\\" nbPopover=\\\"Hello, how are you today?\\\" nbPopoverMode=\\\"hover\\\">on hover</button>\\n        <button class=\\\"btn btn-success with-margins\\\" nbPopover=\\\"Hello, how are you today?\\\" nbPopoverMode=\\\"hint\\\">on hint</button>\\n      </nb-card-body>\\n    </nb-card>\\n  </div>\\n</div>\\n\\n<div class=\\\"row\\\">\\n  <div class=\\\"col-lg-6\\\">\\n\\n    <ng-template #tabs>\\n      <nb-tabset>\\n        <nb-tab tabTitle=\\\"What's up?\\\">\\n          <div class=\\\"p-4\\\">\\n            Such a wonderful day!\\n          </div>\\n        </nb-tab>\\n        <nb-tab tabTitle=\\\"Second Tab\\\">\\n          <div class=\\\"p-4\\\">\\n            Indeed!\\n          </div>\\n        </nb-tab>\\n      </nb-tabset>\\n    </ng-template>\\n\\n    <ng-template #form>\\n      <div class=\\\"p-4\\\">\\n        <form>\\n          <div class=\\\"form-group\\\">\\n            <input type=\\\"text\\\" class=\\\"form-control\\\" placeholder=\\\"Recipients\\\">\\n          </div>\\n          <div class=\\\"form-group\\\">\\n            <input type=\\\"text\\\" class=\\\"form-control\\\" placeholder=\\\"Subject\\\">\\n          </div>\\n          <div class=\\\"form-group\\\">\\n            <textarea class=\\\"form-control\\\" placeholder=\\\"Message\\\"></textarea>\\n          </div>\\n          <button type=\\\"submit\\\" class=\\\"btn btn-primary w-100\\\">Send</button>\\n        </form>\\n      </div>\\n    </ng-template>\\n\\n    <ng-template #card>\\n      <nb-card class=\\\"popover-card\\\">\\n        <nb-card-header status=\\\"warning\\\">\\n          Hello!\\n        </nb-card-header>\\n        <nb-card-body>\\n          Far far away, behind the word mountains, far from the countries Vokalia and Consonantia, there live the blind texts.\\n          Separated they live in Bookmarksgrove right at the coast of the Semantics, a large language ocean.\\n        </nb-card-body>\\n      </nb-card>\\n    </ng-template>\\n\\n    <nb-card size=\\\"small\\\">\\n      <nb-card-header>Template Popovers</nb-card-header>\\n      <nb-card-body>\\n        <p>You can pass a refference to `ng-template` to be rendered.</p>\\n        <button class=\\\"btn btn-warning with-margins\\\" [nbPopover]=\\\"tabs\\\">With tabs</button>\\n        <button class=\\\"btn btn-warning with-margins\\\" [nbPopover]=\\\"form\\\">With form</button>\\n        <button class=\\\"btn btn-warning with-margins\\\" [nbPopover]=\\\"card\\\">With card</button>\\n      </nb-card-body>\\n    </nb-card>\\n  </div>\\n\\n  <div class=\\\"col-lg-6\\\">\\n    <nb-card size=\\\"small\\\">\\n      <nb-card-header>Component Popovers</nb-card-header>\\n      <nb-card-body>\\n        <p>Same way popover can render any angular compnoent.</p>\\n        <button class=\\\"btn btn-warning with-margins\\\" [nbPopover]=\\\"tabsComponent\\\">With tabs</button>\\n        <button class=\\\"btn btn-warning with-margins\\\" [nbPopover]=\\\"formComponent\\\">With form</button>\\n        <button class=\\\"btn btn-warning with-margins\\\" [nbPopover]=\\\"cardComponent\\\">With card</button>\\n      </nb-card-body>\\n    </nb-card>\\n  </div>\\n</div>\\n\\n<div class=\\\"row\\\">\\n  <div class=\\\"col-md-12\\\">\\n    <nb-card>\\n      <nb-card-header>Event Debouncing</nb-card-header>\\n      <nb-card-body>\\n        <p>Quickly move mouse cursor over the buttons, only the last popover will be created. It allows us to avoid excess white improving page performance.</p>\\n\\n        <button class=\\\"btn btn-outline-secondary\\\" nbPopover=\\\"Popover!\\\" nbPopoverMode=\\\"hint\\\">\\n          show hint\\n        </button>\\n        <button class=\\\"btn btn-outline-secondary\\\" nbPopover=\\\"Popover!\\\" nbPopoverMode=\\\"hint\\\">\\n          show hint\\n        </button>\\n        <button class=\\\"btn btn-outline-secondary\\\" nbPopover=\\\"Popover!\\\" nbPopoverMode=\\\"hint\\\">\\n          show hint\\n        </button>\\n        <button class=\\\"btn btn-outline-secondary\\\" nbPopover=\\\"Popover!\\\" nbPopoverMode=\\\"hint\\\">\\n          show hint\\n        </button>\\n        <button class=\\\"btn btn-outline-secondary\\\" nbPopover=\\\"Popover!\\\" nbPopoverMode=\\\"hint\\\">\\n          show hint\\n        </button>\\n        <button class=\\\"btn btn-outline-secondary\\\" nbPopover=\\\"Popover!\\\" nbPopoverMode=\\\"hint\\\">\\n          show hint\\n        </button>\\n        <button class=\\\"btn btn-outline-secondary\\\" nbPopover=\\\"Popover!\\\" nbPopoverMode=\\\"hint\\\">\\n          show hint\\n        </button>\\n        <button class=\\\"btn btn-outline-secondary\\\" nbPopover=\\\"Popover!\\\" nbPopoverMode=\\\"hint\\\">\\n          show hint\\n        </button>\\n        <button class=\\\"btn btn-outline-secondary\\\" nbPopover=\\\"Popover!\\\" nbPopoverMode=\\\"hint\\\">\\n          show hint\\n        </button>\\n        <button class=\\\"btn btn-outline-secondary\\\" nbPopover=\\\"Popover!\\\" nbPopoverMode=\\\"hint\\\">\\n          show hint\\n        </button>\\n        <button class=\\\"btn btn-outline-secondary\\\" nbPopover=\\\"Popover!\\\" nbPopoverMode=\\\"hint\\\">\\n          show hint\\n        </button>\\n        <button class=\\\"btn btn-outline-secondary\\\" nbPopover=\\\"Popover!\\\" nbPopoverMode=\\\"hint\\\">\\n          show hint\\n        </button>\\n        <button class=\\\"btn btn-outline-secondary\\\" nbPopover=\\\"Popover!\\\" nbPopoverMode=\\\"hint\\\">\\n          show hint\\n        </button>\\n        <button class=\\\"btn btn-outline-secondary\\\" nbPopover=\\\"Popover!\\\" nbPopoverMode=\\\"hint\\\">\\n          show hint\\n        </button>\\n        <button class=\\\"btn btn-outline-secondary\\\" nbPopover=\\\"Popover!\\\" nbPopoverMode=\\\"hint\\\">\\n          show hint\\n        </button>\\n        <button class=\\\"btn btn-outline-secondary\\\" nbPopover=\\\"Popover!\\\" nbPopoverMode=\\\"hint\\\">\\n          show hint\\n        </button>\\n      </nb-card-body>\\n    </nb-card>\\n  </div>\\n</div>\\n\"","module.exports = \"<div class=\\\"row\\\">\\n  <div class=\\\"col-md-12 col-lg-6\\\">\\n    <nb-card size=\\\"small\\\">\\n      <nb-tabset>\\n        <nb-tab tabTitle=\\\"Simple Tab #1\\\">\\n          <p>In 1975, the first general purpose home automation network technology, <a target=\\\"_blank\\\" href=\\\"https://en.wikipedia.org/wiki/X10_(industry_standard)\\\" title=\\\"X10 (industry standard)\\\">X10</a>, was developed. It is a communication protocol for electronic devices. It primarily uses <a target=\\\"_blank\\\" href=\\\"https://en.wikipedia.org/wiki/Electric_power_transmission\\\" title=\\\"Electric power transmission\\\">electric power transmission</a> wiring for signalling and control, where the signals involve brief <a target=\\\"_blank\\\" href=\\\"https://en.wikipedia.org/wiki/Radio_frequency\\\" title=\\\"Radio frequency\\\">radio frequency</a> bursts of <a target=\\\"_blank\\\" href=\\\"https://en.wikipedia.org/wiki/Digital_data\\\" title=\\\"Digital data\\\">digital data</a>, and remains the most widely available.<sup id=\\\"cite_ref-8\\\" class=\\\"reference\\\"><a target=\\\"_blank\\\" href=\\\"https://en.wikipedia.org#cite_note-8\\\">[8]</a></sup> By 1978, X10 products included a 16 channel command console, a lamp module, and an appliance module. Soon after came the wall switch module and the first X10 timer.</p>\\n        </nb-tab>\\n        <nb-tab tabTitle=\\\"Simple Tab #2\\\">\\n          <span>Content #2</span>\\n        </nb-tab>\\n        <nb-tab tabTitle=\\\"Simple Tab #3\\\">\\n          <span>Content #3</span>\\n        </nb-tab>\\n      </nb-tabset>\\n    </nb-card>\\n  </div>\\n\\n  <div class=\\\"col-md-6\\\">\\n    <nb-card size=\\\"small\\\">\\n      <nb-tabset fullWidth>\\n        <nb-tab tabTitle=\\\"Full width tab #1\\\">\\n          <p><b>Home automation</b> or <b>smart home</b><sup id=\\\"cite_ref-Smart_Home_1-0\\\" class=\\\"reference\\\"><a target=\\\"_blank\\\" href=\\\"https://en.wikipedia.org#cite_note-Smart_Home-1\\\">[1]</a></sup> (also known as <b>domotics</b><sup id=\\\"cite_ref-t3_2-0\\\" class=\\\"reference\\\"><a target=\\\"_blank\\\" href=\\\"https://en.wikipedia.org#cite_note-t3-2\\\">[2]</a></sup>) is <a target=\\\"_blank\\\" href=\\\"https://en.wikipedia.org/wiki/Building_automation\\\" title=\\\"Building automation\\\">building automation</a> for the home. It involves the control and automation of lighting, heating (such as <a target=\\\"_blank\\\" href=\\\"https://en.wikipedia.org/wiki/Smart_thermostat\\\" title=\\\"Smart thermostat\\\">smart thermostats</a>), ventilation, air conditioning (<a target=\\\"_blank\\\" href=\\\"https://en.wikipedia.org/wiki/HVAC\\\" title=\\\"HVAC\\\">HVAC</a>), and security, as well as <a target=\\\"_blank\\\" href=\\\"https://en.wikipedia.org/wiki/Home_appliance\\\" title=\\\"Home appliance\\\">home appliances</a> such as washer/dryers, ovens or refrigerators/freezers. <a target=\\\"_blank\\\" href=\\\"https://en.wikipedia.org/wiki/Wi-Fi\\\" title=\\\"Wi-Fi\\\">Wi-Fi</a> is often used for remote monitoring and control. Home devices, when remotely monitored and controlled via the Internet, are an important constituent of the <a target=\\\"_blank\\\" href=\\\"https://en.wikipedia.org/wiki/Internet_of_Things\\\" class=\\\"mw-redirect\\\" title=\\\"Internet of Things\\\">Internet of Things</a>. Modern systems generally consist of switches and sensors connected to a central hub sometimes called a \\\"gateway\\\" from which the system is controlled with a <a target=\\\"_blank\\\" href=\\\"https://en.wikipedia.org/wiki/User_interface\\\" title=\\\"User interface\\\">user interface</a> that is interacted either with a wall-mounted terminal, mobile phone software, <a target=\\\"_blank\\\" href=\\\"https://en.wikipedia.org/wiki/Tablet_computer\\\" title=\\\"Tablet computer\\\">tablet computer</a> or a web interface, often but not always via Internet cloud services.</p>\\n          <p>While there are many competing vendors, there are very few worldwide accepted industry standards and the smart home space is heavily fragmented.<sup id=\\\"cite_ref-3\\\" class=\\\"reference\\\"><a target=\\\"_blank\\\" href=\\\"https://en.wikipedia.org#cite_note-3\\\">[3]</a></sup> Popular <a target=\\\"_blank\\\" href=\\\"https://en.wikipedia.org/wiki/Communications_protocol\\\" title=\\\"Communications protocol\\\">communications protocol</a> for products include <a target=\\\"_blank\\\" href=\\\"https://en.wikipedia.org/wiki/X10_(industry_standard)\\\" title=\\\"X10 (industry standard)\\\">X10</a>, <a target=\\\"_blank\\\" href=\\\"https://en.wikipedia.org/wiki/Ethernet\\\" title=\\\"Ethernet\\\">Ethernet</a>, <a target=\\\"_blank\\\" href=\\\"https://en.wikipedia.org/wiki/RS-485\\\" title=\\\"RS-485\\\">RS-485</a>, <a target=\\\"_blank\\\" href=\\\"https://en.wikipedia.org/wiki/6LoWPAN\\\" title=\\\"6LoWPAN\\\">6LoWPAN</a>, <a target=\\\"_blank\\\" href=\\\"https://en.wikipedia.org/wiki/Bluetooth_low_energy\\\" class=\\\"mw-redirect\\\" title=\\\"Bluetooth low energy\\\">Bluetooth LE (BLE)</a>, <a target=\\\"_blank\\\" href=\\\"https://en.wikipedia.org/wiki/ZigBee\\\" class=\\\"mw-redirect\\\" title=\\\"ZigBee\\\">ZigBee</a> and <a target=\\\"_blank\\\" href=\\\"https://en.wikipedia.org/wiki/Z-Wave\\\" title=\\\"Z-Wave\\\">Z-Wave</a>, or other proprietary protocols all of which are incompatible with each other.<sup id=\\\"cite_ref-crhomephone_4-0\\\" class=\\\"reference\\\"><a target=\\\"_blank\\\" href=\\\"https://en.wikipedia.org#cite_note-crhomephone-4\\\">[4]</a></sup> Manufacturers often prevent independent implementations by withholding documentation and by litigation.<sup id=\\\"cite_ref-5\\\" class=\\\"reference\\\"><a target=\\\"_blank\\\" href=\\\"https://en.wikipedia.org#cite_note-5\\\">[5]</a></sup></p>\\n        </nb-tab>\\n        <nb-tab tabTitle=\\\"Full width tab #2\\\">\\n          <span>Content #2</span>\\n        </nb-tab>\\n        <nb-tab tabTitle=\\\"Full width tab #3\\\">\\n          <span>Content #3</span>\\n        </nb-tab>\\n      </nb-tabset>\\n    </nb-card>\\n  </div>\\n\\n  <div class=\\\"col-md-6\\\">\\n    <nb-card size=\\\"small\\\">\\n      <nb-route-tabset [tabs]=\\\"tabs\\\"></nb-route-tabset>\\n    </nb-card>\\n  </div>\\n</div>\\n\"","module.exports = \"/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/**\\n * This mixin generates keyfames.\\n * Because of all keyframes can't be scoped,\\n * we need to puts unique name in each btn-pulse call.\\n */\\n/*\\n\\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\\n:host and :host-context are pseudo-classes. So we assume they could be combined,\\nlike other pseudo-classes, even same ones.\\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\\n\\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\\nso direction could be overridden on any component level.\\n\\nImplementation code:\\n\\n@mixin nb-rtl() {\\n  // add # to scss interpolation statement.\\n  // it works in comments and we can't use it here\\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\\n    @content;\\n  }\\n}\\n\\nAnd when we call it somewhere:\\n\\n:host {\\n  .some-class {\\n    @include nb-rtl() {\\n      ...\\n    }\\n  }\\n}\\n:host-context(...) {\\n  .some-class {\\n    @include nb-rtl() {\\n      ...\\n    }\\n  }\\n}\\n\\nResult will look like:\\n\\n:host-context([dir=rtl]):host .some-class {\\n  ...\\n}\\n:host-context([dir=rtl]):host-context(...) .some-class {\\n  ...\\n}\\n\\n*\\n  Side note:\\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\\n\\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\\n  so order is not important.\\n*\\n\\n\\nCurrently, there're two problems with this approach:\\n\\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\\nFor the moment of writing, the only possible way is:\\n:host {\\n  :host-context(...) {\\n    ...\\n  }\\n}\\nIt doesn't work for us because mixin could be called somewhere deeper, like:\\n:host {\\n  p {\\n    @include nb-rtl() { ... }\\n  }\\n}\\nWe are not able to go up to :host level to place content passed to mixin.\\n\\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\\n  *\\n    Side note:\\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\\n    :host-context($theme) once we will be able to use multiple shadow selectors.\\n  *\\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\\n  ***\\n    Possible solution\\n    check if we in theme by some theme variables and if so append, otherwise nest like\\n    @at-root :host-context([dir=rtl]) {\\n      // add # to scss interpolation statement.\\n      // it works in comments and we can't use it here\\n      {&} {\\n        @content;\\n      }\\n    }\\n    What if :host specified? Can we add space in :host-context(...) :host?\\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\\n  ***\\n\\n\\nProblems with the current approach.\\n\\n1. Direction can be applied only on document level, because mixin prepends theme class,\\nwhich placed on the body.\\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\\nattribute to [dir=rtl] attribute as well.\\n\\n\\nGeneral problems.\\n\\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\\n*/\\n[dir=ltr] :host button {\\n  margin: 0 0.75rem 2rem 0; }\\n[dir=rtl] :host button {\\n  margin: 0 0 2rem 0.75rem; }\\n\"","module.exports = \"<div class=\\\"row\\\">\\n  <div class=\\\"col-md-12\\\">\\n    <nb-card>\\n      <nb-card-header>Modals</nb-card-header>\\n      <nb-card-body>\\n        <button class=\\\"btn btn-success\\\" (click)=\\\"showLargeModal()\\\">Large modal</button>\\n        <button class=\\\"btn btn-warning\\\" (click)=\\\"showSmallModal()\\\">Small modal</button>\\n        <button class=\\\"btn btn-primary\\\" (click)=\\\"showStaticModal()\\\">Static modal</button>\\n      </nb-card-body>\\n    </nb-card>\\n  </div>\\n</div>\\n\"","module.exports = \"<nb-card>\\n  <nb-card-header>Icon buttons</nb-card-header>\\n  <nb-card-body>\\n    <div class=\\\"row icon-buttons\\\">\\n      <div class=\\\"col-md-12\\\">\\n        <div class=\\\"btn-group\\\">\\n          <button type=\\\"button\\\" class=\\\"btn btn-primary btn-group-icon btn-group-divider\\\">\\n            <i class=\\\"nb-home\\\"></i>\\n          </button>\\n          <button type=\\\"button\\\" class=\\\"btn btn-primary\\\">Icon Button</button>\\n        </div>\\n        <div class=\\\"btn-with-icon-example\\\">\\n          <button type=\\\"button\\\" class=\\\"btn btn-primary btn-with-icon\\\">\\n            <i class=\\\"nb-home\\\"></i>\\n            <span>Icon Button</span>\\n          </button>\\n        </div>\\n        <div class=\\\"icon-button-examples\\\">\\n          <button type=\\\"button\\\" class=\\\"btn btn-outline-primary btn-icon\\\">\\n            <i class=\\\"nb-layout-centre\\\"></i>\\n          </button>\\n          <button type=\\\"button\\\" class=\\\"btn btn-outline-success btn-icon\\\">\\n            <i class=\\\"nb-layout-default\\\"></i>\\n          </button>\\n          <button type=\\\"button\\\" class=\\\"btn btn-outline-danger btn-icon\\\">\\n            <i class=\\\"nb-layout-one-column\\\"></i>\\n          </button>\\n        </div>\\n        <div class=\\\"icon-button-examples\\\">\\n          <button type=\\\"button\\\" class=\\\"btn btn-primary btn-icon\\\">\\n            <i class=\\\"nb-shuffle\\\"></i>\\n          </button>\\n          <button type=\\\"button\\\" class=\\\"btn btn-success btn-icon\\\">\\n            <i class=\\\"nb-skip-backward-outline\\\"></i>\\n          </button>\\n          <button type=\\\"button\\\" class=\\\"btn btn-danger btn-icon\\\">\\n            <i class=\\\"nb-skip-forward-outline\\\"></i>\\n          </button>\\n        </div>\\n      </div>\\n    </div>\\n  </nb-card-body>\\n</nb-card>\\n\"","module.exports = \"<div class=\\\"row\\\">\\n  <div class=\\\"col-xxxl-8\\\">\\n    <div class=\\\"row\\\">\\n      <div class=\\\"col-md-6 col-xxl-7\\\">\\n        <nb-card size=\\\"medium\\\">\\n          <nb-card-header>\\n            Used Fonts\\n          </nb-card-header>\\n          <nb-card-body>\\n            <div class=\\\"font-row font-secondary\\\">\\n              <div class=\\\"header\\\">\\n                <div class=\\\"name bold\\\">Exo</div>\\n\\n                <div class=\\\"variants\\\">\\n                  <span class=\\\"font-w-bold\\\">Bold</span>\\n                  <span class=\\\"font-w-regular\\\">Regular</span>\\n                  <span class=\\\"font-w-light\\\">Light</span>\\n                </div>\\n              </div>\\n              <p>\\n                Far far away, behind the word mountains, far from the countries Vokalia and Consonantia,\\n                there live the blind texts.\\n                Separated they live in Bookmarksgrove right at the coast of the Semantics, a large language ocean.\\n              </p>\\n            </div>\\n\\n            <div class=\\\"font-row font-main\\\">\\n              <div class=\\\"header\\\">\\n                <div class=\\\"name bold\\\">Roboto</div>\\n\\n                <div class=\\\"variants\\\">\\n                  <span class=\\\"font-w-bold\\\">Bold</span>\\n                  <span class=\\\"font-w-regular\\\">Regular</span>\\n                  <span class=\\\"font-w-light\\\">Light</span>\\n                </div>\\n              </div>\\n              <p>\\n                Far far away, behind the word mountains, far from the countries Vokalia and Consonantia,\\n                there live the blind texts.\\n                Separated they live in Bookmarksgrove right at the coast of the Semantics, a large language ocean.\\n              </p>\\n            </div>\\n          </nb-card-body>\\n        </nb-card>\\n\\n        <nb-card size=\\\"small\\\">\\n          <nb-card-header>\\n            Article Example\\n          </nb-card-header>\\n          <nb-card-body>\\n            <h4>So what's About the grammar?</h4>\\n            <p class=\\\"text-indent\\\">\\n              Far far away, behind the word mountains, far from the countries <strong>Vokalia</strong> and <strong>Consonantia</strong>,\\n              there live the blind texts.\\n              They live in <strong>Bookmarksgrove</strong>.\\n            </p>\\n            <p class=\\\"text-indent\\\">\\n              A small <strong>river named Duden</strong> flows by their place and supplies it with the\\n              necessary regelialia. It is a paradisematic country, in which roasted parts of sentences fly\\n              into your mouth.\\n              Even the all-powerful Pointing has no control about the blind texts it is an almost\\n              unorthographic life One day however a small\\n              line of blind text by the name of\\n              <a href=\\\"http://google.com\\\" target=\\\"_blank\\\">Lorem Ipsum</a> decided to leave for\\n              the far <strong>World of Grammar</strong>.\\n            </p>\\n          </nb-card-body>\\n        </nb-card>\\n      </div>\\n      <div class=\\\"col-md-6 col-xxl-5\\\">\\n        <nb-card size=\\\"medium\\\" class=\\\"headings-card\\\">\\n          <nb-card-header>\\n            Headings\\n          </nb-card-header>\\n          <nb-card-body>\\n            <div class=\\\"header\\\">\\n              <div>\\n                <h1>H1. Heading</h1>\\n              </div>\\n\\n              <div class=\\\"detail font-w-light\\\">\\n                Demibold 2.5rem (40px)\\n              </div>\\n            </div>\\n            <div class=\\\"header\\\">\\n              <div>\\n                <h2>H2. Heading</h2>\\n              </div>\\n\\n              <div class=\\\"detail font-w-light\\\">\\n                Demibold 2rem (32px)\\n              </div>\\n            </div>\\n            <div class=\\\"header\\\">\\n              <div>\\n                <h3>H3. Heading</h3>\\n              </div>\\n\\n              <div class=\\\"detail font-w-light\\\">\\n                Demibold 1.75rem (28px)\\n              </div>\\n            </div>\\n            <div class=\\\"header\\\">\\n              <div>\\n                <h4>H4. Heading</h4>\\n              </div>\\n\\n              <div class=\\\"detail font-w-light\\\">\\n                Demibold 1.5rem (24px)\\n              </div>\\n            </div>\\n            <div class=\\\"header\\\">\\n              <div>\\n                <h5>H5. Heading</h5>\\n              </div>\\n\\n              <div class=\\\"detail font-w-light\\\">\\n                Demibold 1.25rem (20px)\\n              </div>\\n            </div>\\n            <div class=\\\"header\\\">\\n              <div>\\n                <h6>H6. Heading</h6>\\n              </div>\\n\\n              <div class=\\\"detail font-w-light\\\">\\n                Demibold 1rem (16px)\\n              </div>\\n            </div>\\n          </nb-card-body>\\n        </nb-card>\\n\\n        <nb-card size=\\\"small\\\">\\n          <nb-card-header>\\n            Blockquotes\\n          </nb-card-header>\\n          <nb-card-body>\\n            <blockquote class=\\\"blockquote\\\">\\n              <p class=\\\"mb-0\\\">Far far away, behind the word mountains, far from the countries Vokalia and Consonantia.\\n            </blockquote>\\n            <blockquote class=\\\"blockquote\\\">\\n              <p class=\\\"mb-0\\\">Far far away, behind the word mountains, far from the countries.</p>\\n              <footer class=\\\"blockquote-footer\\\">Vladimir Lugovsky</footer>\\n            </blockquote>\\n            <blockquote class=\\\"blockquote-reverse\\\">\\n              <p class=\\\"mb-0\\\">Far far away, behind the word mountains.</p>\\n              <footer class=\\\"blockquote-footer\\\">Vladimir Lugovsky</footer>\\n            </blockquote>\\n          </nb-card-body>\\n        </nb-card>\\n      </div>\\n    </div>\\n  </div>\\n\\n  <div class=\\\"col-md-6 col-xxxl-4\\\">\\n    <nb-card [size]=\\\"breakpoint.width >= breakpoints.xxxl ? 'xxlarge' : 'large'\\\">\\n      <nb-card-header>\\n        Font Colors\\n      </nb-card-header>\\n      <nb-card-body>\\n        <div class=\\\"colors\\\">\\n          <div class=\\\"item text-heading\\\">\\n            <div class=\\\"color bg-heading\\\"></div>\\n            <div>\\n              <h5 class=\\\"text-heading\\\">Heading Text</h5>\\n              Far far away, behind the your awesomeness.\\n            </div>\\n          </div>\\n          <div class=\\\"item text-body\\\">\\n            <div class=\\\"color bg-body\\\"></div>\\n            <div>\\n              <h5 class=\\\"text-body\\\">Body Text</h5>\\n              Far far away, behind the your awesomeness.\\n            </div>\\n          </div>\\n          <div class=\\\"item text-hint\\\">\\n            <div class=\\\"color bg-hint\\\"></div>\\n            <div>\\n              <h5 class=\\\"text-hint\\\">Hint Text</h5>\\n              Far far away, behind the your awesomeness.\\n            </div>\\n          </div>\\n          <div class=\\\"item text-link\\\">\\n            <div class=\\\"color bg-link\\\"></div>\\n            <div>\\n              <h5 class=\\\"text-link\\\">Link Text</h5>\\n              Far far away, behind the your awesomeness.\\n            </div>\\n          </div>\\n          <div class=\\\"item text-primary\\\">\\n            <div class=\\\"color bg-primary\\\"></div>\\n            <div>\\n              <h5 class=\\\"text-primary\\\">Primary Text</h5>\\n              Far far away, behind the your awesomeness.\\n            </div>\\n          </div>\\n          <div class=\\\"item text-success\\\">\\n            <div class=\\\"color bg-success\\\"></div>\\n            <div>\\n              <h5 class=\\\"text-success\\\">Success Text</h5>\\n              Far far away, behind the your awesomeness.\\n            </div>\\n          </div>\\n          <div class=\\\"item text-info\\\">\\n            <div class=\\\"color bg-info\\\"></div>\\n            <div>\\n              <h5 class=\\\"text-info\\\">Info Text</h5>\\n              Far far away, behind the your awesomeness.\\n            </div>\\n          </div>\\n          <div class=\\\"item text-warning\\\">\\n            <div class=\\\"color bg-warning\\\"></div>\\n            <div>\\n              <h5 class=\\\"text-warning\\\">Warning Text</h5>\\n              Far far away, behind the your awesomeness.\\n            </div>\\n          </div>\\n          <div class=\\\"item text-danger\\\">\\n            <div class=\\\"color bg-danger\\\"></div>\\n            <div>\\n              <h5 class=\\\"text-danger\\\">Danger Text</h5>\\n              Far far away, behind the your awesomeness.\\n            </div>\\n          </div>\\n        </div>\\n      </nb-card-body>\\n    </nb-card>\\n  </div>\\n\\n  <div class=\\\"col-md-6 col-xxxl-4\\\">\\n    <nb-card size=\\\"large\\\">\\n      <nb-card-header>\\n        Alerts\\n      </nb-card-header>\\n      <nb-card-body>\\n        <div class=\\\"alert alert-primary\\\" role=\\\"alert\\\">\\n          <strong>Oh snap!</strong> <a href=\\\"#\\\" class=\\\"alert-link\\\">Change a few things up</a> and try submitting again.\\n        </div>\\n        <div class=\\\"alert alert-hint\\\" role=\\\"alert\\\">\\n          <strong>Heads up!</strong> This <a href=\\\"#\\\" class=\\\"alert-link\\\">alert needs your attention</a>, but it's not super important.\\n        </div>\\n        <div class=\\\"alert alert-success\\\" role=\\\"alert\\\">\\n          <strong>Well done!</strong> You successfully read <a href=\\\"#\\\" class=\\\"alert-link\\\">this important alert message</a>.\\n        </div>\\n        <div class=\\\"alert alert-info\\\" role=\\\"alert\\\">\\n          <strong>Heads up!</strong> This <a href=\\\"#\\\" class=\\\"alert-link\\\">alert needs your attention</a>, but it's not super important.\\n        </div>\\n        <div class=\\\"alert alert-warning\\\" role=\\\"alert\\\">\\n          <strong>Warning!</strong> Better check yourself, you're <a href=\\\"#\\\" class=\\\"alert-link\\\">not looking too good</a>.\\n        </div>\\n        <div class=\\\"alert alert-danger\\\" role=\\\"alert\\\">\\n          <strong>Oh snap!</strong> <a href=\\\"#\\\" class=\\\"alert-link\\\">Change a few things up</a> and try submitting again.\\n        </div>\\n      </nb-card-body>\\n    </nb-card>\\n  </div>\\n\\n  <div class=\\\"col-md-6 col-xxxl-4\\\">\\n    <nb-card size=\\\"large\\\">\\n      <nb-card-header>\\n        Text Types\\n      </nb-card-header>\\n      <nb-card-body>\\n        <h4>Highlighted text</h4>\\n        <p class=\\\"mb-5\\\">\\n          Far far away, behind the word mountains, far from the countries\\n          Vokalia and <mark>Consonantia, there live the blind texts.</mark>\\n        </p>\\n        <h4>Bold Text</h4>\\n        <p class=\\\"mb-5\\\">\\n          Far far away, behind the word mountains, far from the countries\\n          Vokalia and <strong>Consonantia, there live the blind texts.</strong>\\n        </p>\\n        <h4>Link Text</h4>\\n        <p class=\\\"mb-5\\\">\\n          Far far away, behind the word mountains, far from the countries\\n          Vokalia and <a href=\\\"http://google.com\\\" target=\\\"_blank\\\">Consonantia, there live the blind texts.</a>\\n        </p>\\n      </nb-card-body>\\n    </nb-card>\\n  </div>\\n\\n  <div class=\\\"col-md-6 col-xxxl-4\\\">\\n    <nb-card size=\\\"large\\\">\\n      <nb-card-header>\\n        Lists\\n      </nb-card-header>\\n      <nb-card-body>\\n        <h4>Ordered List</h4>\\n        <ol class=\\\"mb-5\\\">\\n          <li>Far far away, behind the word mountains</li>\\n          <li>Far from the countries Vokalia and Consonantia</li>\\n          <li>There live the blind texts.</li>\\n          <li>Right at the coast of the Semantics.</li>\\n          <li>A small river named Duden flows</li>\\n        </ol>\\n\\n        <h4>Unordered List</h4>\\n        <ul class=\\\"mb-5\\\">\\n          <li>Far far away, behind the word mountains</li>\\n          <li>Far from the countries Vokalia and Consonantia</li>\\n          <li>There live the blind texts.</li>\\n          <li>Right at the coast of the Semantics.</li>\\n          <li>A small river named Duden flows</li>\\n        </ul>\\n      </nb-card-body>\\n    </nb-card>\\n  </div>\\n</div>\\n\"","module.exports = \"/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/**\\n * This is a starting point where we declare the maps of themes and globally available functions/mixins\\n */\\n/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/**\\n * This mixin generates keyfames.\\n * Because of all keyframes can't be scoped,\\n * we need to puts unique name in each btn-pulse call.\\n */\\n/*\\n\\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\\n:host and :host-context are pseudo-classes. So we assume they could be combined,\\nlike other pseudo-classes, even same ones.\\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\\n\\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\\nso direction could be overridden on any component level.\\n\\nImplementation code:\\n\\n@mixin nb-rtl() {\\n  // add # to scss interpolation statement.\\n  // it works in comments and we can't use it here\\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\\n    @content;\\n  }\\n}\\n\\nAnd when we call it somewhere:\\n\\n:host {\\n  .some-class {\\n    @include nb-rtl() {\\n      ...\\n    }\\n  }\\n}\\n:host-context(...) {\\n  .some-class {\\n    @include nb-rtl() {\\n      ...\\n    }\\n  }\\n}\\n\\nResult will look like:\\n\\n:host-context([dir=rtl]):host .some-class {\\n  ...\\n}\\n:host-context([dir=rtl]):host-context(...) .some-class {\\n  ...\\n}\\n\\n*\\n  Side note:\\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\\n\\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\\n  so order is not important.\\n*\\n\\n\\nCurrently, there're two problems with this approach:\\n\\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\\nFor the moment of writing, the only possible way is:\\n:host {\\n  :host-context(...) {\\n    ...\\n  }\\n}\\nIt doesn't work for us because mixin could be called somewhere deeper, like:\\n:host {\\n  p {\\n    @include nb-rtl() { ... }\\n  }\\n}\\nWe are not able to go up to :host level to place content passed to mixin.\\n\\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\\n  *\\n    Side note:\\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\\n    :host-context($theme) once we will be able to use multiple shadow selectors.\\n  *\\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\\n  ***\\n    Possible solution\\n    check if we in theme by some theme variables and if so append, otherwise nest like\\n    @at-root :host-context([dir=rtl]) {\\n      // add # to scss interpolation statement.\\n      // it works in comments and we can't use it here\\n      {&} {\\n        @content;\\n      }\\n    }\\n    What if :host specified? Can we add space in :host-context(...) :host?\\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\\n  ***\\n\\n\\nProblems with the current approach.\\n\\n1. Direction can be applied only on document level, because mixin prepends theme class,\\nwhich placed on the body.\\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\\nattribute to [dir=rtl] attribute as well.\\n\\n\\nGeneral problems.\\n\\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\\n*/\\n/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/**\\n * This mixin generates keyfames.\\n * Because of all keyframes can't be scoped,\\n * we need to puts unique name in each btn-pulse call.\\n */\\n/*\\n\\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\\n:host and :host-context are pseudo-classes. So we assume they could be combined,\\nlike other pseudo-classes, even same ones.\\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\\n\\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\\nso direction could be overridden on any component level.\\n\\nImplementation code:\\n\\n@mixin nb-rtl() {\\n  // add # to scss interpolation statement.\\n  // it works in comments and we can't use it here\\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\\n    @content;\\n  }\\n}\\n\\nAnd when we call it somewhere:\\n\\n:host {\\n  .some-class {\\n    @include nb-rtl() {\\n      ...\\n    }\\n  }\\n}\\n:host-context(...) {\\n  .some-class {\\n    @include nb-rtl() {\\n      ...\\n    }\\n  }\\n}\\n\\nResult will look like:\\n\\n:host-context([dir=rtl]):host .some-class {\\n  ...\\n}\\n:host-context([dir=rtl]):host-context(...) .some-class {\\n  ...\\n}\\n\\n*\\n  Side note:\\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\\n\\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\\n  so order is not important.\\n*\\n\\n\\nCurrently, there're two problems with this approach:\\n\\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\\nFor the moment of writing, the only possible way is:\\n:host {\\n  :host-context(...) {\\n    ...\\n  }\\n}\\nIt doesn't work for us because mixin could be called somewhere deeper, like:\\n:host {\\n  p {\\n    @include nb-rtl() { ... }\\n  }\\n}\\nWe are not able to go up to :host level to place content passed to mixin.\\n\\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\\n  *\\n    Side note:\\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\\n    :host-context($theme) once we will be able to use multiple shadow selectors.\\n  *\\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\\n  ***\\n    Possible solution\\n    check if we in theme by some theme variables and if so append, otherwise nest like\\n    @at-root :host-context([dir=rtl]) {\\n      // add # to scss interpolation statement.\\n      // it works in comments and we can't use it here\\n      {&} {\\n        @content;\\n      }\\n    }\\n    What if :host specified? Can we add space in :host-context(...) :host?\\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\\n  ***\\n\\n\\nProblems with the current approach.\\n\\n1. Direction can be applied only on document level, because mixin prepends theme class,\\nwhich placed on the body.\\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\\nattribute to [dir=rtl] attribute as well.\\n\\n\\nGeneral problems.\\n\\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\\n*/\\n/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/**\\n * This mixin generates keyfames.\\n * Because of all keyframes can't be scoped,\\n * we need to puts unique name in each btn-pulse call.\\n */\\n/*\\n\\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\\n:host and :host-context are pseudo-classes. So we assume they could be combined,\\nlike other pseudo-classes, even same ones.\\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\\n\\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\\nso direction could be overridden on any component level.\\n\\nImplementation code:\\n\\n@mixin nb-rtl() {\\n  // add # to scss interpolation statement.\\n  // it works in comments and we can't use it here\\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\\n    @content;\\n  }\\n}\\n\\nAnd when we call it somewhere:\\n\\n:host {\\n  .some-class {\\n    @include nb-rtl() {\\n      ...\\n    }\\n  }\\n}\\n:host-context(...) {\\n  .some-class {\\n    @include nb-rtl() {\\n      ...\\n    }\\n  }\\n}\\n\\nResult will look like:\\n\\n:host-context([dir=rtl]):host .some-class {\\n  ...\\n}\\n:host-context([dir=rtl]):host-context(...) .some-class {\\n  ...\\n}\\n\\n*\\n  Side note:\\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\\n\\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\\n  so order is not important.\\n*\\n\\n\\nCurrently, there're two problems with this approach:\\n\\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\\nFor the moment of writing, the only possible way is:\\n:host {\\n  :host-context(...) {\\n    ...\\n  }\\n}\\nIt doesn't work for us because mixin could be called somewhere deeper, like:\\n:host {\\n  p {\\n    @include nb-rtl() { ... }\\n  }\\n}\\nWe are not able to go up to :host level to place content passed to mixin.\\n\\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\\n  *\\n    Side note:\\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\\n    :host-context($theme) once we will be able to use multiple shadow selectors.\\n  *\\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\\n  ***\\n    Possible solution\\n    check if we in theme by some theme variables and if so append, otherwise nest like\\n    @at-root :host-context([dir=rtl]) {\\n      // add # to scss interpolation statement.\\n      // it works in comments and we can't use it here\\n      {&} {\\n        @content;\\n      }\\n    }\\n    What if :host specified? Can we add space in :host-context(...) :host?\\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\\n  ***\\n\\n\\nProblems with the current approach.\\n\\n1. Direction can be applied only on document level, because mixin prepends theme class,\\nwhich placed on the body.\\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\\nattribute to [dir=rtl] attribute as well.\\n\\n\\nGeneral problems.\\n\\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\\n*/\\n/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/**\\n * This mixin generates keyfames.\\n * Because of all keyframes can't be scoped,\\n * we need to puts unique name in each btn-pulse call.\\n */\\n/*\\n\\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\\n:host and :host-context are pseudo-classes. So we assume they could be combined,\\nlike other pseudo-classes, even same ones.\\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\\n\\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\\nso direction could be overridden on any component level.\\n\\nImplementation code:\\n\\n@mixin nb-rtl() {\\n  // add # to scss interpolation statement.\\n  // it works in comments and we can't use it here\\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\\n    @content;\\n  }\\n}\\n\\nAnd when we call it somewhere:\\n\\n:host {\\n  .some-class {\\n    @include nb-rtl() {\\n      ...\\n    }\\n  }\\n}\\n:host-context(...) {\\n  .some-class {\\n    @include nb-rtl() {\\n      ...\\n    }\\n  }\\n}\\n\\nResult will look like:\\n\\n:host-context([dir=rtl]):host .some-class {\\n  ...\\n}\\n:host-context([dir=rtl]):host-context(...) .some-class {\\n  ...\\n}\\n\\n*\\n  Side note:\\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\\n\\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\\n  so order is not important.\\n*\\n\\n\\nCurrently, there're two problems with this approach:\\n\\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\\nFor the moment of writing, the only possible way is:\\n:host {\\n  :host-context(...) {\\n    ...\\n  }\\n}\\nIt doesn't work for us because mixin could be called somewhere deeper, like:\\n:host {\\n  p {\\n    @include nb-rtl() { ... }\\n  }\\n}\\nWe are not able to go up to :host level to place content passed to mixin.\\n\\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\\n  *\\n    Side note:\\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\\n    :host-context($theme) once we will be able to use multiple shadow selectors.\\n  *\\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\\n  ***\\n    Possible solution\\n    check if we in theme by some theme variables and if so append, otherwise nest like\\n    @at-root :host-context([dir=rtl]) {\\n      // add # to scss interpolation statement.\\n      // it works in comments and we can't use it here\\n      {&} {\\n        @content;\\n      }\\n    }\\n    What if :host specified? Can we add space in :host-context(...) :host?\\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\\n  ***\\n\\n\\nProblems with the current approach.\\n\\n1. Direction can be applied only on document level, because mixin prepends theme class,\\nwhich placed on the body.\\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\\nattribute to [dir=rtl] attribute as well.\\n\\n\\nGeneral problems.\\n\\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\\n*/\\n/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/**\\n * This mixin generates keyfames.\\n * Because of all keyframes can't be scoped,\\n * we need to puts unique name in each btn-pulse call.\\n */\\n/*\\n\\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\\n:host and :host-context are pseudo-classes. So we assume they could be combined,\\nlike other pseudo-classes, even same ones.\\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\\n\\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\\nso direction could be overridden on any component level.\\n\\nImplementation code:\\n\\n@mixin nb-rtl() {\\n  // add # to scss interpolation statement.\\n  // it works in comments and we can't use it here\\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\\n    @content;\\n  }\\n}\\n\\nAnd when we call it somewhere:\\n\\n:host {\\n  .some-class {\\n    @include nb-rtl() {\\n      ...\\n    }\\n  }\\n}\\n:host-context(...) {\\n  .some-class {\\n    @include nb-rtl() {\\n      ...\\n    }\\n  }\\n}\\n\\nResult will look like:\\n\\n:host-context([dir=rtl]):host .some-class {\\n  ...\\n}\\n:host-context([dir=rtl]):host-context(...) .some-class {\\n  ...\\n}\\n\\n*\\n  Side note:\\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\\n\\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\\n  so order is not important.\\n*\\n\\n\\nCurrently, there're two problems with this approach:\\n\\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\\nFor the moment of writing, the only possible way is:\\n:host {\\n  :host-context(...) {\\n    ...\\n  }\\n}\\nIt doesn't work for us because mixin could be called somewhere deeper, like:\\n:host {\\n  p {\\n    @include nb-rtl() { ... }\\n  }\\n}\\nWe are not able to go up to :host level to place content passed to mixin.\\n\\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\\n  *\\n    Side note:\\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\\n    :host-context($theme) once we will be able to use multiple shadow selectors.\\n  *\\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\\n  ***\\n    Possible solution\\n    check if we in theme by some theme variables and if so append, otherwise nest like\\n    @at-root :host-context([dir=rtl]) {\\n      // add # to scss interpolation statement.\\n      // it works in comments and we can't use it here\\n      {&} {\\n        @content;\\n      }\\n    }\\n    What if :host specified? Can we add space in :host-context(...) :host?\\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\\n  ***\\n\\n\\nProblems with the current approach.\\n\\n1. Direction can be applied only on document level, because mixin prepends theme class,\\nwhich placed on the body.\\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\\nattribute to [dir=rtl] attribute as well.\\n\\n\\nGeneral problems.\\n\\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\\n*/\\n/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/**\\n * This mixin generates keyfames.\\n * Because of all keyframes can't be scoped,\\n * we need to puts unique name in each btn-pulse call.\\n */\\n/*\\n\\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\\n:host and :host-context are pseudo-classes. So we assume they could be combined,\\nlike other pseudo-classes, even same ones.\\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\\n\\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\\nso direction could be overridden on any component level.\\n\\nImplementation code:\\n\\n@mixin nb-rtl() {\\n  // add # to scss interpolation statement.\\n  // it works in comments and we can't use it here\\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\\n    @content;\\n  }\\n}\\n\\nAnd when we call it somewhere:\\n\\n:host {\\n  .some-class {\\n    @include nb-rtl() {\\n      ...\\n    }\\n  }\\n}\\n:host-context(...) {\\n  .some-class {\\n    @include nb-rtl() {\\n      ...\\n    }\\n  }\\n}\\n\\nResult will look like:\\n\\n:host-context([dir=rtl]):host .some-class {\\n  ...\\n}\\n:host-context([dir=rtl]):host-context(...) .some-class {\\n  ...\\n}\\n\\n*\\n  Side note:\\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\\n\\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\\n  so order is not important.\\n*\\n\\n\\nCurrently, there're two problems with this approach:\\n\\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\\nFor the moment of writing, the only possible way is:\\n:host {\\n  :host-context(...) {\\n    ...\\n  }\\n}\\nIt doesn't work for us because mixin could be called somewhere deeper, like:\\n:host {\\n  p {\\n    @include nb-rtl() { ... }\\n  }\\n}\\nWe are not able to go up to :host level to place content passed to mixin.\\n\\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\\n  *\\n    Side note:\\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\\n    :host-context($theme) once we will be able to use multiple shadow selectors.\\n  *\\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\\n  ***\\n    Possible solution\\n    check if we in theme by some theme variables and if so append, otherwise nest like\\n    @at-root :host-context([dir=rtl]) {\\n      // add # to scss interpolation statement.\\n      // it works in comments and we can't use it here\\n      {&} {\\n        @content;\\n      }\\n    }\\n    What if :host specified? Can we add space in :host-context(...) :host?\\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\\n  ***\\n\\n\\nProblems with the current approach.\\n\\n1. Direction can be applied only on document level, because mixin prepends theme class,\\nwhich placed on the body.\\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\\nattribute to [dir=rtl] attribute as well.\\n\\n\\nGeneral problems.\\n\\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\\n*/\\n/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/*\\n      :host can be prefixed\\n      https://github.com/angular/angular/blob/8d0ee34939f14c07876d222c25b405ed458a34d3/packages/compiler/src/shadow_css.ts#L441\\n\\n      We have to use :host insted of :host-context($theme), to be able to prefix theme class\\n      with something defined inside of @content, by prefixing &.\\n      For example this scss code:\\n        .nb-theme-default {\\n          .some-selector & {\\n            ...\\n          }\\n        }\\n      Will result in next css:\\n        .some-selector .nb-theme-default {\\n          ...\\n        }\\n\\n      It doesn't work with :host-context because angular splitting it in two selectors and removes\\n      prefix in one of the selectors.\\n    */\\n.nb-theme-default :host nb-card-header {\\n  display: -webkit-box;\\n  display: -ms-flexbox;\\n  display: flex;\\n  -webkit-box-align: center;\\n      -ms-flex-align: center;\\n          align-items: center;\\n  -webkit-box-pack: justify;\\n      -ms-flex-pack: justify;\\n          justify-content: space-between; }\\n.nb-theme-default :host nb-card-header .dropdown {\\n    -ms-flex-preferred-size: 30%;\\n        flex-basis: 30%;\\n    min-width: 220px; }\\n.nb-theme-default :host nb-card-body {\\n  padding-bottom: 0; }\\n.nb-theme-default :host .example-container {\\n  margin-bottom: 1.5rem; }\\n.nb-theme-default :host .primary-container .original {\\n  background-color: #8a7fff; }\\n.nb-theme-default :host .primary-container .hover:hover, .nb-theme-default :host .primary-container .hover.hover {\\n  color: #ffffff;\\n  background-color: #9a91ff;\\n  border-color: transparent; }\\n.nb-theme-default :host .primary-container .active:active, .nb-theme-default :host .primary-container .active.active, .nb-theme-default :host .primary-container .active:active:focus {\\n  color: #ffffff;\\n  background-color: #776ddb;\\n  border-color: transparent;\\n  -webkit-box-shadow: none;\\n          box-shadow: none; }\\n.nb-theme-default :host .primary-container.outline .original {\\n  background-color: transparent;\\n  border: 2px solid #8a7fff; }\\n.nb-theme-default :host .success-container .original {\\n  background-color: #40dc7e; }\\n.nb-theme-default :host .success-container .hover:hover, .nb-theme-default :host .success-container .hover.hover {\\n  color: #ffffff;\\n  background-color: #5be190;\\n  border-color: transparent; }\\n.nb-theme-default :host .success-container .active:active, .nb-theme-default :host .success-container .active.active, .nb-theme-default :host .success-container .active:active:focus {\\n  color: #ffffff;\\n  background-color: #37bd6c;\\n  border-color: transparent;\\n  -webkit-box-shadow: none;\\n          box-shadow: none; }\\n.nb-theme-default :host .success-container.outline .original {\\n  background-color: transparent;\\n  border: 2px solid #40dc7e; }\\n.nb-theme-default :host .warning-container .original {\\n  background-color: #ffa100; }\\n.nb-theme-default :host .warning-container .hover:hover, .nb-theme-default :host .warning-container .hover.hover {\\n  color: #ffffff;\\n  background-color: #ffae24;\\n  border-color: transparent; }\\n.nb-theme-default :host .warning-container .active:active, .nb-theme-default :host .warning-container .active.active, .nb-theme-default :host .warning-container .active:active:focus {\\n  color: #ffffff;\\n  background-color: #db8a00;\\n  border-color: transparent;\\n  -webkit-box-shadow: none;\\n          box-shadow: none; }\\n.nb-theme-default :host .warning-container.outline .original {\\n  background-color: transparent;\\n  border: 2px solid #ffa100; }\\n.nb-theme-default :host .info-container .original {\\n  background-color: #4ca6ff; }\\n.nb-theme-default :host .info-container .hover:hover, .nb-theme-default :host .info-container .hover.hover {\\n  color: #ffffff;\\n  background-color: #65b2ff;\\n  border-color: transparent; }\\n.nb-theme-default :host .info-container .active:active, .nb-theme-default :host .info-container .active.active, .nb-theme-default :host .info-container .active:active:focus {\\n  color: #ffffff;\\n  background-color: #418fdb;\\n  border-color: transparent;\\n  -webkit-box-shadow: none;\\n          box-shadow: none; }\\n.nb-theme-default :host .info-container.outline .original {\\n  background-color: transparent;\\n  border: 2px solid #4ca6ff; }\\n.nb-theme-default :host .danger-container .original {\\n  background-color: #ff4c6a; }\\n.nb-theme-default :host .danger-container .hover:hover, .nb-theme-default :host .danger-container .hover.hover {\\n  color: #ffffff;\\n  background-color: #ff657f;\\n  border-color: transparent; }\\n.nb-theme-default :host .danger-container .active:active, .nb-theme-default :host .danger-container .active.active, .nb-theme-default :host .danger-container .active:active:focus {\\n  color: #ffffff;\\n  background-color: #db415b;\\n  border-color: transparent;\\n  -webkit-box-shadow: none;\\n          box-shadow: none; }\\n.nb-theme-default :host .danger-container.outline .original {\\n  background-color: transparent;\\n  border: 2px solid #ff4c6a; }\\n.nb-theme-default :host .secondary-container .original {\\n  border: 2px solid #dadfe6; }\\n.nb-theme-default :host .secondary-container .hover:hover, .nb-theme-default :host .secondary-container .hover.hover {\\n  color: #ffffff;\\n  background-color: #dfe3ea;\\n  border-color: transparent; }\\n.nb-theme-default :host .secondary-container .active:active, .nb-theme-default :host .secondary-container .active.active, .nb-theme-default :host .secondary-container .active:active:focus {\\n  color: #ffffff;\\n  background-color: #bbc0c6;\\n  border-color: transparent;\\n  -webkit-box-shadow: none;\\n          box-shadow: none; }\\n.nb-theme-default :host .secondary-container.outline .original {\\n  background-color: transparent;\\n  border: 2px solid #dadfe6; }\\n/*\\n      :host can be prefixed\\n      https://github.com/angular/angular/blob/8d0ee34939f14c07876d222c25b405ed458a34d3/packages/compiler/src/shadow_css.ts#L441\\n\\n      We have to use :host insted of :host-context($theme), to be able to prefix theme class\\n      with something defined inside of @content, by prefixing &.\\n      For example this scss code:\\n        .nb-theme-default {\\n          .some-selector & {\\n            ...\\n          }\\n        }\\n      Will result in next css:\\n        .some-selector .nb-theme-default {\\n          ...\\n        }\\n\\n      It doesn't work with :host-context because angular splitting it in two selectors and removes\\n      prefix in one of the selectors.\\n    */\\n.nb-theme-cosmic :host nb-card-header {\\n  display: -webkit-box;\\n  display: -ms-flexbox;\\n  display: flex;\\n  -webkit-box-align: center;\\n      -ms-flex-align: center;\\n          align-items: center;\\n  -webkit-box-pack: justify;\\n      -ms-flex-pack: justify;\\n          justify-content: space-between; }\\n.nb-theme-cosmic :host nb-card-header .dropdown {\\n    -ms-flex-preferred-size: 30%;\\n        flex-basis: 30%;\\n    min-width: 220px; }\\n.nb-theme-cosmic :host nb-card-body {\\n  padding-bottom: 0; }\\n.nb-theme-cosmic :host .example-container {\\n  margin-bottom: 1.5rem; }\\n.nb-theme-cosmic :host .primary-container .original {\\n  background-color: #7659ff; }\\n.nb-theme-cosmic :host .primary-container .hover:hover, .nb-theme-cosmic :host .primary-container .hover.hover {\\n  color: #ffffff;\\n  background-color: #8970ff;\\n  border-color: transparent; }\\n.nb-theme-cosmic :host .primary-container .active:active, .nb-theme-cosmic :host .primary-container .active.active, .nb-theme-cosmic :host .primary-container .active:active:focus {\\n  color: #ffffff;\\n  background-color: #654ddb;\\n  border-color: transparent;\\n  -webkit-box-shadow: none;\\n          box-shadow: none; }\\n.nb-theme-cosmic :host .primary-container.outline .original {\\n  background-color: transparent;\\n  border: 2px solid #7659ff; }\\n.nb-theme-cosmic :host .success-container .original {\\n  background-color: #00d977; }\\n.nb-theme-cosmic :host .success-container .hover:hover, .nb-theme-cosmic :host .success-container .hover.hover {\\n  color: #ffffff;\\n  background-color: #24de8a;\\n  border-color: transparent; }\\n.nb-theme-cosmic :host .success-container .active:active, .nb-theme-cosmic :host .success-container .active.active, .nb-theme-cosmic :host .success-container .active:active:focus {\\n  color: #ffffff;\\n  background-color: #00bb66;\\n  border-color: transparent;\\n  -webkit-box-shadow: none;\\n          box-shadow: none; }\\n.nb-theme-cosmic :host .success-container.outline .original {\\n  background-color: transparent;\\n  border: 2px solid #00d977; }\\n.nb-theme-cosmic :host .warning-container .original {\\n  background-color: #ffa100; }\\n.nb-theme-cosmic :host .warning-container .hover:hover, .nb-theme-cosmic :host .warning-container .hover.hover {\\n  color: #ffffff;\\n  background-color: #ffae24;\\n  border-color: transparent; }\\n.nb-theme-cosmic :host .warning-container .active:active, .nb-theme-cosmic :host .warning-container .active.active, .nb-theme-cosmic :host .warning-container .active:active:focus {\\n  color: #ffffff;\\n  background-color: #db8a00;\\n  border-color: transparent;\\n  -webkit-box-shadow: none;\\n          box-shadow: none; }\\n.nb-theme-cosmic :host .warning-container.outline .original {\\n  background-color: transparent;\\n  border: 2px solid #ffa100; }\\n.nb-theme-cosmic :host .info-container .original {\\n  background-color: #0088ff; }\\n.nb-theme-cosmic :host .info-container .hover:hover, .nb-theme-cosmic :host .info-container .hover.hover {\\n  color: #ffffff;\\n  background-color: #2499ff;\\n  border-color: transparent; }\\n.nb-theme-cosmic :host .info-container .active:active, .nb-theme-cosmic :host .info-container .active.active, .nb-theme-cosmic :host .info-container .active:active:focus {\\n  color: #ffffff;\\n  background-color: #0075db;\\n  border-color: transparent;\\n  -webkit-box-shadow: none;\\n          box-shadow: none; }\\n.nb-theme-cosmic :host .info-container.outline .original {\\n  background-color: transparent;\\n  border: 2px solid #0088ff; }\\n.nb-theme-cosmic :host .danger-container .original {\\n  background-color: #ff386a; }\\n.nb-theme-cosmic :host .danger-container .hover:hover, .nb-theme-cosmic :host .danger-container .hover.hover {\\n  color: #ffffff;\\n  background-color: #ff547f;\\n  border-color: transparent; }\\n.nb-theme-cosmic :host .danger-container .active:active, .nb-theme-cosmic :host .danger-container .active.active, .nb-theme-cosmic :host .danger-container .active:active:focus {\\n  color: #ffffff;\\n  background-color: #db305b;\\n  border-color: transparent;\\n  -webkit-box-shadow: none;\\n          box-shadow: none; }\\n.nb-theme-cosmic :host .danger-container.outline .original {\\n  background-color: transparent;\\n  border: 2px solid #ff386a; }\\n.nb-theme-cosmic :host .secondary-container .original {\\n  border: 2px solid #7659ff; }\\n.nb-theme-cosmic :host .secondary-container .hover:hover, .nb-theme-cosmic :host .secondary-container .hover.hover {\\n  color: #ffffff;\\n  background-color: #8970ff;\\n  border-color: transparent; }\\n.nb-theme-cosmic :host .secondary-container .active:active, .nb-theme-cosmic :host .secondary-container .active.active, .nb-theme-cosmic :host .secondary-container .active:active:focus {\\n  color: #ffffff;\\n  background-color: #654ddb;\\n  border-color: transparent;\\n  -webkit-box-shadow: none;\\n          box-shadow: none; }\\n.nb-theme-cosmic :host .secondary-container.outline .original {\\n  background-color: transparent;\\n  border: 2px solid #7659ff; }\\n/*\\n      :host can be prefixed\\n      https://github.com/angular/angular/blob/8d0ee34939f14c07876d222c25b405ed458a34d3/packages/compiler/src/shadow_css.ts#L441\\n\\n      We have to use :host insted of :host-context($theme), to be able to prefix theme class\\n      with something defined inside of @content, by prefixing &.\\n      For example this scss code:\\n        .nb-theme-default {\\n          .some-selector & {\\n            ...\\n          }\\n        }\\n      Will result in next css:\\n        .some-selector .nb-theme-default {\\n          ...\\n        }\\n\\n      It doesn't work with :host-context because angular splitting it in two selectors and removes\\n      prefix in one of the selectors.\\n    */\\n.nb-theme-corporate :host nb-card-header {\\n  display: -webkit-box;\\n  display: -ms-flexbox;\\n  display: flex;\\n  -webkit-box-align: center;\\n      -ms-flex-align: center;\\n          align-items: center;\\n  -webkit-box-pack: justify;\\n      -ms-flex-pack: justify;\\n          justify-content: space-between; }\\n.nb-theme-corporate :host nb-card-header .dropdown {\\n    -ms-flex-preferred-size: 30%;\\n        flex-basis: 30%;\\n    min-width: 220px; }\\n.nb-theme-corporate :host nb-card-body {\\n  padding-bottom: 0; }\\n.nb-theme-corporate :host .example-container {\\n  margin-bottom: 1.5rem; }\\n.nb-theme-corporate :host .primary-container .original {\\n  background-color: #73a1ff; }\\n.nb-theme-corporate :host .primary-container .hover:hover, .nb-theme-corporate :host .primary-container .hover.hover {\\n  color: #ffffff;\\n  background-color: #87aeff;\\n  border-color: transparent; }\\n.nb-theme-corporate :host .primary-container .active:active, .nb-theme-corporate :host .primary-container .active.active, .nb-theme-corporate :host .primary-container .active:active:focus {\\n  color: #ffffff;\\n  background-color: #638adb;\\n  border-color: transparent;\\n  -webkit-box-shadow: none;\\n          box-shadow: none; }\\n.nb-theme-corporate :host .primary-container.outline .original {\\n  background-color: transparent;\\n  border: 2px solid #73a1ff; }\\n.nb-theme-corporate :host .success-container .original {\\n  background-color: #5dcfe3; }\\n.nb-theme-corporate :host .success-container .hover:hover, .nb-theme-corporate :host .success-container .hover.hover {\\n  color: #ffffff;\\n  background-color: #74d6e7;\\n  border-color: transparent; }\\n.nb-theme-corporate :host .success-container .active:active, .nb-theme-corporate :host .success-container .active.active, .nb-theme-corporate :host .success-container .active:active:focus {\\n  color: #ffffff;\\n  background-color: #50b2c3;\\n  border-color: transparent;\\n  -webkit-box-shadow: none;\\n          box-shadow: none; }\\n.nb-theme-corporate :host .success-container.outline .original {\\n  background-color: transparent;\\n  border: 2px solid #5dcfe3; }\\n.nb-theme-corporate :host .warning-container .original {\\n  background-color: #ffa36b; }\\n.nb-theme-corporate :host .warning-container .hover:hover, .nb-theme-corporate :host .warning-container .hover.hover {\\n  color: #ffffff;\\n  background-color: #ffb080;\\n  border-color: transparent; }\\n.nb-theme-corporate :host .warning-container .active:active, .nb-theme-corporate :host .warning-container .active.active, .nb-theme-corporate :host .warning-container .active:active:focus {\\n  color: #ffffff;\\n  background-color: #db8c5c;\\n  border-color: transparent;\\n  -webkit-box-shadow: none;\\n          box-shadow: none; }\\n.nb-theme-corporate :host .warning-container.outline .original {\\n  background-color: transparent;\\n  border: 2px solid #ffa36b; }\\n.nb-theme-corporate :host .info-container .original {\\n  background-color: #ba7fec; }\\n.nb-theme-corporate :host .info-container .hover:hover, .nb-theme-corporate :host .info-container .hover.hover {\\n  color: #ffffff;\\n  background-color: #c491ef;\\n  border-color: transparent; }\\n.nb-theme-corporate :host .info-container .active:active, .nb-theme-corporate :host .info-container .active.active, .nb-theme-corporate :host .info-container .active:active:focus {\\n  color: #ffffff;\\n  background-color: #a06dcb;\\n  border-color: transparent;\\n  -webkit-box-shadow: none;\\n          box-shadow: none; }\\n.nb-theme-corporate :host .info-container.outline .original {\\n  background-color: transparent;\\n  border: 2px solid #ba7fec; }\\n.nb-theme-corporate :host .danger-container .original {\\n  background-color: #ff6b83; }\\n.nb-theme-corporate :host .danger-container .hover:hover, .nb-theme-corporate :host .danger-container .hover.hover {\\n  color: #ffffff;\\n  background-color: #ff8094;\\n  border-color: transparent; }\\n.nb-theme-corporate :host .danger-container .active:active, .nb-theme-corporate :host .danger-container .active.active, .nb-theme-corporate :host .danger-container .active:active:focus {\\n  color: #ffffff;\\n  background-color: #db5c71;\\n  border-color: transparent;\\n  -webkit-box-shadow: none;\\n          box-shadow: none; }\\n.nb-theme-corporate :host .danger-container.outline .original {\\n  background-color: transparent;\\n  border: 2px solid #ff6b83; }\\n.nb-theme-corporate :host .secondary-container .original {\\n  border: 2px solid #edf2f5; }\\n.nb-theme-corporate :host .secondary-container .hover:hover, .nb-theme-corporate :host .secondary-container .hover.hover {\\n  color: #ffffff;\\n  background-color: #f0f4f6;\\n  border-color: transparent; }\\n.nb-theme-corporate :host .secondary-container .active:active, .nb-theme-corporate :host .secondary-container .active.active, .nb-theme-corporate :host .secondary-container .active:active:focus {\\n  color: #ffffff;\\n  background-color: #ccd0d3;\\n  border-color: transparent;\\n  -webkit-box-shadow: none;\\n          box-shadow: none; }\\n.nb-theme-corporate :host .secondary-container.outline .original {\\n  background-color: transparent;\\n  border: 2px solid #edf2f5; }\\n\"","module.exports = \"<nb-card>\\n  <nb-card-header>Block Level Buttons</nb-card-header>\\n  <nb-card-body>\\n    <div class=\\\"row block-level-buttons\\\">\\n      <div class=\\\"col-md-12\\\">\\n        <div class=\\\"btn-group btn-group-full-width\\\" role=\\\"group\\\">\\n          <button type=\\\"button\\\" class=\\\"btn btn-primary btn-group-icon btn-group-divider btn-fixed\\\">\\n            <i class=\\\"nb-home\\\"></i>\\n          </button>\\n          <button type=\\\"button\\\" class=\\\"btn btn-primary\\\">Icon Block Button</button>\\n        </div>\\n        <button type=\\\"button\\\" class=\\\"btn btn-outline-primary btn-block\\\">Block Button</button>\\n      </div>\\n    </div>\\n  </nb-card-body>\\n</nb-card>\\n\"","import { Component } from '@angular/core';\n\n@Component({\n  selector: 'ngx-default-buttons',\n  styleUrls: ['./default-buttons.component.scss'],\n  templateUrl: './default-buttons.component.html',\n})\nexport class DefaultButtonsComponent {\n\n  buttonsViews = [{\n    title: 'Default Buttons',\n    key: 'default',\n  }, {\n    title: 'Outline Buttons',\n    key: 'outline',\n  }];\n\n  selectedView = this.buttonsViews[0];\n\n  buttons = {\n    'default': [\n      {\n        class: 'btn-primary',\n        container: 'primary-container',\n        containerTitle: 'Primary Button',\n        title: 'Primary',\n        default: '#7659ff',\n      }, {\n        class: 'btn-warning',\n        container: 'warning-container',\n        containerTitle: 'Warning Button',\n        title: 'Warning',\n        default: '#ffcb17',\n      }, {\n        class: 'btn-success',\n        container: 'success-container',\n        containerTitle: 'Success Button',\n        title: 'Success',\n        default: '#00d977',\n      }, {\n        class: 'btn-info',\n        container: 'info-container',\n        containerTitle: 'Info Button',\n        title: 'Info',\n        default: '#0088ff',\n      }, {\n        class: 'btn-danger',\n        container: 'danger-container',\n        containerTitle: 'Danger Button',\n        title: 'Danger',\n        default: '#ff386a',\n      }, {\n        class: 'btn-secondary',\n        container: 'secondary-container',\n        containerTitle: 'Default Button',\n        title: 'Default',\n        default: '#bdbaff',\n      },\n    ],\n\n    'outline': [\n      {\n        class: 'btn-outline-primary',\n        container: 'primary-container outline',\n        containerTitle: 'Primary Button',\n        title: 'Primary',\n        default: '#7659ff',\n      }, {\n        class: 'btn-outline-warning',\n        container: 'warning-container outline',\n        containerTitle: 'Warning Button',\n        title: 'Warning',\n        default: '#ffcb17',\n      }, {\n        class: 'btn-outline-success',\n        container: 'success-container outline',\n        containerTitle: 'Success Button',\n        title: 'Success',\n        default: '#00d977',\n      }, {\n        class: 'btn-outline-info',\n        container: 'info-container',\n        containerTitle: 'Info Button',\n        title: 'Info',\n        default: '#0088ff',\n      }, {\n        class: 'btn-outline-danger',\n        container: 'danger-container outline',\n        containerTitle: 'Danger Button',\n        title: 'Danger',\n        default: '#ff386a',\n      }, {\n        class: 'btn-outline-secondary',\n        container: 'secondary-container outline',\n        containerTitle: 'Default Button',\n        title: 'Default',\n        default: '#bdbaff',\n      },\n    ],\n  };\n}\n","import { Component, OnDestroy } from '@angular/core';\nimport { NbThemeService } from '@nebular/theme';\nimport { Subscription } from 'rxjs';\n\n@Component({\n  selector: 'ngx-hero-buttons',\n  styleUrls: ['./hero-buttons.component.scss'],\n  templateUrl: './hero-buttons.component.html',\n})\nexport class HeroButtonComponent implements OnDestroy {\n\n  themeName = 'default';\n  settings: Array<any>;\n  themeSubscription: Subscription;\n\n  constructor(private themeService: NbThemeService) {\n    this.themeSubscription = this.themeService.getJsTheme().subscribe(theme => {\n      this.themeName = theme.name;\n      this.init(theme.variables);\n    });\n  }\n\n  init(colors: any) {\n    this.settings = [{\n      class: 'btn-hero-primary',\n      container: 'primary-container',\n      title: 'Primary Button',\n      buttonTitle: 'Primary',\n      default: {\n        gradientLeft: `adjust-hue(${colors.primary}, 20deg)`,\n        gradientRight: colors.primary,\n      },\n      corporate: {\n        color: colors.primary,\n        glow: {\n          params: '0 0 20px 0',\n          color: 'rgba (115, 161, 255, 0.5)',\n        },\n      },\n      cosmic: {\n        gradientLeft: `adjust-hue(${colors.primary}, 20deg)`,\n        gradientRight: colors.primary,\n        bevel: `shade(${colors.primary}, 14%)`,\n        shadow: 'rgba (6, 7, 64, 0.5)',\n        glow: {\n          params: '0 2px 12px 0',\n          color: `adjust-hue(${colors.primary}, 10deg)`,\n        },\n      },\n    }, {\n      class: 'btn-hero-warning',\n      container: 'warning-container',\n      title: 'Warning Button',\n      buttonTitle: 'Warning',\n      default: {\n        gradientLeft: `adjust-hue(${colors.warning}, 10deg)`,\n        gradientRight: colors.warning,\n      },\n      corporate: {\n        color: colors.warning,\n        glow: {\n          params: '0 0 20px 0',\n          color: 'rgba (256, 163, 107, 0.5)',\n        },\n      },\n      cosmic: {\n        gradientLeft: `adjust-hue(${colors.warning}, 10deg)`,\n        gradientRight: colors.warning,\n        bevel: `shade(${colors.warning}, 14%)`,\n        shadow: 'rgba (33, 7, 77, 0.5)',\n        glow: {\n          params: '0 2px 12px 0',\n          color: `adjust-hue(${colors.warning}, 5deg)`,\n        },\n      },\n    }, {\n      class: 'btn-hero-success',\n      container: 'success-container',\n      title: 'Success Button',\n      buttonTitle: 'Success',\n      default: {\n        gradientLeft: `adjust-hue(${colors.success}, 20deg)`,\n        gradientRight: colors.success,\n      },\n      corporate: {\n        color: colors.success,\n        glow: {\n          params: '0 0 20px 0',\n          color: 'rgba (93, 207, 227, 0.5)',\n        },\n      },\n      cosmic: {\n        gradientLeft: `adjust-hue(${colors.success}, 20deg)`,\n        gradientRight: colors.success,\n        bevel: `shade(${colors.success}, 14%)`,\n        shadow: 'rgba (33, 7, 77, 0.5)',\n        glow: {\n          params: '0 2px 12px 0',\n          color: `adjust-hue(${colors.success}, 10deg)`,\n        },\n      },\n    }, {\n      class: 'btn-hero-info',\n      container: 'info-container',\n      title: 'Info Button',\n      buttonTitle: 'Info',\n      default: {\n        gradientLeft: `adjust-hue(${colors.info}, -10deg)`,\n        gradientRight: colors.info,\n      },\n      corporate: {\n        color: colors.info,\n        glow: {\n          params: '0 0 20px 0',\n          color: 'rgba (186, 127, 236, 0.5)',\n        },\n      },\n      cosmic: {\n        gradientLeft: `adjust-hue(${colors.info}, -10deg)`,\n        gradientRight: colors.info,\n        bevel: `shade(${colors.info}, 14%)`,\n        shadow: 'rgba (33, 7, 77, 0.5)',\n        glow: {\n          params: '0 2px 12px 0',\n          color: `adjust-hue(${colors.info}, -5deg)`,\n        },\n      },\n    }, {\n      class: 'btn-hero-danger',\n      container: 'danger-container',\n      title: 'Danger Button',\n      buttonTitle: 'Danger',\n      default: {\n        gradientLeft: `adjust-hue(${colors.danger}, -20deg)`,\n        gradientRight: colors.danger,\n      },\n      corporate: {\n        color: colors.danger,\n        glow: {\n          params: '0 0 20px 0',\n          color: 'rgba (255, 107, 131, 0.5)',\n        },\n      },\n      cosmic: {\n        gradientLeft: `adjust-hue(${colors.danger}, -20deg)`,\n        gradientRight: colors.danger,\n        bevel: `shade(${colors.danger}, 14%)`,\n        shadow: 'rgba (33, 7, 77, 0.5)',\n        glow: {\n          params: '0 2px 12px 0',\n          color: `adjust-hue(${colors.danger}, -10deg)`,\n        },\n      },\n    }, {\n      class: 'btn-hero-secondary',\n      container: 'secondary-container',\n      title: 'Ghost Button',\n      buttonTitle: 'Ghost',\n      default: {\n        border: '#dadfe6',\n      },\n      corporate: {\n        color: '#edf2f5',\n      },\n      cosmic: {\n        border: colors.primary,\n        bevel: '#665ebd',\n        shadow: 'rgba (33, 7, 77, 0.5)',\n        glow: {\n          params: '0 2px 12px 0',\n          color: 'rgba (146, 141, 255, 1)',\n        },\n      },\n    }];\n  }\n\n  ngOnDestroy() {\n    this.themeSubscription.unsubscribe();\n  }\n}\n","import { Component } from '@angular/core';\n\n@Component({\n  selector: 'ngx-shape-buttons',\n  styleUrls: ['./shape-buttons.component.scss'],\n  templateUrl: './shape-buttons.component.html',\n})\nexport class ShapeButtonsComponent {\n}\n","import { Component } from '@angular/core';\n\n@Component({\n  selector: 'ngx-size-buttons',\n  styleUrls: ['./size-buttons.component.scss'],\n  templateUrl: './size-buttons.component.html',\n})\nexport class SizeButtonsComponent {\n}\n","import { Component } from '@angular/core';\n\n@Component({\n  selector: 'ngx-buttons',\n  styleUrls: ['./buttons.component.scss'],\n  templateUrl: './buttons.component.html',\n})\nexport class ButtonsComponent {\n}\n","import { NgModule } from '@angular/core';\n\nimport { ThemeModule } from '../../../app/@theme/theme.module';\nimport { DefaultButtonsComponent } from './default-buttons/default-buttons.component';\nimport { HeroButtonComponent } from './hero-buttons/hero-buttons.component';\nimport { ShapeButtonsComponent } from './shape-buttons/shape-buttons.component';\nimport { SizeButtonsComponent } from './size-buttons/size-buttons.component';\nimport { ButtonsComponent } from './buttons.component';\nimport { ActionGroupsComponent } from './action-groups/action-groups.component';\nimport { DropdownButtonsComponent } from './dropdown-buttons/dropdown-button.component';\nimport { BlockLevelButtonsComponent } from './block-level-buttons/block-level-buttons.component';\nimport { ButtonGroupsComponent } from './button-groups/button-groups.component';\nimport { IconButtonsComponent } from './icon-buttons/icon-buttons.component';\nimport { LabeledActionsGroupComponent } from './labeled-actions-group/labeled-actions-group.component';\n\nconst components = [\n  ButtonsComponent,\n  DefaultButtonsComponent,\n  HeroButtonComponent,\n  ShapeButtonsComponent,\n  SizeButtonsComponent,\n  ActionGroupsComponent,\n  DropdownButtonsComponent,\n  BlockLevelButtonsComponent,\n  ButtonGroupsComponent,\n  IconButtonsComponent,\n  LabeledActionsGroupComponent,\n];\n\n@NgModule({\n  imports: [ThemeModule],\n  exports: [...components],\n  declarations: [...components],\n  providers: [],\n})\nexport class ButtonsModule {}\n","import { Component } from '@angular/core';\n\n@Component({\n  selector: 'ngx-action-groups',\n  styleUrls: ['./action-groups.component.scss'],\n  templateUrl: './action-groups.component.html',\n})\nexport class ActionGroupsComponent {\n}\n","import { Component } from '@angular/core';\n\n@Component({\n  selector: 'ngx-dropdown-buttons',\n  styleUrls: ['./dropdown-button.component.scss'],\n  templateUrl: './dropdown-button.component.html',\n})\n\nexport class DropdownButtonsComponent {\n}\n","import { Component } from '@angular/core';\n\n@Component({\n  selector: 'ngx-block-level-buttons',\n  templateUrl: './block-level-buttons.component.html',\n})\nexport class BlockLevelButtonsComponent {\n}\n","import { Component } from '@angular/core';\n\n@Component({\n  selector: 'ngx-button-groups',\n  styleUrls: ['./button-groups.component.scss'],\n  templateUrl: './button-groups.component.html',\n})\nexport class ButtonGroupsComponent {\n\n  radioModel = 'left';\n\n  checkboxModel = {\n    left: false,\n    middle: false,\n    right: false,\n  };\n\n  dividedCheckboxModel = {\n    monday: true,\n    tuesday: true,\n    wednesday: false,\n    thursday: false,\n    friday: false,\n    saturday: false,\n  };\n\n  paginationModel = 1;\n\n  iconToolbarModel = {\n    one: false,\n    two: false,\n    three: true,\n    four: false,\n    five: false,\n  };\n\n  dividedButtonGroupOne = 'left';\n\n  dividedButtonGroupTwo = {\n    left: false,\n    middle: false,\n    right: false,\n  };\n}\n","import { Component } from '@angular/core';\n\n@Component({\n  selector: 'ngx-icon-buttons',\n  styleUrls: ['./icon-buttons.component.scss'],\n  templateUrl: './icon-buttons.component.html',\n})\nexport class IconButtonsComponent {\n}\n","import { Component } from '@angular/core';\n\n@Component({\n  selector: 'ngx-labeled-actions-group',\n  styleUrls: ['./labeled-actions-group.component.scss'],\n  templateUrl: './labeled-actions-group.component.html',\n})\nexport class LabeledActionsGroupComponent {\n}\n","import { Component } from '@angular/core';\n\n@Component({\n  selector: 'ngx-ui-features',\n  template: `\n    <router-outlet></router-outlet>\n  `,\n})\nexport class UiFeaturesComponent {\n}\n","import { Component } from '@angular/core';\n\n@Component({\n  selector: 'ngx-grid',\n  styleUrls: ['./grid.component.scss'],\n  templateUrl: './grid.component.html',\n})\nexport class GridComponent {\n\n}\n","import { Component } from '@angular/core';\n\n@Component({\n  selector: 'ngx-icons',\n  styleUrls: ['./icons.component.scss'],\n  templateUrl: './icons.component.html',\n})\nexport class IconsComponent {\n\n  icons = {\n\n    nebular: ['nb-alert', 'nb-angle-double-left', 'nb-arrow-down', 'nb-arrow-dropdown', 'nb-arrow-dropleft',\n      'nb-arrow-dropright', 'nb-arrow-dropup', 'nb-arrow-left', 'nb-arrow-retweet', 'nb-arrow-right',\n      'nb-arrow-thin-down', 'nb-arrow-thin-left', 'nb-arrow-thin-right', 'nb-arrow-thin-up',\n      'nb-arrow-up', 'nb-audio', 'nb-bar-chart', 'nb-checkmark', 'nb-chevron-down',\n      'nb-chevron-down-outline', 'nb-chevron-left', 'nb-chevron-left-outline', 'nb-chevron-right',\n      'nb-chevron-right-outline', 'nb-chevron-up', 'nb-chevron-up-outline', 'nb-close',\n      'nb-close-circled', 'nb-cloudy', 'nb-coffee-maker', 'nb-compose', 'nb-edit', 'nb-email',\n      'nb-flame-circled', 'nb-gear', 'nb-grid-a', 'nb-grid-a-outline', 'nb-grid-b', 'nb-grid-b-outline',\n      'nb-heart', 'nb-home', 'nb-keypad', 'nb-layout-centre', 'nb-layout-default', 'nb-layout-one-column',\n      'nb-layout-sidebar-left', 'nb-layout-sidebar-right', 'nb-layout-two-column', 'nb-lightbulb',\n      'nb-list', 'nb-location', 'nb-locked', 'nb-loop', 'nb-loop-circled', 'nb-menu', 'nb-notifications',\n      'nb-paper-plane', 'nb-partlysunny', 'nb-pause', 'nb-pause-outline', 'nb-person', 'nb-phone',\n      'nb-play', 'nb-play-outline', 'nb-plus', 'nb-plus-circled', 'nb-power', 'nb-power-circled',\n      'nb-rainy', 'nb-roller-shades', 'nb-search', 'nb-shuffle', 'nb-skip-backward',\n      'nb-skip-backward-outline', 'nb-skip-forward', 'nb-skip-forward-outline', 'nb-snowy-circled',\n      'nb-square', 'nb-square-outline', 'nb-star', 'nb-sunny', 'nb-sunny-circled', 'nb-tables', 'nb-title',\n      'nb-trash', 'nb-volume-high', 'nb-volume-mute', 'nb-drop', 'nb-drops', 'nb-info'],\n\n    ionicons: [\n      'ion-ionic', 'ion-arrow-right-b', 'ion-arrow-down-b', 'ion-arrow-left-b', 'ion-arrow-up-c', 'ion-arrow-right-c',\n      'ion-arrow-down-c', 'ion-arrow-left-c', 'ion-arrow-return-right', 'ion-arrow-return-left', 'ion-arrow-swap',\n      'ion-arrow-shrink', 'ion-arrow-expand', 'ion-arrow-move', 'ion-arrow-resize', 'ion-chevron-up',\n      'ion-chevron-right', 'ion-chevron-down', 'ion-chevron-left', 'ion-navicon-round', 'ion-navicon',\n      'ion-drag', 'ion-log-in', 'ion-log-out', 'ion-checkmark-round', 'ion-checkmark', 'ion-checkmark-circled',\n      'ion-close-round', 'ion-plus-round', 'ion-minus-round', 'ion-information', 'ion-help',\n      'ion-backspace-outline', 'ion-help-buoy', 'ion-asterisk', 'ion-alert', 'ion-alert-circled',\n      'ion-refresh', 'ion-loop', 'ion-shuffle', 'ion-home', 'ion-search', 'ion-flag', 'ion-star',\n      'ion-heart', 'ion-heart-broken', 'ion-gear-a', 'ion-gear-b', 'ion-toggle-filled', 'ion-toggle',\n      'ion-settings', 'ion-wrench', 'ion-hammer', 'ion-edit', 'ion-trash-a', 'ion-trash-b',\n      'ion-document', 'ion-document-text', 'ion-clipboard', 'ion-scissors', 'ion-funnel',\n      'ion-bookmark', 'ion-email', 'ion-email-unread', 'ion-folder', 'ion-filing', 'ion-archive',\n      'ion-reply', 'ion-reply-all', 'ion-forward',\n    ],\n\n    fontAwesome: [\n      'fa fa-adjust', 'fa fa-anchor', 'fa fa-archive', 'fa fa-area-chart', 'fa fa-arrows', 'fa fa-arrows-h',\n      'fa fa-arrows-v', 'fa fa-asterisk', 'fa fa-at', 'fa fa-automobile', 'fa fa-ban', 'fa fa-bank',\n      'fa fa-bar-chart', 'fa fa-bar-chart-o', 'fa fa-barcode', 'fa fa-bars', 'fa fa-bed', 'fa fa-beer',\n      'fa fa-bell', 'fa fa-bell-o', 'fa fa-bell-slash', 'fa fa-bell-slash-o', 'fa fa-bicycle', 'fa fa-binoculars',\n      'fa fa-birthday-cake', 'fa fa-bolt', 'fa fa-bomb', 'fa fa-book', 'fa fa-bookmark', 'fa fa-bookmark-o',\n      'fa fa-briefcase', 'fa fa-bug', 'fa fa-building', 'fa fa-building-o', 'fa fa-bullhorn',\n    ],\n  };\n\n}\n","import { Component } from '@angular/core';\nimport { NgbActiveModal } from '@ng-bootstrap/ng-bootstrap';\n\n@Component({\n  selector: 'ngx-modal',\n  template: `\n    <div class=\"modal-header\">\n      <span>{{ modalHeader }}</span>\n      <button class=\"close\" aria-label=\"Close\" (click)=\"closeModal()\">\n        <span aria-hidden=\"true\">&times;</span>\n      </button>\n    </div>\n    <div class=\"modal-body\">\n      {{ modalContent }}\n    </div>\n    <div class=\"modal-footer\">\n      <button class=\"btn btn-md btn-primary\" (click)=\"closeModal()\">Save changes</button>\n    </div>\n  `,\n})\nexport class ModalComponent {\n\n  modalHeader: string;\n  modalContent = `Lorem ipsum dolor sit amet, consectetuer adipiscing elit, sed diam nonummy\n    nibh euismod tincidunt ut laoreet dolore magna aliquam erat volutpat. Ut wisi enim ad minim veniam, quis\n    nostrud exerci tation ullamcorper suscipit lobortis nisl ut aliquip ex ea commodo consequat.`;\n\n  constructor(private activeModal: NgbActiveModal) { }\n\n  closeModal() {\n    this.activeModal.close();\n  }\n}\n","import { Component } from '@angular/core';\nimport { NgbModal } from '@ng-bootstrap/ng-bootstrap';\n\nimport { ModalComponent } from './modal/modal.component';\n\n@Component({\n  selector: 'ngx-modals',\n  styleUrls: ['./modals.component.scss'],\n  templateUrl: './modals.component.html',\n})\nexport class ModalsComponent {\n\n  constructor(private modalService: NgbModal) { }\n\n  showLargeModal() {\n    const activeModal = this.modalService.open(ModalComponent, { size: 'lg', container: 'nb-layout' });\n\n    activeModal.componentInstance.modalHeader = 'Large Modal';\n  }\n  showSmallModal() {\n    const activeModal = this.modalService.open(ModalComponent, { size: 'sm', container: 'nb-layout' });\n\n    activeModal.componentInstance.modalHeader = 'Small Modal';\n  }\n\n  showStaticModal() {\n    const activeModal = this.modalService.open(ModalComponent, {\n      size: 'sm',\n      backdrop: 'static',\n      container: 'nb-layout',\n    });\n\n    activeModal.componentInstance.modalHeader = 'Static modal';\n    activeModal.componentInstance.modalContent = `This is static modal, backdrop click\n                                                    will not close it. Click  or confirmation button to close modal.`;\n  }\n\n}\n","import { Component, OnDestroy } from '@angular/core';\nimport { NbThemeService, NbMediaBreakpoint, NbMediaBreakpointsService } from '@nebular/theme';\n\n@Component({\n  selector: 'ngx-typography',\n  styleUrls: ['./typography.component.scss'],\n  templateUrl: './typography.component.html',\n})\nexport class TypographyComponent implements OnDestroy {\n  breakpoint: NbMediaBreakpoint;\n  breakpoints: any;\n  themeSubscription: any;\n\n  constructor(private themeService: NbThemeService,\n              private breakpointService: NbMediaBreakpointsService) {\n\n    this.breakpoints = this.breakpointService.getBreakpointsMap();\n    this.themeSubscription = this.themeService.onMediaQueryChange()\n      .subscribe(([oldValue, newValue]) => {\n        this.breakpoint = newValue;\n      });\n  }\n\n  ngOnDestroy() {\n    this.themeSubscription.unsubscribe();\n  }\n}\n","import { Component } from '@angular/core';\n\n@Component({\n  selector: 'ngx-tab1',\n  template: `\n    <p>Early home automation began with labor-saving machines. Self-contained electric or gas powered\n      <a target=\"_blank\" href=\"https://en.wikipedia.org/wiki/Home_appliances\">home appliances</a>\n      became viable in the 1900s with the introduction of\n      <a target=\"_blank\" href=\"https://en.wikipedia.org/wiki/Electric_power_distribution\">electric power distribution\n      </a> and led to the introduction of washing machines (1904), water heaters (1889), refrigerators, sewing machines,\n      dishwashers, and clothes dryers.\n    </p>\n  `,\n})\nexport class Tab1Component { }\n\n@Component({\n  selector: 'ngx-tab2',\n  template: `\n    <p>Tab 2 works!</p>\n  `,\n})\nexport class Tab2Component { }\n\n@Component({\n  selector: 'ngx-tabs',\n  styleUrls: ['./tabs.component.scss'],\n  templateUrl: './tabs.component.html',\n})\nexport class TabsComponent {\n\n  tabs: any[] = [\n    {\n      title: 'Route tab #1',\n      route: '/pages/ui-features/tabs/tab1',\n    },\n    {\n      title: 'Route tab #2',\n      route: '/pages/ui-features/tabs/tab2',\n    },\n  ];\n\n}\n","import { Component } from '@angular/core';\n\n@Component({\n    selector: 'ngx-search-fields',\n    templateUrl: 'search-fields.component.html',\n})\nexport class SearchComponent {\n}\n","import { Component } from '@angular/core';\n\n@Component({\n  selector: 'ngx-popover-tabs',\n  template: `\n    <nb-tabset>\n      <nb-tab tabTitle=\"What's up?\">\n        <div class=\"p-4\">\n          Such a wonderful day!\n        </div>\n      </nb-tab>\n      <nb-tab tabTitle=\"Second Tab\">\n        <div class=\"p-4\">\n          Indeed!\n        </div>\n      </nb-tab>\n    </nb-tabset>\n  `,\n})\nexport class NgxPopoverTabsComponent {\n}\n\n@Component({\n  selector: 'ngx-popover-form',\n  template: `\n    <div class=\"p-4\">\n      <form>\n        <div class=\"form-group\">\n          <input type=\"text\" class=\"form-control\" placeholder=\"Recipients\">\n        </div>\n        <div class=\"form-group\">\n          <input type=\"text\" class=\"form-control\" placeholder=\"Subject\">\n        </div>\n        <div class=\"form-group\">\n          <textarea class=\"form-control\" placeholder=\"Message\"></textarea>\n        </div>\n        <button type=\"submit\" class=\"btn btn-primary w-100\">Send</button>\n      </form>\n    </div>\n  `,\n})\nexport class NgxPopoverFormComponent {\n}\n\n@Component({\n  selector: 'ngx-popover-card',\n  template: `\n    <nb-card class=\"popover-card\">\n      <nb-card-header status=\"warning\">\n        Hello!\n      </nb-card-header>\n      <nb-card-body>\n        Far far away, behind the word mountains, far from the countries Vokalia and Consonantia,\n        there live the blind texts.\n        Separated they live in Bookmarksgrove right at the coast of the Semantics, a large language ocean.\n      </nb-card-body>\n    </nb-card>\n  `,\n})\nexport class NgxPopoverCardComponent {\n}\n","import { Component } from '@angular/core';\nimport {\n  NgxPopoverCardComponent, NgxPopoverFormComponent,\n  NgxPopoverTabsComponent,\n} from './popover-examples.component';\n\n@Component({\n  selector: 'ngx-popovers',\n  styleUrls: ['./popovers.component.scss'],\n  templateUrl: './popovers.component.html',\n})\nexport class PopoversComponent {\n  tabsComponent = NgxPopoverTabsComponent;\n  cardComponent = NgxPopoverCardComponent;\n  formComponent = NgxPopoverFormComponent;\n}\n","import { NgModule } from '@angular/core';\nimport { Routes, RouterModule } from '@angular/router';\n\nimport { UiFeaturesComponent } from './ui-features.component';\nimport { ButtonsComponent } from './buttons/buttons.component';\nimport { GridComponent } from './grid/grid.component';\nimport { IconsComponent } from './icons/icons.component';\nimport { ModalsComponent } from './modals/modals.component';\nimport { TypographyComponent } from './typography/typography.component';\nimport { TabsComponent, Tab1Component, Tab2Component } from './tabs/tabs.component';\nimport { SearchComponent } from './search-fields/search-fields.component';\nimport { PopoversComponent } from './popovers/popovers.component';\n\nconst routes: Routes = [{\n  path: '',\n  component: UiFeaturesComponent,\n  children: [{\n    path: 'buttons',\n    component: ButtonsComponent,\n  }, {\n    path: 'grid',\n    component: GridComponent,\n  }, {\n    path: 'icons',\n    component: IconsComponent,\n  }, {\n    path: 'modals',\n    component: ModalsComponent,\n  }, {\n    path: 'popovers',\n    component: PopoversComponent,\n  }, {\n    path: 'typography',\n    component: TypographyComponent,\n  }, {\n    path: 'search-fields',\n    component: SearchComponent,\n  }, {\n    path: 'tabs',\n    component: TabsComponent,\n    children: [{\n      path: '',\n      redirectTo: 'tab1',\n      pathMatch: 'full',\n    }, {\n      path: 'tab1',\n      component: Tab1Component,\n    }, {\n      path: 'tab2',\n      component: Tab2Component,\n    }],\n  }],\n}];\n\n@NgModule({\n  imports: [RouterModule.forChild(routes)],\n  exports: [RouterModule],\n})\nexport class UiFeaturesRoutingModule { }\n","import { NgModule } from '@angular/core';\n\nimport { ThemeModule } from '../../app/@theme/theme.module';\nimport { ButtonsModule } from './buttons/buttons.module';\nimport { UiFeaturesRoutingModule } from './ui-features-routing.module';\nimport { UiFeaturesComponent } from './ui-features.component';\nimport { GridComponent } from './grid/grid.component';\nimport { ModalsComponent } from './modals/modals.component';\nimport { IconsComponent } from './icons/icons.component';\nimport { ModalComponent } from './modals/modal/modal.component';\nimport { TypographyComponent } from './typography/typography.component';\nimport {\n  TabsComponent,\n  Tab1Component,\n  Tab2Component,\n} from './tabs/tabs.component';\nimport { SearchComponent } from './search-fields/search-fields.component';\nimport { PopoversComponent } from './popovers/popovers.component';\nimport {\n  NgxPopoverCardComponent,\n  NgxPopoverFormComponent,\n  NgxPopoverTabsComponent,\n} from './popovers/popover-examples.component';\n\nconst components = [\n  UiFeaturesComponent,\n  GridComponent,\n  ModalsComponent,\n  IconsComponent,\n  ModalComponent,\n  TypographyComponent,\n  TabsComponent,\n  Tab1Component,\n  Tab2Component,\n  SearchComponent,\n  PopoversComponent,\n  NgxPopoverCardComponent,\n  NgxPopoverFormComponent,\n  NgxPopoverTabsComponent,\n];\n\n@NgModule({\n  imports: [ThemeModule, UiFeaturesRoutingModule, ButtonsModule],\n  declarations: [...components],\n  entryComponents: [\n    ModalComponent,\n    NgxPopoverCardComponent,\n    NgxPopoverFormComponent,\n    NgxPopoverTabsComponent,\n  ],\n})\nexport class UiFeaturesModule {}\n","module.exports = \"<nb-card>\\n  <nb-card-header>Button Sizes</nb-card-header>\\n\\n  <nb-card-body>\\n    <div class=\\\"size-container\\\">\\n      <div class=\\\"container-title\\\">\\n        <span>Large Button</span>\\n      </div>\\n      <div class=\\\"subheader\\\">\\n        <span>0.875rem 1.75rem</span>\\n      </div>\\n      <div>\\n        <button class=\\\"btn btn-primary btn-lg\\\">Large Button</button>\\n      </div>\\n    </div>\\n    <div class=\\\"size-container\\\">\\n      <div class=\\\"container-title\\\">\\n        <span>Medium Button</span>\\n      </div>\\n      <div class=\\\"subheader\\\">\\n        <span>0.75rem 1.5rem</span>\\n      </div>\\n      <div>\\n        <button class=\\\"btn btn-primary btn-md\\\">Medium Button</button>\\n      </div>\\n    </div>\\n    <div class=\\\"size-container\\\">\\n      <div class=\\\"container-title\\\">\\n        <span>Small Button</span>\\n      </div>\\n      <div class=\\\"subheader\\\">\\n        <span>0.675rem 1.5rem</span>\\n      </div>\\n      <div>\\n        <button class=\\\"btn btn-primary btn-sm\\\">Small Button</button>\\n      </div>\\n    </div>\\n    <div class=\\\"size-container\\\">\\n      <div class=\\\"container-title\\\">\\n        <span>Tiny Button</span>\\n      </div>\\n      <div class=\\\"subheader\\\">\\n        <span>0.5rem 1.25rem</span>\\n      </div>\\n      <div>\\n        <button class=\\\"btn btn-primary btn-tn\\\">Tiny</button>\\n      </div>\\n    </div>\\n  </nb-card-body>\\n</nb-card>\\n\"","module.exports = \".icon {\\n  display: inline-block;\\n  width: 4rem;\\n  padding: 1.25rem 0;\\n  text-align: center;\\n  font-size: 1.25rem; }\\n  .icon i:hover {\\n    opacity: 0.8;\\n    cursor: pointer; }\\n  .nb-icons .icon {\\n  padding: 0.75rem 0;\\n  font-size: 1.75rem; }\\n  nb-card-body {\\n  padding: 0; }\\n  nb-card-footer {\\n  text-align: right; }\\n\"","module.exports = \"<div class=\\\"row\\\">\\n  <div class=\\\"col-md-12\\\">\\n    <nb-card>\\n      <nb-card-header>\\n        Grid System\\n      </nb-card-header>\\n      <nb-card-body>\\n        <h5 class=\\\"grid-h\\\">Stacked to horizontal</h5>\\n        <div class=\\\"row show-grid\\\">\\n          <div class=\\\"col-md-1\\\">\\n            <div>.col-md-1</div>\\n          </div>\\n          <div class=\\\"col-md-1\\\">\\n            <div>.col-md-1</div>\\n          </div>\\n          <div class=\\\"col-md-1\\\">\\n            <div>.col-md-1</div>\\n          </div>\\n          <div class=\\\"col-md-1\\\">\\n            <div>.col-md-1</div>\\n          </div>\\n          <div class=\\\"col-md-1\\\">\\n            <div>.col-md-1</div>\\n          </div>\\n          <div class=\\\"col-md-1\\\">\\n            <div>.col-md-1</div>\\n          </div>\\n          <div class=\\\"col-md-1\\\">\\n            <div>.col-md-1</div>\\n          </div>\\n          <div class=\\\"col-md-1\\\">\\n            <div>.col-md-1</div>\\n          </div>\\n          <div class=\\\"col-md-1\\\">\\n            <div>.col-md-1</div>\\n          </div>\\n          <div class=\\\"col-md-1\\\">\\n            <div>.col-md-1</div>\\n          </div>\\n          <div class=\\\"col-md-1\\\">\\n            <div>.col-md-1</div>\\n          </div>\\n          <div class=\\\"col-md-1\\\">\\n            <div>.col-md-1</div>\\n          </div>\\n        </div>\\n        <div class=\\\"row show-grid\\\">\\n          <div class=\\\"col-md-8\\\">\\n            <div>.col-md-8</div>\\n          </div>\\n          <div class=\\\"col-md-4\\\">\\n            <div>.col-md-4</div>\\n          </div>\\n        </div>\\n        <div class=\\\"row show-grid\\\">\\n          <div class=\\\"col-md-4\\\">\\n            <div>.col-md-4</div>\\n          </div>\\n          <div class=\\\"col-md-4\\\">\\n            <div>.col-md-4</div>\\n          </div>\\n          <div class=\\\"col-md-4\\\">\\n            <div>.col-md-4</div>\\n          </div>\\n        </div>\\n        <div class=\\\"row show-grid\\\">\\n          <div class=\\\"col-md-6\\\">\\n            <div>.col-md-6</div>\\n          </div>\\n          <div class=\\\"col-md-6\\\">\\n            <div>.col-md-6</div>\\n          </div>\\n        </div>\\n\\n        <h5 class=\\\"grid-h\\\">Mobile and desktop</h5>\\n        <div class=\\\"row show-grid\\\">\\n          <div class=\\\"col-12 col-md-8\\\">\\n            <div>.col-12 .col-md-8</div>\\n          </div>\\n          <div class=\\\"col-6 col-md-4\\\">\\n            <div>.col-6 .col-md-4</div>\\n          </div>\\n        </div>\\n        <div class=\\\"row show-grid\\\">\\n          <div class=\\\"col-6 col-md-4\\\">\\n            <div>.col-6 .col-md-4</div>\\n          </div>\\n          <div class=\\\"col-6 col-md-4\\\">\\n            <div>col-6 .col-md-4</div>\\n          </div>\\n          <div class=\\\"col-6 col-md-4\\\">\\n            <div>.col-6 .col-md-4</div>\\n          </div>\\n        </div>\\n        <div class=\\\"row show-grid\\\">\\n          <div class=\\\"col-6\\\">\\n            <div>.col-6</div>\\n          </div>\\n          <div class=\\\"col-6\\\">\\n            <div>.col-6</div>\\n          </div>\\n        </div>\\n\\n        <h5 class=\\\"grid-h\\\">Mobile, tablet, desktop</h5>\\n        <div class=\\\"row show-grid\\\">\\n          <div class=\\\"col-12 col-sm-6 col-md-8\\\">\\n            <div>.col-12 .col-sm-6 .col-md-8</div>\\n          </div>\\n          <div class=\\\"col-6 col-md-4\\\">\\n            <div>.col-6 .col-md-4</div>\\n          </div>\\n        </div>\\n        <div class=\\\"row show-grid\\\">\\n          <div class=\\\"col-6 col-sm-4\\\">\\n            <div>.col-6 .col-sm-4</div>\\n          </div>\\n          <div class=\\\"col-6 col-sm-4\\\">\\n            <div>.col-6 .col-sm-4</div>\\n          </div>\\n          <div class=\\\"col-6 col-sm-4\\\">\\n            <div>.col-6 .col-sm-4</div>\\n          </div>\\n        </div>\\n\\n        <h5 class=\\\"grid-h\\\">Column wrapping</h5>\\n        <div class=\\\"row show-grid\\\">\\n          <div class=\\\"col-9\\\">\\n            <div>.col-9</div>\\n          </div>\\n          <div class=\\\"col-4\\\">\\n            <div>.col-4<br>Since 9 + 4 = 13 &gt; 12, this 4-column-wide div gets wrapped onto a new line as one contiguous unit.\\n            </div>\\n          </div>\\n          <div class=\\\"col-6\\\">\\n            <div>.col-6<br>Subsequent columns continue along the new line.</div>\\n          </div>\\n        </div>\\n\\n        <h5 class=\\\"grid-h\\\">Responsive column resets</h5>\\n        <div class=\\\"row show-grid\\\">\\n          <div class=\\\"col-6 col-sm-3\\\">\\n            <div>.col-6 .col-sm-3\\n              <p>Resize your viewport or check it out on your phone for an example.</p>\\n            </div>\\n          </div>\\n          <div class=\\\"col-6 col-sm-3\\\">\\n            <div>.col-6 .col-sm-3</div>\\n          </div>\\n          <div class=\\\"col-6 col-sm-3\\\">\\n            <div>.col-6 .col-sm-3</div>\\n          </div>\\n          <div class=\\\"col-6 col-sm-3\\\">\\n            <div>.col-6 .col-sm-3</div>\\n          </div>\\n        </div>\\n\\n        <h5 class=\\\"grid-h\\\">Offsetting columns</h5>\\n        <div class=\\\"row show-grid\\\">\\n          <div class=\\\"col-md-4\\\">\\n            <div>.col-md-4</div>\\n          </div>\\n          <div class=\\\"col-md-4 offset-md-4\\\">\\n            <div>.col-md-4 .offset-md-4</div>\\n          </div>\\n        </div>\\n        <div class=\\\"row show-grid\\\">\\n          <div class=\\\"col-md-3 offset-md-3\\\">\\n            <div>.col-md-3 .offset-md-3</div>\\n          </div>\\n          <div class=\\\"col-md-3 offset-md-3\\\">\\n            <div>.col-md-3 .offset-md-3</div>\\n          </div>\\n        </div>\\n        <div class=\\\"row show-grid\\\">\\n          <div class=\\\"col-md-6 offset-md-3\\\">\\n            <div>.col-md-6 .offset-md-3</div>\\n          </div>\\n        </div>\\n\\n        <h5 class=\\\"grid-h\\\">Grid options</h5>\\n        <div class=\\\"table-responsive\\\">\\n          <table class=\\\"table table-bordered table-striped\\\">\\n            <thead>\\n              <tr>\\n                <th></th>\\n                <th> Extra small devices\\n                  <small>Phones (&lt;576px)</small>\\n                </th>\\n                <th> Small devices\\n                  <small>Tablets (576px)</small>\\n                </th>\\n                <th> Medium devices\\n                  <small>Desktops (768px)</small>\\n                </th>\\n                <th> Large devices\\n                  <small>Desktops (992px)</small>\\n                </th>\\n                <th> Large devices\\n                  <small>Desktops (1200px)</small>\\n                </th>\\n              </tr>\\n            </thead>\\n            <tbody>\\n              <tr>\\n                <th class=\\\"text-nowrap\\\" scope=\\\"row\\\">Grid behavior</th>\\n                <td>Horizontal at all times</td>\\n                <td colspan=\\\"4\\\">Collapsed to start, horizontal above breakpoints</td>\\n              </tr>\\n              <tr>\\n                <th class=\\\"text-nowrap\\\" scope=\\\"row\\\">Container width</th>\\n                <td>None (auto)</td>\\n                <td>540px</td>\\n                <td>720px</td>\\n                <td>960px</td>\\n                <td>1140px</td>\\n              </tr>\\n              <tr>\\n                <th class=\\\"text-nowrap\\\" scope=\\\"row\\\">Class prefix</th>\\n                <td><code>.col-</code></td>\\n                <td><code>.col-sm-</code></td>\\n                <td><code>.col-md-</code></td>\\n                <td><code>.col-lg-</code></td>\\n                <td><code>.col-xl-</code></td>\\n              </tr>\\n              <tr>\\n                <th class=\\\"text-nowrap\\\" scope=\\\"row\\\"># of columns</th>\\n                <td colspan=\\\"5\\\">12</td>\\n              </tr>\\n              <tr>\\n                <th class=\\\"text-nowrap\\\" scope=\\\"row\\\">Gutter width</th>\\n                <td colspan=\\\"5\\\">1.875rem / 30px (15px on each side of a column)</td>\\n              </tr>\\n              <tr>\\n                <th class=\\\"text-nowrap\\\" scope=\\\"row\\\">Nestable</th>\\n                <td colspan=\\\"5\\\">Yes</td>\\n              </tr>\\n              <tr>\\n                <th class=\\\"text-nowrap\\\" scope=\\\"row\\\">Offsets</th>\\n                <td colspan=\\\"5\\\">Yes</td>\\n              </tr>\\n              <tr>\\n                <th class=\\\"text-nowrap\\\" scope=\\\"row\\\">Column ordering</th>\\n                <td colspan=\\\"5\\\">Yes</td>\\n              </tr>\\n            </tbody>\\n          </table>\\n        </div>\\n      </nb-card-body>\\n    </nb-card>\\n  </div>\\n</div>\\n\"","module.exports = \"<div class=\\\"row\\\">\\n  <div class=\\\"col-lg-12\\\">\\n    <ngx-hero-buttons></ngx-hero-buttons>\\n  </div>\\n  <div class=\\\"col-md-12 col-lg-12 col-xxxl-6\\\">\\n    <ngx-shape-buttons></ngx-shape-buttons>\\n    <ngx-action-groups></ngx-action-groups>\\n    <ngx-labeled-actions-group></ngx-labeled-actions-group>\\n\\n    <div class=\\\"row\\\">\\n      <div class=\\\"col-lg-5\\\">\\n        <ngx-dropdown-buttons></ngx-dropdown-buttons>\\n        <ngx-icon-buttons></ngx-icon-buttons>\\n      </div>\\n      <div class=\\\"col-lg-7\\\">\\n        <ngx-button-groups></ngx-button-groups>\\n      </div>\\n    </div>\\n  </div>\\n  <div class=\\\"col-md-12 col-lg-12 col-xxxl-6\\\">\\n    <ngx-size-buttons></ngx-size-buttons>\\n    <ngx-default-buttons></ngx-default-buttons>\\n    <ngx-block-level-buttons></ngx-block-level-buttons>\\n  </div>\\n</div>\\n\"","module.exports = \"nb-card-body div:not(:last-child) {\\n  margin-bottom: 1rem; }\\n\\n.btn-with-icon-example {\\n  width: 100%; }\\n\\n.btn-with-icon-example .btn {\\n    width: 100%; }\\n\\n.btn-group:not(:last-child) {\\n  margin-bottom: 1rem; }\\n\\n.icon-button-examples {\\n  display: -webkit-box;\\n  display: -ms-flexbox;\\n  display: flex;\\n  -webkit-box-pack: justify;\\n      -ms-flex-pack: justify;\\n          justify-content: space-between; }\\n\\n.icon-button-examples button {\\n    min-width: 4rem; }\\n\\n.icon-button-examples:not(:last-child) {\\n  margin-bottom: 1rem; }\\n\"","module.exports = \"/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/**\\n * This mixin generates keyfames.\\n * Because of all keyframes can't be scoped,\\n * we need to puts unique name in each btn-pulse call.\\n */\\n/*\\n\\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\\n:host and :host-context are pseudo-classes. So we assume they could be combined,\\nlike other pseudo-classes, even same ones.\\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\\n\\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\\nso direction could be overridden on any component level.\\n\\nImplementation code:\\n\\n@mixin nb-rtl() {\\n  // add # to scss interpolation statement.\\n  // it works in comments and we can't use it here\\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\\n    @content;\\n  }\\n}\\n\\nAnd when we call it somewhere:\\n\\n:host {\\n  .some-class {\\n    @include nb-rtl() {\\n      ...\\n    }\\n  }\\n}\\n:host-context(...) {\\n  .some-class {\\n    @include nb-rtl() {\\n      ...\\n    }\\n  }\\n}\\n\\nResult will look like:\\n\\n:host-context([dir=rtl]):host .some-class {\\n  ...\\n}\\n:host-context([dir=rtl]):host-context(...) .some-class {\\n  ...\\n}\\n\\n*\\n  Side note:\\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\\n\\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\\n  so order is not important.\\n*\\n\\n\\nCurrently, there're two problems with this approach:\\n\\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\\nFor the moment of writing, the only possible way is:\\n:host {\\n  :host-context(...) {\\n    ...\\n  }\\n}\\nIt doesn't work for us because mixin could be called somewhere deeper, like:\\n:host {\\n  p {\\n    @include nb-rtl() { ... }\\n  }\\n}\\nWe are not able to go up to :host level to place content passed to mixin.\\n\\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\\n  *\\n    Side note:\\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\\n    :host-context($theme) once we will be able to use multiple shadow selectors.\\n  *\\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\\n  ***\\n    Possible solution\\n    check if we in theme by some theme variables and if so append, otherwise nest like\\n    @at-root :host-context([dir=rtl]) {\\n      // add # to scss interpolation statement.\\n      // it works in comments and we can't use it here\\n      {&} {\\n        @content;\\n      }\\n    }\\n    What if :host specified? Can we add space in :host-context(...) :host?\\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\\n  ***\\n\\n\\nProblems with the current approach.\\n\\n1. Direction can be applied only on document level, because mixin prepends theme class,\\nwhich placed on the body.\\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\\nattribute to [dir=rtl] attribute as well.\\n\\n\\nGeneral problems.\\n\\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\\n*/\\n/deep/ nb-card.popover-card {\\n  margin-bottom: 0;\\n  width: 300px;\\n  -webkit-box-shadow: none;\\n          box-shadow: none; }\\n[dir=ltr] :host button.with-margins {\\n  margin: 0 0.75rem 2rem 0; }\\n[dir=rtl] :host button.with-margins {\\n  margin: 0 0 2rem 0.75rem; }\\n[dir=ltr] :host /deep/ .btn-outline-secondary {\\n  margin: 0 0.5rem 0.5rem 0; }\\n[dir=rtl] :host /deep/ .btn-outline-secondary {\\n  margin: 0 0 0.5rem 0.5rem; }\\n\"","module.exports = \"<div class=\\\"row\\\">\\n  <div class=\\\"col-md-12 col-lg-6\\\">\\n    <nb-card class=\\\"nb-icons\\\">\\n      <nb-card-header>\\n        Nebular\\n      </nb-card-header>\\n      <nb-card-body>\\n        <div class=\\\"icon\\\"\\n             *ngFor=\\\"let icon of icons.nebular\\\">\\n          <i class=\\\"{{ icon }}\\\" [nbPopover]=\\\"icon\\\"></i>\\n        </div>\\n      </nb-card-body>\\n    </nb-card>\\n\\n    <nb-card>\\n      <nb-card-header>\\n        Font awesome icons\\n      </nb-card-header>\\n      <nb-card-body>\\n        <div class=\\\"icon\\\"\\n             *ngFor=\\\"let icon of icons.fontAwesome\\\">\\n          <i class=\\\"fa {{ icon }}\\\" [nbPopover]=\\\"icon\\\"></i>\\n        </div>\\n      </nb-card-body>\\n      <nb-card-footer>\\n        <a href=\\\"http://fortawesome.github.io/Font-Awesome/icons/\\\" target=\\\"_blank\\\">\\n          See all Font Awesome icons\\n        </a>\\n      </nb-card-footer>\\n    </nb-card>\\n  </div>\\n\\n  <div class=\\\"col-md-12 col-lg-6\\\">\\n    <nb-card>\\n      <nb-card-header>\\n        Ionicons\\n      </nb-card-header>\\n      <nb-card-body>\\n        <div class=\\\"icon\\\" *ngFor=\\\"let icon of icons.ionicons\\\">\\n          <i class=\\\"{{ icon }}\\\" [nbPopover]=\\\"icon\\\"></i>\\n        </div>\\n      </nb-card-body>\\n      <nb-card-footer>\\n        <a href=\\\"http://ionicons.com/\\\" target=\\\"_blank\\\">See all ionicons icons</a>\\n      </nb-card-footer>\\n    </nb-card>\\n  </div>\\n</div>\\n\"","module.exports = \"/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/**\\n * This is a starting point where we declare the maps of themes and globally available functions/mixins\\n */\\n/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/**\\n * This mixin generates keyfames.\\n * Because of all keyframes can't be scoped,\\n * we need to puts unique name in each btn-pulse call.\\n */\\n/*\\n\\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\\n:host and :host-context are pseudo-classes. So we assume they could be combined,\\nlike other pseudo-classes, even same ones.\\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\\n\\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\\nso direction could be overridden on any component level.\\n\\nImplementation code:\\n\\n@mixin nb-rtl() {\\n  // add # to scss interpolation statement.\\n  // it works in comments and we can't use it here\\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\\n    @content;\\n  }\\n}\\n\\nAnd when we call it somewhere:\\n\\n:host {\\n  .some-class {\\n    @include nb-rtl() {\\n      ...\\n    }\\n  }\\n}\\n:host-context(...) {\\n  .some-class {\\n    @include nb-rtl() {\\n      ...\\n    }\\n  }\\n}\\n\\nResult will look like:\\n\\n:host-context([dir=rtl]):host .some-class {\\n  ...\\n}\\n:host-context([dir=rtl]):host-context(...) .some-class {\\n  ...\\n}\\n\\n*\\n  Side note:\\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\\n\\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\\n  so order is not important.\\n*\\n\\n\\nCurrently, there're two problems with this approach:\\n\\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\\nFor the moment of writing, the only possible way is:\\n:host {\\n  :host-context(...) {\\n    ...\\n  }\\n}\\nIt doesn't work for us because mixin could be called somewhere deeper, like:\\n:host {\\n  p {\\n    @include nb-rtl() { ... }\\n  }\\n}\\nWe are not able to go up to :host level to place content passed to mixin.\\n\\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\\n  *\\n    Side note:\\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\\n    :host-context($theme) once we will be able to use multiple shadow selectors.\\n  *\\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\\n  ***\\n    Possible solution\\n    check if we in theme by some theme variables and if so append, otherwise nest like\\n    @at-root :host-context([dir=rtl]) {\\n      // add # to scss interpolation statement.\\n      // it works in comments and we can't use it here\\n      {&} {\\n        @content;\\n      }\\n    }\\n    What if :host specified? Can we add space in :host-context(...) :host?\\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\\n  ***\\n\\n\\nProblems with the current approach.\\n\\n1. Direction can be applied only on document level, because mixin prepends theme class,\\nwhich placed on the body.\\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\\nattribute to [dir=rtl] attribute as well.\\n\\n\\nGeneral problems.\\n\\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\\n*/\\n/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/**\\n * This mixin generates keyfames.\\n * Because of all keyframes can't be scoped,\\n * we need to puts unique name in each btn-pulse call.\\n */\\n/*\\n\\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\\n:host and :host-context are pseudo-classes. So we assume they could be combined,\\nlike other pseudo-classes, even same ones.\\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\\n\\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\\nso direction could be overridden on any component level.\\n\\nImplementation code:\\n\\n@mixin nb-rtl() {\\n  // add # to scss interpolation statement.\\n  // it works in comments and we can't use it here\\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\\n    @content;\\n  }\\n}\\n\\nAnd when we call it somewhere:\\n\\n:host {\\n  .some-class {\\n    @include nb-rtl() {\\n      ...\\n    }\\n  }\\n}\\n:host-context(...) {\\n  .some-class {\\n    @include nb-rtl() {\\n      ...\\n    }\\n  }\\n}\\n\\nResult will look like:\\n\\n:host-context([dir=rtl]):host .some-class {\\n  ...\\n}\\n:host-context([dir=rtl]):host-context(...) .some-class {\\n  ...\\n}\\n\\n*\\n  Side note:\\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\\n\\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\\n  so order is not important.\\n*\\n\\n\\nCurrently, there're two problems with this approach:\\n\\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\\nFor the moment of writing, the only possible way is:\\n:host {\\n  :host-context(...) {\\n    ...\\n  }\\n}\\nIt doesn't work for us because mixin could be called somewhere deeper, like:\\n:host {\\n  p {\\n    @include nb-rtl() { ... }\\n  }\\n}\\nWe are not able to go up to :host level to place content passed to mixin.\\n\\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\\n  *\\n    Side note:\\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\\n    :host-context($theme) once we will be able to use multiple shadow selectors.\\n  *\\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\\n  ***\\n    Possible solution\\n    check if we in theme by some theme variables and if so append, otherwise nest like\\n    @at-root :host-context([dir=rtl]) {\\n      // add # to scss interpolation statement.\\n      // it works in comments and we can't use it here\\n      {&} {\\n        @content;\\n      }\\n    }\\n    What if :host specified? Can we add space in :host-context(...) :host?\\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\\n  ***\\n\\n\\nProblems with the current approach.\\n\\n1. Direction can be applied only on document level, because mixin prepends theme class,\\nwhich placed on the body.\\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\\nattribute to [dir=rtl] attribute as well.\\n\\n\\nGeneral problems.\\n\\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\\n*/\\n/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/**\\n * This mixin generates keyfames.\\n * Because of all keyframes can't be scoped,\\n * we need to puts unique name in each btn-pulse call.\\n */\\n/*\\n\\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\\n:host and :host-context are pseudo-classes. So we assume they could be combined,\\nlike other pseudo-classes, even same ones.\\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\\n\\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\\nso direction could be overridden on any component level.\\n\\nImplementation code:\\n\\n@mixin nb-rtl() {\\n  // add # to scss interpolation statement.\\n  // it works in comments and we can't use it here\\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\\n    @content;\\n  }\\n}\\n\\nAnd when we call it somewhere:\\n\\n:host {\\n  .some-class {\\n    @include nb-rtl() {\\n      ...\\n    }\\n  }\\n}\\n:host-context(...) {\\n  .some-class {\\n    @include nb-rtl() {\\n      ...\\n    }\\n  }\\n}\\n\\nResult will look like:\\n\\n:host-context([dir=rtl]):host .some-class {\\n  ...\\n}\\n:host-context([dir=rtl]):host-context(...) .some-class {\\n  ...\\n}\\n\\n*\\n  Side note:\\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\\n\\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\\n  so order is not important.\\n*\\n\\n\\nCurrently, there're two problems with this approach:\\n\\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\\nFor the moment of writing, the only possible way is:\\n:host {\\n  :host-context(...) {\\n    ...\\n  }\\n}\\nIt doesn't work for us because mixin could be called somewhere deeper, like:\\n:host {\\n  p {\\n    @include nb-rtl() { ... }\\n  }\\n}\\nWe are not able to go up to :host level to place content passed to mixin.\\n\\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\\n  *\\n    Side note:\\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\\n    :host-context($theme) once we will be able to use multiple shadow selectors.\\n  *\\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\\n  ***\\n    Possible solution\\n    check if we in theme by some theme variables and if so append, otherwise nest like\\n    @at-root :host-context([dir=rtl]) {\\n      // add # to scss interpolation statement.\\n      // it works in comments and we can't use it here\\n      {&} {\\n        @content;\\n      }\\n    }\\n    What if :host specified? Can we add space in :host-context(...) :host?\\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\\n  ***\\n\\n\\nProblems with the current approach.\\n\\n1. Direction can be applied only on document level, because mixin prepends theme class,\\nwhich placed on the body.\\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\\nattribute to [dir=rtl] attribute as well.\\n\\n\\nGeneral problems.\\n\\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\\n*/\\n/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/**\\n * This mixin generates keyfames.\\n * Because of all keyframes can't be scoped,\\n * we need to puts unique name in each btn-pulse call.\\n */\\n/*\\n\\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\\n:host and :host-context are pseudo-classes. So we assume they could be combined,\\nlike other pseudo-classes, even same ones.\\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\\n\\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\\nso direction could be overridden on any component level.\\n\\nImplementation code:\\n\\n@mixin nb-rtl() {\\n  // add # to scss interpolation statement.\\n  // it works in comments and we can't use it here\\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\\n    @content;\\n  }\\n}\\n\\nAnd when we call it somewhere:\\n\\n:host {\\n  .some-class {\\n    @include nb-rtl() {\\n      ...\\n    }\\n  }\\n}\\n:host-context(...) {\\n  .some-class {\\n    @include nb-rtl() {\\n      ...\\n    }\\n  }\\n}\\n\\nResult will look like:\\n\\n:host-context([dir=rtl]):host .some-class {\\n  ...\\n}\\n:host-context([dir=rtl]):host-context(...) .some-class {\\n  ...\\n}\\n\\n*\\n  Side note:\\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\\n\\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\\n  so order is not important.\\n*\\n\\n\\nCurrently, there're two problems with this approach:\\n\\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\\nFor the moment of writing, the only possible way is:\\n:host {\\n  :host-context(...) {\\n    ...\\n  }\\n}\\nIt doesn't work for us because mixin could be called somewhere deeper, like:\\n:host {\\n  p {\\n    @include nb-rtl() { ... }\\n  }\\n}\\nWe are not able to go up to :host level to place content passed to mixin.\\n\\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\\n  *\\n    Side note:\\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\\n    :host-context($theme) once we will be able to use multiple shadow selectors.\\n  *\\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\\n  ***\\n    Possible solution\\n    check if we in theme by some theme variables and if so append, otherwise nest like\\n    @at-root :host-context([dir=rtl]) {\\n      // add # to scss interpolation statement.\\n      // it works in comments and we can't use it here\\n      {&} {\\n        @content;\\n      }\\n    }\\n    What if :host specified? Can we add space in :host-context(...) :host?\\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\\n  ***\\n\\n\\nProblems with the current approach.\\n\\n1. Direction can be applied only on document level, because mixin prepends theme class,\\nwhich placed on the body.\\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\\nattribute to [dir=rtl] attribute as well.\\n\\n\\nGeneral problems.\\n\\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\\n*/\\n/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/**\\n * This mixin generates keyfames.\\n * Because of all keyframes can't be scoped,\\n * we need to puts unique name in each btn-pulse call.\\n */\\n/*\\n\\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\\n:host and :host-context are pseudo-classes. So we assume they could be combined,\\nlike other pseudo-classes, even same ones.\\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\\n\\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\\nso direction could be overridden on any component level.\\n\\nImplementation code:\\n\\n@mixin nb-rtl() {\\n  // add # to scss interpolation statement.\\n  // it works in comments and we can't use it here\\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\\n    @content;\\n  }\\n}\\n\\nAnd when we call it somewhere:\\n\\n:host {\\n  .some-class {\\n    @include nb-rtl() {\\n      ...\\n    }\\n  }\\n}\\n:host-context(...) {\\n  .some-class {\\n    @include nb-rtl() {\\n      ...\\n    }\\n  }\\n}\\n\\nResult will look like:\\n\\n:host-context([dir=rtl]):host .some-class {\\n  ...\\n}\\n:host-context([dir=rtl]):host-context(...) .some-class {\\n  ...\\n}\\n\\n*\\n  Side note:\\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\\n\\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\\n  so order is not important.\\n*\\n\\n\\nCurrently, there're two problems with this approach:\\n\\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\\nFor the moment of writing, the only possible way is:\\n:host {\\n  :host-context(...) {\\n    ...\\n  }\\n}\\nIt doesn't work for us because mixin could be called somewhere deeper, like:\\n:host {\\n  p {\\n    @include nb-rtl() { ... }\\n  }\\n}\\nWe are not able to go up to :host level to place content passed to mixin.\\n\\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\\n  *\\n    Side note:\\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\\n    :host-context($theme) once we will be able to use multiple shadow selectors.\\n  *\\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\\n  ***\\n    Possible solution\\n    check if we in theme by some theme variables and if so append, otherwise nest like\\n    @at-root :host-context([dir=rtl]) {\\n      // add # to scss interpolation statement.\\n      // it works in comments and we can't use it here\\n      {&} {\\n        @content;\\n      }\\n    }\\n    What if :host specified? Can we add space in :host-context(...) :host?\\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\\n  ***\\n\\n\\nProblems with the current approach.\\n\\n1. Direction can be applied only on document level, because mixin prepends theme class,\\nwhich placed on the body.\\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\\nattribute to [dir=rtl] attribute as well.\\n\\n\\nGeneral problems.\\n\\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\\n*/\\n/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/**\\n * This mixin generates keyfames.\\n * Because of all keyframes can't be scoped,\\n * we need to puts unique name in each btn-pulse call.\\n */\\n/*\\n\\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\\n:host and :host-context are pseudo-classes. So we assume they could be combined,\\nlike other pseudo-classes, even same ones.\\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\\n\\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\\nso direction could be overridden on any component level.\\n\\nImplementation code:\\n\\n@mixin nb-rtl() {\\n  // add # to scss interpolation statement.\\n  // it works in comments and we can't use it here\\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\\n    @content;\\n  }\\n}\\n\\nAnd when we call it somewhere:\\n\\n:host {\\n  .some-class {\\n    @include nb-rtl() {\\n      ...\\n    }\\n  }\\n}\\n:host-context(...) {\\n  .some-class {\\n    @include nb-rtl() {\\n      ...\\n    }\\n  }\\n}\\n\\nResult will look like:\\n\\n:host-context([dir=rtl]):host .some-class {\\n  ...\\n}\\n:host-context([dir=rtl]):host-context(...) .some-class {\\n  ...\\n}\\n\\n*\\n  Side note:\\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\\n\\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\\n  so order is not important.\\n*\\n\\n\\nCurrently, there're two problems with this approach:\\n\\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\\nFor the moment of writing, the only possible way is:\\n:host {\\n  :host-context(...) {\\n    ...\\n  }\\n}\\nIt doesn't work for us because mixin could be called somewhere deeper, like:\\n:host {\\n  p {\\n    @include nb-rtl() { ... }\\n  }\\n}\\nWe are not able to go up to :host level to place content passed to mixin.\\n\\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\\n  *\\n    Side note:\\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\\n    :host-context($theme) once we will be able to use multiple shadow selectors.\\n  *\\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\\n  ***\\n    Possible solution\\n    check if we in theme by some theme variables and if so append, otherwise nest like\\n    @at-root :host-context([dir=rtl]) {\\n      // add # to scss interpolation statement.\\n      // it works in comments and we can't use it here\\n      {&} {\\n        @content;\\n      }\\n    }\\n    What if :host specified? Can we add space in :host-context(...) :host?\\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\\n  ***\\n\\n\\nProblems with the current approach.\\n\\n1. Direction can be applied only on document level, because mixin prepends theme class,\\nwhich placed on the body.\\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\\nattribute to [dir=rtl] attribute as well.\\n\\n\\nGeneral problems.\\n\\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\\n*/\\n/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/*\\n      :host can be prefixed\\n      https://github.com/angular/angular/blob/8d0ee34939f14c07876d222c25b405ed458a34d3/packages/compiler/src/shadow_css.ts#L441\\n\\n      We have to use :host insted of :host-context($theme), to be able to prefix theme class\\n      with something defined inside of @content, by prefixing &.\\n      For example this scss code:\\n        .nb-theme-default {\\n          .some-selector & {\\n            ...\\n          }\\n        }\\n      Will result in next css:\\n        .some-selector .nb-theme-default {\\n          ...\\n        }\\n\\n      It doesn't work with :host-context because angular splitting it in two selectors and removes\\n      prefix in one of the selectors.\\n    */\\n.nb-theme-default :host .toolbars-container {\\n  display: -webkit-box;\\n  display: -ms-flexbox;\\n  display: flex;\\n  -webkit-box-orient: vertical;\\n  -webkit-box-direction: normal;\\n      -ms-flex-direction: column;\\n          flex-direction: column; }\\n[dir=ltr] .nb-theme-default :host .pagination-container {\\n  margin-right: 1rem; }\\n[dir=rtl] .nb-theme-default :host .pagination-container {\\n  margin-left: 1rem; }\\n.nb-theme-default :host .pagination-container .btn-group > .btn {\\n  padding-left: 1.125rem;\\n  padding-right: 1.125rem; }\\n.nb-theme-default :host .icon-toolbar-container .btn-group > .btn {\\n  padding-left: 1.125rem;\\n  padding-right: 1.125rem; }\\n.nb-theme-default :host .toggle-types .btn-toggle-radio-group {\\n  margin-bottom: 1rem; }\\n.nb-theme-default :host .divided-button-group .btn-divided-checkbox-group {\\n  margin-bottom: 1rem;\\n  -ms-flex-wrap: wrap;\\n      flex-wrap: wrap; }\\n.nb-theme-default :host .example-container:not(:last-child) {\\n  margin-bottom: 1.5rem; }\\n.nb-theme-default :host .example-container > div:not(:last-child) {\\n  margin-bottom: 1rem; }\\n.nb-theme-default :host .example-container > .btn-divided-checkbox-group {\\n  -ms-flex-wrap: wrap;\\n      flex-wrap: wrap; }\\n.nb-theme-default :host .example-container > .btn-divided-checkbox-group > label {\\n    -ms-flex-preferred-size: 10%;\\n        flex-basis: 10%; }\\n[dir=ltr] .nb-theme-default :host .example-container > .btn-divided-checkbox-group > label {\\n      margin: 0 0.25rem 0.5rem 0; }\\n[dir=rtl] .nb-theme-default :host .example-container > .btn-divided-checkbox-group > label {\\n      margin: 0 0 0.5rem 0.25rem; }\\n@media (max-width: 767.98px) {\\n  .nb-theme-default :host .btn {\\n    padding: 0.75rem 0.7rem; } }\\n/*\\n      :host can be prefixed\\n      https://github.com/angular/angular/blob/8d0ee34939f14c07876d222c25b405ed458a34d3/packages/compiler/src/shadow_css.ts#L441\\n\\n      We have to use :host insted of :host-context($theme), to be able to prefix theme class\\n      with something defined inside of @content, by prefixing &.\\n      For example this scss code:\\n        .nb-theme-default {\\n          .some-selector & {\\n            ...\\n          }\\n        }\\n      Will result in next css:\\n        .some-selector .nb-theme-default {\\n          ...\\n        }\\n\\n      It doesn't work with :host-context because angular splitting it in two selectors and removes\\n      prefix in one of the selectors.\\n    */\\n.nb-theme-cosmic :host .toolbars-container {\\n  display: -webkit-box;\\n  display: -ms-flexbox;\\n  display: flex;\\n  -webkit-box-orient: vertical;\\n  -webkit-box-direction: normal;\\n      -ms-flex-direction: column;\\n          flex-direction: column; }\\n[dir=ltr] .nb-theme-cosmic :host .pagination-container {\\n  margin-right: 1rem; }\\n[dir=rtl] .nb-theme-cosmic :host .pagination-container {\\n  margin-left: 1rem; }\\n.nb-theme-cosmic :host .pagination-container .btn-group > .btn {\\n  padding-left: 1.125rem;\\n  padding-right: 1.125rem; }\\n.nb-theme-cosmic :host .icon-toolbar-container .btn-group > .btn {\\n  padding-left: 1.125rem;\\n  padding-right: 1.125rem; }\\n.nb-theme-cosmic :host .toggle-types .btn-toggle-radio-group {\\n  margin-bottom: 1rem; }\\n.nb-theme-cosmic :host .divided-button-group .btn-divided-checkbox-group {\\n  margin-bottom: 1rem;\\n  -ms-flex-wrap: wrap;\\n      flex-wrap: wrap; }\\n.nb-theme-cosmic :host .example-container:not(:last-child) {\\n  margin-bottom: 1.5rem; }\\n.nb-theme-cosmic :host .example-container > div:not(:last-child) {\\n  margin-bottom: 1rem; }\\n.nb-theme-cosmic :host .example-container > .btn-divided-checkbox-group {\\n  -ms-flex-wrap: wrap;\\n      flex-wrap: wrap; }\\n.nb-theme-cosmic :host .example-container > .btn-divided-checkbox-group > label {\\n    -ms-flex-preferred-size: 10%;\\n        flex-basis: 10%; }\\n[dir=ltr] .nb-theme-cosmic :host .example-container > .btn-divided-checkbox-group > label {\\n      margin: 0 0.25rem 0.5rem 0; }\\n[dir=rtl] .nb-theme-cosmic :host .example-container > .btn-divided-checkbox-group > label {\\n      margin: 0 0 0.5rem 0.25rem; }\\n@media (max-width: 767.98px) {\\n  .nb-theme-cosmic :host .btn {\\n    padding: 0.75rem 0.7rem; } }\\n/*\\n      :host can be prefixed\\n      https://github.com/angular/angular/blob/8d0ee34939f14c07876d222c25b405ed458a34d3/packages/compiler/src/shadow_css.ts#L441\\n\\n      We have to use :host insted of :host-context($theme), to be able to prefix theme class\\n      with something defined inside of @content, by prefixing &.\\n      For example this scss code:\\n        .nb-theme-default {\\n          .some-selector & {\\n            ...\\n          }\\n        }\\n      Will result in next css:\\n        .some-selector .nb-theme-default {\\n          ...\\n        }\\n\\n      It doesn't work with :host-context because angular splitting it in two selectors and removes\\n      prefix in one of the selectors.\\n    */\\n.nb-theme-corporate :host .toolbars-container {\\n  display: -webkit-box;\\n  display: -ms-flexbox;\\n  display: flex;\\n  -webkit-box-orient: vertical;\\n  -webkit-box-direction: normal;\\n      -ms-flex-direction: column;\\n          flex-direction: column; }\\n[dir=ltr] .nb-theme-corporate :host .pagination-container {\\n  margin-right: 1rem; }\\n[dir=rtl] .nb-theme-corporate :host .pagination-container {\\n  margin-left: 1rem; }\\n.nb-theme-corporate :host .pagination-container .btn-group > .btn {\\n  padding-left: 1.125rem;\\n  padding-right: 1.125rem; }\\n.nb-theme-corporate :host .icon-toolbar-container .btn-group > .btn {\\n  padding-left: 1.125rem;\\n  padding-right: 1.125rem; }\\n.nb-theme-corporate :host .toggle-types .btn-toggle-radio-group {\\n  margin-bottom: 1rem; }\\n.nb-theme-corporate :host .divided-button-group .btn-divided-checkbox-group {\\n  margin-bottom: 1rem;\\n  -ms-flex-wrap: wrap;\\n      flex-wrap: wrap; }\\n.nb-theme-corporate :host .example-container:not(:last-child) {\\n  margin-bottom: 1.5rem; }\\n.nb-theme-corporate :host .example-container > div:not(:last-child) {\\n  margin-bottom: 1rem; }\\n.nb-theme-corporate :host .example-container > .btn-divided-checkbox-group {\\n  -ms-flex-wrap: wrap;\\n      flex-wrap: wrap; }\\n.nb-theme-corporate :host .example-container > .btn-divided-checkbox-group > label {\\n    -ms-flex-preferred-size: 10%;\\n        flex-basis: 10%; }\\n[dir=ltr] .nb-theme-corporate :host .example-container > .btn-divided-checkbox-group > label {\\n      margin: 0 0.25rem 0.5rem 0; }\\n[dir=rtl] .nb-theme-corporate :host .example-container > .btn-divided-checkbox-group > label {\\n      margin: 0 0 0.5rem 0.25rem; }\\n@media (max-width: 767.98px) {\\n  .nb-theme-corporate :host .btn {\\n    padding: 0.75rem 0.7rem; } }\\n\"","module.exports = \"/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/**\\n * This is a starting point where we declare the maps of themes and globally available functions/mixins\\n */\\n/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/**\\n * This mixin generates keyfames.\\n * Because of all keyframes can't be scoped,\\n * we need to puts unique name in each btn-pulse call.\\n */\\n/*\\n\\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\\n:host and :host-context are pseudo-classes. So we assume they could be combined,\\nlike other pseudo-classes, even same ones.\\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\\n\\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\\nso direction could be overridden on any component level.\\n\\nImplementation code:\\n\\n@mixin nb-rtl() {\\n  // add # to scss interpolation statement.\\n  // it works in comments and we can't use it here\\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\\n    @content;\\n  }\\n}\\n\\nAnd when we call it somewhere:\\n\\n:host {\\n  .some-class {\\n    @include nb-rtl() {\\n      ...\\n    }\\n  }\\n}\\n:host-context(...) {\\n  .some-class {\\n    @include nb-rtl() {\\n      ...\\n    }\\n  }\\n}\\n\\nResult will look like:\\n\\n:host-context([dir=rtl]):host .some-class {\\n  ...\\n}\\n:host-context([dir=rtl]):host-context(...) .some-class {\\n  ...\\n}\\n\\n*\\n  Side note:\\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\\n\\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\\n  so order is not important.\\n*\\n\\n\\nCurrently, there're two problems with this approach:\\n\\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\\nFor the moment of writing, the only possible way is:\\n:host {\\n  :host-context(...) {\\n    ...\\n  }\\n}\\nIt doesn't work for us because mixin could be called somewhere deeper, like:\\n:host {\\n  p {\\n    @include nb-rtl() { ... }\\n  }\\n}\\nWe are not able to go up to :host level to place content passed to mixin.\\n\\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\\n  *\\n    Side note:\\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\\n    :host-context($theme) once we will be able to use multiple shadow selectors.\\n  *\\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\\n  ***\\n    Possible solution\\n    check if we in theme by some theme variables and if so append, otherwise nest like\\n    @at-root :host-context([dir=rtl]) {\\n      // add # to scss interpolation statement.\\n      // it works in comments and we can't use it here\\n      {&} {\\n        @content;\\n      }\\n    }\\n    What if :host specified? Can we add space in :host-context(...) :host?\\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\\n  ***\\n\\n\\nProblems with the current approach.\\n\\n1. Direction can be applied only on document level, because mixin prepends theme class,\\nwhich placed on the body.\\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\\nattribute to [dir=rtl] attribute as well.\\n\\n\\nGeneral problems.\\n\\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\\n*/\\n/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/**\\n * This mixin generates keyfames.\\n * Because of all keyframes can't be scoped,\\n * we need to puts unique name in each btn-pulse call.\\n */\\n/*\\n\\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\\n:host and :host-context are pseudo-classes. So we assume they could be combined,\\nlike other pseudo-classes, even same ones.\\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\\n\\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\\nso direction could be overridden on any component level.\\n\\nImplementation code:\\n\\n@mixin nb-rtl() {\\n  // add # to scss interpolation statement.\\n  // it works in comments and we can't use it here\\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\\n    @content;\\n  }\\n}\\n\\nAnd when we call it somewhere:\\n\\n:host {\\n  .some-class {\\n    @include nb-rtl() {\\n      ...\\n    }\\n  }\\n}\\n:host-context(...) {\\n  .some-class {\\n    @include nb-rtl() {\\n      ...\\n    }\\n  }\\n}\\n\\nResult will look like:\\n\\n:host-context([dir=rtl]):host .some-class {\\n  ...\\n}\\n:host-context([dir=rtl]):host-context(...) .some-class {\\n  ...\\n}\\n\\n*\\n  Side note:\\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\\n\\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\\n  so order is not important.\\n*\\n\\n\\nCurrently, there're two problems with this approach:\\n\\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\\nFor the moment of writing, the only possible way is:\\n:host {\\n  :host-context(...) {\\n    ...\\n  }\\n}\\nIt doesn't work for us because mixin could be called somewhere deeper, like:\\n:host {\\n  p {\\n    @include nb-rtl() { ... }\\n  }\\n}\\nWe are not able to go up to :host level to place content passed to mixin.\\n\\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\\n  *\\n    Side note:\\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\\n    :host-context($theme) once we will be able to use multiple shadow selectors.\\n  *\\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\\n  ***\\n    Possible solution\\n    check if we in theme by some theme variables and if so append, otherwise nest like\\n    @at-root :host-context([dir=rtl]) {\\n      // add # to scss interpolation statement.\\n      // it works in comments and we can't use it here\\n      {&} {\\n        @content;\\n      }\\n    }\\n    What if :host specified? Can we add space in :host-context(...) :host?\\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\\n  ***\\n\\n\\nProblems with the current approach.\\n\\n1. Direction can be applied only on document level, because mixin prepends theme class,\\nwhich placed on the body.\\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\\nattribute to [dir=rtl] attribute as well.\\n\\n\\nGeneral problems.\\n\\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\\n*/\\n/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/**\\n * This mixin generates keyfames.\\n * Because of all keyframes can't be scoped,\\n * we need to puts unique name in each btn-pulse call.\\n */\\n/*\\n\\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\\n:host and :host-context are pseudo-classes. So we assume they could be combined,\\nlike other pseudo-classes, even same ones.\\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\\n\\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\\nso direction could be overridden on any component level.\\n\\nImplementation code:\\n\\n@mixin nb-rtl() {\\n  // add # to scss interpolation statement.\\n  // it works in comments and we can't use it here\\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\\n    @content;\\n  }\\n}\\n\\nAnd when we call it somewhere:\\n\\n:host {\\n  .some-class {\\n    @include nb-rtl() {\\n      ...\\n    }\\n  }\\n}\\n:host-context(...) {\\n  .some-class {\\n    @include nb-rtl() {\\n      ...\\n    }\\n  }\\n}\\n\\nResult will look like:\\n\\n:host-context([dir=rtl]):host .some-class {\\n  ...\\n}\\n:host-context([dir=rtl]):host-context(...) .some-class {\\n  ...\\n}\\n\\n*\\n  Side note:\\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\\n\\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\\n  so order is not important.\\n*\\n\\n\\nCurrently, there're two problems with this approach:\\n\\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\\nFor the moment of writing, the only possible way is:\\n:host {\\n  :host-context(...) {\\n    ...\\n  }\\n}\\nIt doesn't work for us because mixin could be called somewhere deeper, like:\\n:host {\\n  p {\\n    @include nb-rtl() { ... }\\n  }\\n}\\nWe are not able to go up to :host level to place content passed to mixin.\\n\\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\\n  *\\n    Side note:\\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\\n    :host-context($theme) once we will be able to use multiple shadow selectors.\\n  *\\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\\n  ***\\n    Possible solution\\n    check if we in theme by some theme variables and if so append, otherwise nest like\\n    @at-root :host-context([dir=rtl]) {\\n      // add # to scss interpolation statement.\\n      // it works in comments and we can't use it here\\n      {&} {\\n        @content;\\n      }\\n    }\\n    What if :host specified? Can we add space in :host-context(...) :host?\\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\\n  ***\\n\\n\\nProblems with the current approach.\\n\\n1. Direction can be applied only on document level, because mixin prepends theme class,\\nwhich placed on the body.\\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\\nattribute to [dir=rtl] attribute as well.\\n\\n\\nGeneral problems.\\n\\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\\n*/\\n/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/**\\n * This mixin generates keyfames.\\n * Because of all keyframes can't be scoped,\\n * we need to puts unique name in each btn-pulse call.\\n */\\n/*\\n\\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\\n:host and :host-context are pseudo-classes. So we assume they could be combined,\\nlike other pseudo-classes, even same ones.\\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\\n\\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\\nso direction could be overridden on any component level.\\n\\nImplementation code:\\n\\n@mixin nb-rtl() {\\n  // add # to scss interpolation statement.\\n  // it works in comments and we can't use it here\\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\\n    @content;\\n  }\\n}\\n\\nAnd when we call it somewhere:\\n\\n:host {\\n  .some-class {\\n    @include nb-rtl() {\\n      ...\\n    }\\n  }\\n}\\n:host-context(...) {\\n  .some-class {\\n    @include nb-rtl() {\\n      ...\\n    }\\n  }\\n}\\n\\nResult will look like:\\n\\n:host-context([dir=rtl]):host .some-class {\\n  ...\\n}\\n:host-context([dir=rtl]):host-context(...) .some-class {\\n  ...\\n}\\n\\n*\\n  Side note:\\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\\n\\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\\n  so order is not important.\\n*\\n\\n\\nCurrently, there're two problems with this approach:\\n\\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\\nFor the moment of writing, the only possible way is:\\n:host {\\n  :host-context(...) {\\n    ...\\n  }\\n}\\nIt doesn't work for us because mixin could be called somewhere deeper, like:\\n:host {\\n  p {\\n    @include nb-rtl() { ... }\\n  }\\n}\\nWe are not able to go up to :host level to place content passed to mixin.\\n\\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\\n  *\\n    Side note:\\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\\n    :host-context($theme) once we will be able to use multiple shadow selectors.\\n  *\\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\\n  ***\\n    Possible solution\\n    check if we in theme by some theme variables and if so append, otherwise nest like\\n    @at-root :host-context([dir=rtl]) {\\n      // add # to scss interpolation statement.\\n      // it works in comments and we can't use it here\\n      {&} {\\n        @content;\\n      }\\n    }\\n    What if :host specified? Can we add space in :host-context(...) :host?\\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\\n  ***\\n\\n\\nProblems with the current approach.\\n\\n1. Direction can be applied only on document level, because mixin prepends theme class,\\nwhich placed on the body.\\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\\nattribute to [dir=rtl] attribute as well.\\n\\n\\nGeneral problems.\\n\\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\\n*/\\n/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/**\\n * This mixin generates keyfames.\\n * Because of all keyframes can't be scoped,\\n * we need to puts unique name in each btn-pulse call.\\n */\\n/*\\n\\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\\n:host and :host-context are pseudo-classes. So we assume they could be combined,\\nlike other pseudo-classes, even same ones.\\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\\n\\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\\nso direction could be overridden on any component level.\\n\\nImplementation code:\\n\\n@mixin nb-rtl() {\\n  // add # to scss interpolation statement.\\n  // it works in comments and we can't use it here\\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\\n    @content;\\n  }\\n}\\n\\nAnd when we call it somewhere:\\n\\n:host {\\n  .some-class {\\n    @include nb-rtl() {\\n      ...\\n    }\\n  }\\n}\\n:host-context(...) {\\n  .some-class {\\n    @include nb-rtl() {\\n      ...\\n    }\\n  }\\n}\\n\\nResult will look like:\\n\\n:host-context([dir=rtl]):host .some-class {\\n  ...\\n}\\n:host-context([dir=rtl]):host-context(...) .some-class {\\n  ...\\n}\\n\\n*\\n  Side note:\\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\\n\\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\\n  so order is not important.\\n*\\n\\n\\nCurrently, there're two problems with this approach:\\n\\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\\nFor the moment of writing, the only possible way is:\\n:host {\\n  :host-context(...) {\\n    ...\\n  }\\n}\\nIt doesn't work for us because mixin could be called somewhere deeper, like:\\n:host {\\n  p {\\n    @include nb-rtl() { ... }\\n  }\\n}\\nWe are not able to go up to :host level to place content passed to mixin.\\n\\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\\n  *\\n    Side note:\\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\\n    :host-context($theme) once we will be able to use multiple shadow selectors.\\n  *\\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\\n  ***\\n    Possible solution\\n    check if we in theme by some theme variables and if so append, otherwise nest like\\n    @at-root :host-context([dir=rtl]) {\\n      // add # to scss interpolation statement.\\n      // it works in comments and we can't use it here\\n      {&} {\\n        @content;\\n      }\\n    }\\n    What if :host specified? Can we add space in :host-context(...) :host?\\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\\n  ***\\n\\n\\nProblems with the current approach.\\n\\n1. Direction can be applied only on document level, because mixin prepends theme class,\\nwhich placed on the body.\\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\\nattribute to [dir=rtl] attribute as well.\\n\\n\\nGeneral problems.\\n\\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\\n*/\\n/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/**\\n * This mixin generates keyfames.\\n * Because of all keyframes can't be scoped,\\n * we need to puts unique name in each btn-pulse call.\\n */\\n/*\\n\\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\\n:host and :host-context are pseudo-classes. So we assume they could be combined,\\nlike other pseudo-classes, even same ones.\\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\\n\\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\\nso direction could be overridden on any component level.\\n\\nImplementation code:\\n\\n@mixin nb-rtl() {\\n  // add # to scss interpolation statement.\\n  // it works in comments and we can't use it here\\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\\n    @content;\\n  }\\n}\\n\\nAnd when we call it somewhere:\\n\\n:host {\\n  .some-class {\\n    @include nb-rtl() {\\n      ...\\n    }\\n  }\\n}\\n:host-context(...) {\\n  .some-class {\\n    @include nb-rtl() {\\n      ...\\n    }\\n  }\\n}\\n\\nResult will look like:\\n\\n:host-context([dir=rtl]):host .some-class {\\n  ...\\n}\\n:host-context([dir=rtl]):host-context(...) .some-class {\\n  ...\\n}\\n\\n*\\n  Side note:\\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\\n\\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\\n  so order is not important.\\n*\\n\\n\\nCurrently, there're two problems with this approach:\\n\\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\\nFor the moment of writing, the only possible way is:\\n:host {\\n  :host-context(...) {\\n    ...\\n  }\\n}\\nIt doesn't work for us because mixin could be called somewhere deeper, like:\\n:host {\\n  p {\\n    @include nb-rtl() { ... }\\n  }\\n}\\nWe are not able to go up to :host level to place content passed to mixin.\\n\\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\\n  *\\n    Side note:\\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\\n    :host-context($theme) once we will be able to use multiple shadow selectors.\\n  *\\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\\n  ***\\n    Possible solution\\n    check if we in theme by some theme variables and if so append, otherwise nest like\\n    @at-root :host-context([dir=rtl]) {\\n      // add # to scss interpolation statement.\\n      // it works in comments and we can't use it here\\n      {&} {\\n        @content;\\n      }\\n    }\\n    What if :host specified? Can we add space in :host-context(...) :host?\\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\\n  ***\\n\\n\\nProblems with the current approach.\\n\\n1. Direction can be applied only on document level, because mixin prepends theme class,\\nwhich placed on the body.\\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\\nattribute to [dir=rtl] attribute as well.\\n\\n\\nGeneral problems.\\n\\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\\n*/\\n/*\\n      :host can be prefixed\\n      https://github.com/angular/angular/blob/8d0ee34939f14c07876d222c25b405ed458a34d3/packages/compiler/src/shadow_css.ts#L441\\n\\n      We have to use :host insted of :host-context($theme), to be able to prefix theme class\\n      with something defined inside of @content, by prefixing &.\\n      For example this scss code:\\n        .nb-theme-default {\\n          .some-selector & {\\n            ...\\n          }\\n        }\\n      Will result in next css:\\n        .some-selector .nb-theme-default {\\n          ...\\n        }\\n\\n      It doesn't work with :host-context because angular splitting it in two selectors and removes\\n      prefix in one of the selectors.\\n    */\\n.nb-theme-default :host .font-secondary .font-header .name {\\n  font-size: 4.5rem;\\n  line-height: 4rem;\\n  font-weight: 600; }\\n.nb-theme-default :host .font-main .font-header .name {\\n  font-size: 3rem;\\n  font-weight: 600; }\\n.nb-theme-default :host .font-row:first-child {\\n  margin-bottom: 2rem; }\\n.nb-theme-default :host .font-row .header {\\n  -webkit-box-align: baseline;\\n      -ms-flex-align: baseline;\\n          align-items: baseline; }\\n.nb-theme-default :host .font-row p {\\n  margin: 0; }\\n.nb-theme-default :host .headings-card nb-card-body {\\n  padding: 1rem 1.25rem; }\\n.nb-theme-default :host .headings-card .header {\\n  padding-bottom: 0.675rem;\\n  margin-bottom: 0.675rem; }\\n.nb-theme-default :host .headings-card .header:last-child {\\n    padding-bottom: 0;\\n    margin-bottom: 0; }\\n.nb-theme-default :host .header {\\n  display: -webkit-box;\\n  display: -ms-flexbox;\\n  display: flex;\\n  -ms-flex-wrap: wrap;\\n      flex-wrap: wrap;\\n  -webkit-box-align: center;\\n      -ms-flex-align: center;\\n          align-items: center;\\n  padding-bottom: 1rem;\\n  margin-bottom: 1rem;\\n  border-bottom: 1px solid #ebeef2;\\n  color: #2a2a2a; }\\n.nb-theme-default :host .header:last-child {\\n    border-bottom: none;\\n    padding: 0;\\n    margin: 0; }\\n.nb-theme-default :host .header div:first-child {\\n    -webkit-box-flex: 2;\\n            flex: 2;\\n    -ms-flex: 2 1 auto;\\n    line-height: 1;\\n    -webkit-box-align: end;\\n        -ms-flex-align: end;\\n            align-items: flex-end; }\\n.nb-theme-default :host .header div:first-child h1,\\n    .nb-theme-default :host .header div:first-child h2,\\n    .nb-theme-default :host .header div:first-child h3,\\n    .nb-theme-default :host .header div:first-child h4,\\n    .nb-theme-default :host .header div:first-child h5,\\n    .nb-theme-default :host .header div:first-child h6 {\\n      margin-bottom: 0; }\\n.nb-theme-default :host .header .variants {\\n    -webkit-box-flex: 1;\\n            flex: 1;\\n    -ms-flex: 1 1 auto;\\n    display: -webkit-box;\\n    display: -ms-flexbox;\\n    display: flex;\\n    -webkit-box-pack: justify;\\n        -ms-flex-pack: justify;\\n            justify-content: space-between;\\n    -webkit-box-align: end;\\n        -ms-flex-align: end;\\n            align-items: flex-end; }\\n.nb-theme-default :host .header .variants span {\\n      padding-right: 1rem;\\n      padding-left: 1rem;\\n      font-size: 1.5rem; }\\n.nb-theme-default :host .header .detail {\\n    -webkit-box-flex: 1;\\n        -ms-flex: 1;\\n            flex: 1;\\n    display: -webkit-box;\\n    display: -ms-flexbox;\\n    display: flex;\\n    -webkit-box-pack: end;\\n        -ms-flex-pack: end;\\n            justify-content: flex-end;\\n    -webkit-box-align: end;\\n        -ms-flex-align: end;\\n            align-items: flex-end;\\n    color: #a4abb3; }\\n.nb-theme-default :host .colors {\\n  display: -webkit-box;\\n  display: -ms-flexbox;\\n  display: flex;\\n  -webkit-box-orient: vertical;\\n  -webkit-box-direction: normal;\\n      -ms-flex-direction: column;\\n          flex-direction: column; }\\n.nb-theme-default :host .colors .item {\\n    display: -webkit-box;\\n    display: -ms-flexbox;\\n    display: flex;\\n    -webkit-box-align: center;\\n        -ms-flex-align: center;\\n            align-items: center;\\n    margin-bottom: 1.25rem; }\\n.nb-theme-default :host .colors .item:last-child {\\n      margin-bottom: 0; }\\n.nb-theme-default :host .colors .color {\\n    width: 86px;\\n    height: 60px;\\n    border-top-right-radius: 1rem;\\n    border-bottom-left-radius: 1rem; }\\n[dir=ltr] .nb-theme-default :host .colors .color {\\n      margin-right: 1rem; }\\n[dir=rtl] .nb-theme-default :host .colors .color {\\n      margin-left: 1rem; }\\n.nb-theme-default :host .colors h1,\\n  .nb-theme-default :host .colors h2,\\n  .nb-theme-default :host .colors h3,\\n  .nb-theme-default :host .colors h4,\\n  .nb-theme-default :host .colors h5,\\n  .nb-theme-default :host .colors h6 {\\n    margin-bottom: 0.25rem; }\\n.nb-theme-default :host .text-link {\\n  color: #3dcc6d; }\\n.nb-theme-default :host .bg-link {\\n  background: #3dcc6d; }\\n/*\\n      :host can be prefixed\\n      https://github.com/angular/angular/blob/8d0ee34939f14c07876d222c25b405ed458a34d3/packages/compiler/src/shadow_css.ts#L441\\n\\n      We have to use :host insted of :host-context($theme), to be able to prefix theme class\\n      with something defined inside of @content, by prefixing &.\\n      For example this scss code:\\n        .nb-theme-default {\\n          .some-selector & {\\n            ...\\n          }\\n        }\\n      Will result in next css:\\n        .some-selector .nb-theme-default {\\n          ...\\n        }\\n\\n      It doesn't work with :host-context because angular splitting it in two selectors and removes\\n      prefix in one of the selectors.\\n    */\\n.nb-theme-cosmic :host .font-secondary .font-header .name {\\n  font-size: 4.5rem;\\n  line-height: 4rem;\\n  font-weight: 600; }\\n.nb-theme-cosmic :host .font-main .font-header .name {\\n  font-size: 3rem;\\n  font-weight: 600; }\\n.nb-theme-cosmic :host .font-row:first-child {\\n  margin-bottom: 2rem; }\\n.nb-theme-cosmic :host .font-row .header {\\n  -webkit-box-align: baseline;\\n      -ms-flex-align: baseline;\\n          align-items: baseline; }\\n.nb-theme-cosmic :host .font-row p {\\n  margin: 0; }\\n.nb-theme-cosmic :host .headings-card nb-card-body {\\n  padding: 1rem 1.25rem; }\\n.nb-theme-cosmic :host .headings-card .header {\\n  padding-bottom: 0.675rem;\\n  margin-bottom: 0.675rem; }\\n.nb-theme-cosmic :host .headings-card .header:last-child {\\n    padding-bottom: 0;\\n    margin-bottom: 0; }\\n.nb-theme-cosmic :host .header {\\n  display: -webkit-box;\\n  display: -ms-flexbox;\\n  display: flex;\\n  -ms-flex-wrap: wrap;\\n      flex-wrap: wrap;\\n  -webkit-box-align: center;\\n      -ms-flex-align: center;\\n          align-items: center;\\n  padding-bottom: 1rem;\\n  margin-bottom: 1rem;\\n  border-bottom: 1px solid #342e73;\\n  color: #ffffff; }\\n.nb-theme-cosmic :host .header:last-child {\\n    border-bottom: none;\\n    padding: 0;\\n    margin: 0; }\\n.nb-theme-cosmic :host .header div:first-child {\\n    -webkit-box-flex: 2;\\n            flex: 2;\\n    -ms-flex: 2 1 auto;\\n    line-height: 1;\\n    -webkit-box-align: end;\\n        -ms-flex-align: end;\\n            align-items: flex-end; }\\n.nb-theme-cosmic :host .header div:first-child h1,\\n    .nb-theme-cosmic :host .header div:first-child h2,\\n    .nb-theme-cosmic :host .header div:first-child h3,\\n    .nb-theme-cosmic :host .header div:first-child h4,\\n    .nb-theme-cosmic :host .header div:first-child h5,\\n    .nb-theme-cosmic :host .header div:first-child h6 {\\n      margin-bottom: 0; }\\n.nb-theme-cosmic :host .header .variants {\\n    -webkit-box-flex: 1;\\n            flex: 1;\\n    -ms-flex: 1 1 auto;\\n    display: -webkit-box;\\n    display: -ms-flexbox;\\n    display: flex;\\n    -webkit-box-pack: justify;\\n        -ms-flex-pack: justify;\\n            justify-content: space-between;\\n    -webkit-box-align: end;\\n        -ms-flex-align: end;\\n            align-items: flex-end; }\\n.nb-theme-cosmic :host .header .variants span {\\n      padding-right: 1rem;\\n      padding-left: 1rem;\\n      font-size: 1.5rem; }\\n.nb-theme-cosmic :host .header .detail {\\n    -webkit-box-flex: 1;\\n        -ms-flex: 1;\\n            flex: 1;\\n    display: -webkit-box;\\n    display: -ms-flexbox;\\n    display: flex;\\n    -webkit-box-pack: end;\\n        -ms-flex-pack: end;\\n            justify-content: flex-end;\\n    -webkit-box-align: end;\\n        -ms-flex-align: end;\\n            align-items: flex-end;\\n    color: #a1a1e5; }\\n.nb-theme-cosmic :host .colors {\\n  display: -webkit-box;\\n  display: -ms-flexbox;\\n  display: flex;\\n  -webkit-box-orient: vertical;\\n  -webkit-box-direction: normal;\\n      -ms-flex-direction: column;\\n          flex-direction: column; }\\n.nb-theme-cosmic :host .colors .item {\\n    display: -webkit-box;\\n    display: -ms-flexbox;\\n    display: flex;\\n    -webkit-box-align: center;\\n        -ms-flex-align: center;\\n            align-items: center;\\n    margin-bottom: 1.25rem; }\\n.nb-theme-cosmic :host .colors .item:last-child {\\n      margin-bottom: 0; }\\n.nb-theme-cosmic :host .colors .color {\\n    width: 86px;\\n    height: 60px;\\n    border-top-right-radius: 1rem;\\n    border-bottom-left-radius: 1rem; }\\n[dir=ltr] .nb-theme-cosmic :host .colors .color {\\n      margin-right: 1rem; }\\n[dir=rtl] .nb-theme-cosmic :host .colors .color {\\n      margin-left: 1rem; }\\n.nb-theme-cosmic :host .colors h1,\\n  .nb-theme-cosmic :host .colors h2,\\n  .nb-theme-cosmic :host .colors h3,\\n  .nb-theme-cosmic :host .colors h4,\\n  .nb-theme-cosmic :host .colors h5,\\n  .nb-theme-cosmic :host .colors h6 {\\n    margin-bottom: 0.25rem; }\\n.nb-theme-cosmic :host .text-link {\\n  color: #00f9a6; }\\n.nb-theme-cosmic :host .bg-link {\\n  background: #00f9a6; }\\n/*\\n      :host can be prefixed\\n      https://github.com/angular/angular/blob/8d0ee34939f14c07876d222c25b405ed458a34d3/packages/compiler/src/shadow_css.ts#L441\\n\\n      We have to use :host insted of :host-context($theme), to be able to prefix theme class\\n      with something defined inside of @content, by prefixing &.\\n      For example this scss code:\\n        .nb-theme-default {\\n          .some-selector & {\\n            ...\\n          }\\n        }\\n      Will result in next css:\\n        .some-selector .nb-theme-default {\\n          ...\\n        }\\n\\n      It doesn't work with :host-context because angular splitting it in two selectors and removes\\n      prefix in one of the selectors.\\n    */\\n.nb-theme-corporate :host .font-secondary .font-header .name {\\n  font-size: 4.5rem;\\n  line-height: 4rem;\\n  font-weight: 600; }\\n.nb-theme-corporate :host .font-main .font-header .name {\\n  font-size: 3rem;\\n  font-weight: 600; }\\n.nb-theme-corporate :host .font-row:first-child {\\n  margin-bottom: 2rem; }\\n.nb-theme-corporate :host .font-row .header {\\n  -webkit-box-align: baseline;\\n      -ms-flex-align: baseline;\\n          align-items: baseline; }\\n.nb-theme-corporate :host .font-row p {\\n  margin: 0; }\\n.nb-theme-corporate :host .headings-card nb-card-body {\\n  padding: 1rem 1.25rem; }\\n.nb-theme-corporate :host .headings-card .header {\\n  padding-bottom: 0.675rem;\\n  margin-bottom: 0.675rem; }\\n.nb-theme-corporate :host .headings-card .header:last-child {\\n    padding-bottom: 0;\\n    margin-bottom: 0; }\\n.nb-theme-corporate :host .header {\\n  display: -webkit-box;\\n  display: -ms-flexbox;\\n  display: flex;\\n  -ms-flex-wrap: wrap;\\n      flex-wrap: wrap;\\n  -webkit-box-align: center;\\n      -ms-flex-align: center;\\n          align-items: center;\\n  padding-bottom: 1rem;\\n  margin-bottom: 1rem;\\n  border-bottom: 1px solid #cdd5dc;\\n  color: #181818; }\\n.nb-theme-corporate :host .header:last-child {\\n    border-bottom: none;\\n    padding: 0;\\n    margin: 0; }\\n.nb-theme-corporate :host .header div:first-child {\\n    -webkit-box-flex: 2;\\n            flex: 2;\\n    -ms-flex: 2 1 auto;\\n    line-height: 1;\\n    -webkit-box-align: end;\\n        -ms-flex-align: end;\\n            align-items: flex-end; }\\n.nb-theme-corporate :host .header div:first-child h1,\\n    .nb-theme-corporate :host .header div:first-child h2,\\n    .nb-theme-corporate :host .header div:first-child h3,\\n    .nb-theme-corporate :host .header div:first-child h4,\\n    .nb-theme-corporate :host .header div:first-child h5,\\n    .nb-theme-corporate :host .header div:first-child h6 {\\n      margin-bottom: 0; }\\n.nb-theme-corporate :host .header .variants {\\n    -webkit-box-flex: 1;\\n            flex: 1;\\n    -ms-flex: 1 1 auto;\\n    display: -webkit-box;\\n    display: -ms-flexbox;\\n    display: flex;\\n    -webkit-box-pack: justify;\\n        -ms-flex-pack: justify;\\n            justify-content: space-between;\\n    -webkit-box-align: end;\\n        -ms-flex-align: end;\\n            align-items: flex-end; }\\n.nb-theme-corporate :host .header .variants span {\\n      padding-right: 1rem;\\n      padding-left: 1rem;\\n      font-size: 1.5rem; }\\n.nb-theme-corporate :host .header .detail {\\n    -webkit-box-flex: 1;\\n        -ms-flex: 1;\\n            flex: 1;\\n    display: -webkit-box;\\n    display: -ms-flexbox;\\n    display: flex;\\n    -webkit-box-pack: end;\\n        -ms-flex-pack: end;\\n            justify-content: flex-end;\\n    -webkit-box-align: end;\\n        -ms-flex-align: end;\\n            align-items: flex-end;\\n    color: #a4abb3; }\\n.nb-theme-corporate :host .colors {\\n  display: -webkit-box;\\n  display: -ms-flexbox;\\n  display: flex;\\n  -webkit-box-orient: vertical;\\n  -webkit-box-direction: normal;\\n      -ms-flex-direction: column;\\n          flex-direction: column; }\\n.nb-theme-corporate :host .colors .item {\\n    display: -webkit-box;\\n    display: -ms-flexbox;\\n    display: flex;\\n    -webkit-box-align: center;\\n        -ms-flex-align: center;\\n            align-items: center;\\n    margin-bottom: 1.25rem; }\\n.nb-theme-corporate :host .colors .item:last-child {\\n      margin-bottom: 0; }\\n.nb-theme-corporate :host .colors .color {\\n    width: 86px;\\n    height: 60px;\\n    border-top-right-radius: 1rem;\\n    border-bottom-left-radius: 1rem; }\\n[dir=ltr] .nb-theme-corporate :host .colors .color {\\n      margin-right: 1rem; }\\n[dir=rtl] .nb-theme-corporate :host .colors .color {\\n      margin-left: 1rem; }\\n.nb-theme-corporate :host .colors h1,\\n  .nb-theme-corporate :host .colors h2,\\n  .nb-theme-corporate :host .colors h3,\\n  .nb-theme-corporate :host .colors h4,\\n  .nb-theme-corporate :host .colors h5,\\n  .nb-theme-corporate :host .colors h6 {\\n    margin-bottom: 0.25rem; }\\n.nb-theme-corporate :host .text-link {\\n  color: #5dcfe3; }\\n.nb-theme-corporate :host .bg-link {\\n  background: #5dcfe3; }\\n\"","module.exports = \"<nb-card>\\n  <nb-card-body>\\n    <div class=\\\"action-groups-header\\\">\\n      Action Groups\\n    </div>\\n    <nb-actions size=\\\"medium\\\">\\n      <nb-action icon=\\\"nb-menu\\\"></nb-action>\\n      <nb-action icon=\\\"nb-search\\\"></nb-action>\\n      <nb-action icon=\\\"nb-email\\\"></nb-action>\\n      <nb-action disabled icon=\\\"nb-notifications\\\"></nb-action>\\n      <nb-action>\\n        <nb-user name=\\\"Han Solo\\\"></nb-user>\\n      </nb-action>\\n      <nb-action icon=\\\"nb-gear\\\"></nb-action>\\n    </nb-actions>\\n  </nb-card-body>\\n</nb-card>\\n\"","module.exports = \"<nb-card>\\n  <nb-card-body>\\n    <nb-actions size=\\\"medium\\\" fullWidth>\\n      <nb-action>\\n        <i class=\\\"nb-pause-outline\\\"></i><span>Pause</span>\\n      </nb-action>\\n      <nb-action>\\n        <i class=\\\"nb-list\\\"></i><span>Logs</span>\\n      </nb-action>\\n      <nb-action>\\n        <i class=\\\"nb-search\\\"></i><span>Search</span>\\n      </nb-action>\\n      <nb-action>\\n        <i class=\\\"nb-gear\\\"></i><span>Setup</span>\\n      </nb-action>\\n    </nb-actions>\\n  </nb-card-body>\\n</nb-card>\\n\"","module.exports = \"/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/**\\n * This is a starting point where we declare the maps of themes and globally available functions/mixins\\n */\\n/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/**\\n * This mixin generates keyfames.\\n * Because of all keyframes can't be scoped,\\n * we need to puts unique name in each btn-pulse call.\\n */\\n/*\\n\\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\\n:host and :host-context are pseudo-classes. So we assume they could be combined,\\nlike other pseudo-classes, even same ones.\\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\\n\\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\\nso direction could be overridden on any component level.\\n\\nImplementation code:\\n\\n@mixin nb-rtl() {\\n  // add # to scss interpolation statement.\\n  // it works in comments and we can't use it here\\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\\n    @content;\\n  }\\n}\\n\\nAnd when we call it somewhere:\\n\\n:host {\\n  .some-class {\\n    @include nb-rtl() {\\n      ...\\n    }\\n  }\\n}\\n:host-context(...) {\\n  .some-class {\\n    @include nb-rtl() {\\n      ...\\n    }\\n  }\\n}\\n\\nResult will look like:\\n\\n:host-context([dir=rtl]):host .some-class {\\n  ...\\n}\\n:host-context([dir=rtl]):host-context(...) .some-class {\\n  ...\\n}\\n\\n*\\n  Side note:\\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\\n\\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\\n  so order is not important.\\n*\\n\\n\\nCurrently, there're two problems with this approach:\\n\\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\\nFor the moment of writing, the only possible way is:\\n:host {\\n  :host-context(...) {\\n    ...\\n  }\\n}\\nIt doesn't work for us because mixin could be called somewhere deeper, like:\\n:host {\\n  p {\\n    @include nb-rtl() { ... }\\n  }\\n}\\nWe are not able to go up to :host level to place content passed to mixin.\\n\\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\\n  *\\n    Side note:\\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\\n    :host-context($theme) once we will be able to use multiple shadow selectors.\\n  *\\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\\n  ***\\n    Possible solution\\n    check if we in theme by some theme variables and if so append, otherwise nest like\\n    @at-root :host-context([dir=rtl]) {\\n      // add # to scss interpolation statement.\\n      // it works in comments and we can't use it here\\n      {&} {\\n        @content;\\n      }\\n    }\\n    What if :host specified? Can we add space in :host-context(...) :host?\\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\\n  ***\\n\\n\\nProblems with the current approach.\\n\\n1. Direction can be applied only on document level, because mixin prepends theme class,\\nwhich placed on the body.\\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\\nattribute to [dir=rtl] attribute as well.\\n\\n\\nGeneral problems.\\n\\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\\n*/\\n/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/**\\n * This mixin generates keyfames.\\n * Because of all keyframes can't be scoped,\\n * we need to puts unique name in each btn-pulse call.\\n */\\n/*\\n\\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\\n:host and :host-context are pseudo-classes. So we assume they could be combined,\\nlike other pseudo-classes, even same ones.\\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\\n\\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\\nso direction could be overridden on any component level.\\n\\nImplementation code:\\n\\n@mixin nb-rtl() {\\n  // add # to scss interpolation statement.\\n  // it works in comments and we can't use it here\\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\\n    @content;\\n  }\\n}\\n\\nAnd when we call it somewhere:\\n\\n:host {\\n  .some-class {\\n    @include nb-rtl() {\\n      ...\\n    }\\n  }\\n}\\n:host-context(...) {\\n  .some-class {\\n    @include nb-rtl() {\\n      ...\\n    }\\n  }\\n}\\n\\nResult will look like:\\n\\n:host-context([dir=rtl]):host .some-class {\\n  ...\\n}\\n:host-context([dir=rtl]):host-context(...) .some-class {\\n  ...\\n}\\n\\n*\\n  Side note:\\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\\n\\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\\n  so order is not important.\\n*\\n\\n\\nCurrently, there're two problems with this approach:\\n\\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\\nFor the moment of writing, the only possible way is:\\n:host {\\n  :host-context(...) {\\n    ...\\n  }\\n}\\nIt doesn't work for us because mixin could be called somewhere deeper, like:\\n:host {\\n  p {\\n    @include nb-rtl() { ... }\\n  }\\n}\\nWe are not able to go up to :host level to place content passed to mixin.\\n\\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\\n  *\\n    Side note:\\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\\n    :host-context($theme) once we will be able to use multiple shadow selectors.\\n  *\\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\\n  ***\\n    Possible solution\\n    check if we in theme by some theme variables and if so append, otherwise nest like\\n    @at-root :host-context([dir=rtl]) {\\n      // add # to scss interpolation statement.\\n      // it works in comments and we can't use it here\\n      {&} {\\n        @content;\\n      }\\n    }\\n    What if :host specified? Can we add space in :host-context(...) :host?\\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\\n  ***\\n\\n\\nProblems with the current approach.\\n\\n1. Direction can be applied only on document level, because mixin prepends theme class,\\nwhich placed on the body.\\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\\nattribute to [dir=rtl] attribute as well.\\n\\n\\nGeneral problems.\\n\\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\\n*/\\n/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/**\\n * This mixin generates keyfames.\\n * Because of all keyframes can't be scoped,\\n * we need to puts unique name in each btn-pulse call.\\n */\\n/*\\n\\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\\n:host and :host-context are pseudo-classes. So we assume they could be combined,\\nlike other pseudo-classes, even same ones.\\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\\n\\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\\nso direction could be overridden on any component level.\\n\\nImplementation code:\\n\\n@mixin nb-rtl() {\\n  // add # to scss interpolation statement.\\n  // it works in comments and we can't use it here\\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\\n    @content;\\n  }\\n}\\n\\nAnd when we call it somewhere:\\n\\n:host {\\n  .some-class {\\n    @include nb-rtl() {\\n      ...\\n    }\\n  }\\n}\\n:host-context(...) {\\n  .some-class {\\n    @include nb-rtl() {\\n      ...\\n    }\\n  }\\n}\\n\\nResult will look like:\\n\\n:host-context([dir=rtl]):host .some-class {\\n  ...\\n}\\n:host-context([dir=rtl]):host-context(...) .some-class {\\n  ...\\n}\\n\\n*\\n  Side note:\\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\\n\\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\\n  so order is not important.\\n*\\n\\n\\nCurrently, there're two problems with this approach:\\n\\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\\nFor the moment of writing, the only possible way is:\\n:host {\\n  :host-context(...) {\\n    ...\\n  }\\n}\\nIt doesn't work for us because mixin could be called somewhere deeper, like:\\n:host {\\n  p {\\n    @include nb-rtl() { ... }\\n  }\\n}\\nWe are not able to go up to :host level to place content passed to mixin.\\n\\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\\n  *\\n    Side note:\\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\\n    :host-context($theme) once we will be able to use multiple shadow selectors.\\n  *\\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\\n  ***\\n    Possible solution\\n    check if we in theme by some theme variables and if so append, otherwise nest like\\n    @at-root :host-context([dir=rtl]) {\\n      // add # to scss interpolation statement.\\n      // it works in comments and we can't use it here\\n      {&} {\\n        @content;\\n      }\\n    }\\n    What if :host specified? Can we add space in :host-context(...) :host?\\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\\n  ***\\n\\n\\nProblems with the current approach.\\n\\n1. Direction can be applied only on document level, because mixin prepends theme class,\\nwhich placed on the body.\\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\\nattribute to [dir=rtl] attribute as well.\\n\\n\\nGeneral problems.\\n\\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\\n*/\\n/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/**\\n * This mixin generates keyfames.\\n * Because of all keyframes can't be scoped,\\n * we need to puts unique name in each btn-pulse call.\\n */\\n/*\\n\\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\\n:host and :host-context are pseudo-classes. So we assume they could be combined,\\nlike other pseudo-classes, even same ones.\\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\\n\\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\\nso direction could be overridden on any component level.\\n\\nImplementation code:\\n\\n@mixin nb-rtl() {\\n  // add # to scss interpolation statement.\\n  // it works in comments and we can't use it here\\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\\n    @content;\\n  }\\n}\\n\\nAnd when we call it somewhere:\\n\\n:host {\\n  .some-class {\\n    @include nb-rtl() {\\n      ...\\n    }\\n  }\\n}\\n:host-context(...) {\\n  .some-class {\\n    @include nb-rtl() {\\n      ...\\n    }\\n  }\\n}\\n\\nResult will look like:\\n\\n:host-context([dir=rtl]):host .some-class {\\n  ...\\n}\\n:host-context([dir=rtl]):host-context(...) .some-class {\\n  ...\\n}\\n\\n*\\n  Side note:\\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\\n\\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\\n  so order is not important.\\n*\\n\\n\\nCurrently, there're two problems with this approach:\\n\\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\\nFor the moment of writing, the only possible way is:\\n:host {\\n  :host-context(...) {\\n    ...\\n  }\\n}\\nIt doesn't work for us because mixin could be called somewhere deeper, like:\\n:host {\\n  p {\\n    @include nb-rtl() { ... }\\n  }\\n}\\nWe are not able to go up to :host level to place content passed to mixin.\\n\\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\\n  *\\n    Side note:\\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\\n    :host-context($theme) once we will be able to use multiple shadow selectors.\\n  *\\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\\n  ***\\n    Possible solution\\n    check if we in theme by some theme variables and if so append, otherwise nest like\\n    @at-root :host-context([dir=rtl]) {\\n      // add # to scss interpolation statement.\\n      // it works in comments and we can't use it here\\n      {&} {\\n        @content;\\n      }\\n    }\\n    What if :host specified? Can we add space in :host-context(...) :host?\\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\\n  ***\\n\\n\\nProblems with the current approach.\\n\\n1. Direction can be applied only on document level, because mixin prepends theme class,\\nwhich placed on the body.\\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\\nattribute to [dir=rtl] attribute as well.\\n\\n\\nGeneral problems.\\n\\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\\n*/\\n/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/**\\n * This mixin generates keyfames.\\n * Because of all keyframes can't be scoped,\\n * we need to puts unique name in each btn-pulse call.\\n */\\n/*\\n\\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\\n:host and :host-context are pseudo-classes. So we assume they could be combined,\\nlike other pseudo-classes, even same ones.\\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\\n\\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\\nso direction could be overridden on any component level.\\n\\nImplementation code:\\n\\n@mixin nb-rtl() {\\n  // add # to scss interpolation statement.\\n  // it works in comments and we can't use it here\\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\\n    @content;\\n  }\\n}\\n\\nAnd when we call it somewhere:\\n\\n:host {\\n  .some-class {\\n    @include nb-rtl() {\\n      ...\\n    }\\n  }\\n}\\n:host-context(...) {\\n  .some-class {\\n    @include nb-rtl() {\\n      ...\\n    }\\n  }\\n}\\n\\nResult will look like:\\n\\n:host-context([dir=rtl]):host .some-class {\\n  ...\\n}\\n:host-context([dir=rtl]):host-context(...) .some-class {\\n  ...\\n}\\n\\n*\\n  Side note:\\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\\n\\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\\n  so order is not important.\\n*\\n\\n\\nCurrently, there're two problems with this approach:\\n\\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\\nFor the moment of writing, the only possible way is:\\n:host {\\n  :host-context(...) {\\n    ...\\n  }\\n}\\nIt doesn't work for us because mixin could be called somewhere deeper, like:\\n:host {\\n  p {\\n    @include nb-rtl() { ... }\\n  }\\n}\\nWe are not able to go up to :host level to place content passed to mixin.\\n\\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\\n  *\\n    Side note:\\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\\n    :host-context($theme) once we will be able to use multiple shadow selectors.\\n  *\\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\\n  ***\\n    Possible solution\\n    check if we in theme by some theme variables and if so append, otherwise nest like\\n    @at-root :host-context([dir=rtl]) {\\n      // add # to scss interpolation statement.\\n      // it works in comments and we can't use it here\\n      {&} {\\n        @content;\\n      }\\n    }\\n    What if :host specified? Can we add space in :host-context(...) :host?\\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\\n  ***\\n\\n\\nProblems with the current approach.\\n\\n1. Direction can be applied only on document level, because mixin prepends theme class,\\nwhich placed on the body.\\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\\nattribute to [dir=rtl] attribute as well.\\n\\n\\nGeneral problems.\\n\\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\\n*/\\n/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/**\\n * This mixin generates keyfames.\\n * Because of all keyframes can't be scoped,\\n * we need to puts unique name in each btn-pulse call.\\n */\\n/*\\n\\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\\n:host and :host-context are pseudo-classes. So we assume they could be combined,\\nlike other pseudo-classes, even same ones.\\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\\n\\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\\nso direction could be overridden on any component level.\\n\\nImplementation code:\\n\\n@mixin nb-rtl() {\\n  // add # to scss interpolation statement.\\n  // it works in comments and we can't use it here\\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\\n    @content;\\n  }\\n}\\n\\nAnd when we call it somewhere:\\n\\n:host {\\n  .some-class {\\n    @include nb-rtl() {\\n      ...\\n    }\\n  }\\n}\\n:host-context(...) {\\n  .some-class {\\n    @include nb-rtl() {\\n      ...\\n    }\\n  }\\n}\\n\\nResult will look like:\\n\\n:host-context([dir=rtl]):host .some-class {\\n  ...\\n}\\n:host-context([dir=rtl]):host-context(...) .some-class {\\n  ...\\n}\\n\\n*\\n  Side note:\\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\\n\\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\\n  so order is not important.\\n*\\n\\n\\nCurrently, there're two problems with this approach:\\n\\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\\nFor the moment of writing, the only possible way is:\\n:host {\\n  :host-context(...) {\\n    ...\\n  }\\n}\\nIt doesn't work for us because mixin could be called somewhere deeper, like:\\n:host {\\n  p {\\n    @include nb-rtl() { ... }\\n  }\\n}\\nWe are not able to go up to :host level to place content passed to mixin.\\n\\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\\n  *\\n    Side note:\\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\\n    :host-context($theme) once we will be able to use multiple shadow selectors.\\n  *\\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\\n  ***\\n    Possible solution\\n    check if we in theme by some theme variables and if so append, otherwise nest like\\n    @at-root :host-context([dir=rtl]) {\\n      // add # to scss interpolation statement.\\n      // it works in comments and we can't use it here\\n      {&} {\\n        @content;\\n      }\\n    }\\n    What if :host specified? Can we add space in :host-context(...) :host?\\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\\n  ***\\n\\n\\nProblems with the current approach.\\n\\n1. Direction can be applied only on document level, because mixin prepends theme class,\\nwhich placed on the body.\\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\\nattribute to [dir=rtl] attribute as well.\\n\\n\\nGeneral problems.\\n\\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\\n*/\\n/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/*\\n      :host can be prefixed\\n      https://github.com/angular/angular/blob/8d0ee34939f14c07876d222c25b405ed458a34d3/packages/compiler/src/shadow_css.ts#L441\\n\\n      We have to use :host insted of :host-context($theme), to be able to prefix theme class\\n      with something defined inside of @content, by prefixing &.\\n      For example this scss code:\\n        .nb-theme-default {\\n          .some-selector & {\\n            ...\\n          }\\n        }\\n      Will result in next css:\\n        .some-selector .nb-theme-default {\\n          ...\\n        }\\n\\n      It doesn't work with :host-context because angular splitting it in two selectors and removes\\n      prefix in one of the selectors.\\n    */\\n.nb-theme-default :host nb-card-body {\\n  padding-bottom: 0; }\\n.nb-theme-default :host .none {\\n  position: relative;\\n  -webkit-transform: rotate(45deg);\\n          transform: rotate(45deg); }\\n.nb-theme-default :host .none::before, .nb-theme-default :host .none::after {\\n    position: absolute;\\n    content: '';\\n    background: #dadfe6; }\\n.nb-theme-default :host .none::before {\\n    left: 50%;\\n    top: 10%;\\n    -webkit-transform: translateX(-50%);\\n            transform: translateX(-50%);\\n    width: 1px;\\n    height: 80%; }\\n.nb-theme-default :host .none::after {\\n    top: 50%;\\n    left: 10%;\\n    -webkit-transform: translateY(-50%);\\n            transform: translateY(-50%);\\n    height: 1px;\\n    width: 80%; }\\n.nb-theme-default :host .shadow {\\n  -webkit-box-shadow: none;\\n          box-shadow: none; }\\n.nb-theme-default :host .primary-container .color {\\n  background-color: #8a7fff; }\\n.nb-theme-default :host .primary-container .gradient {\\n  background-image: -webkit-gradient(linear, left top, right top, from(#b57fff), to(#8a7fff));\\n  background-image: linear-gradient(to right, #b57fff, #8a7fff); }\\n.nb-theme-default :host .primary-container .glow {\\n  -webkit-box-shadow: 0 0 0 0 #9f7fff;\\n          box-shadow: 0 0 0 0 #9f7fff; }\\n.nb-theme-default :host .primary-container .bevel {\\n  -webkit-box-shadow: 0 0 0 0 #896ddb;\\n          box-shadow: 0 0 0 0 #896ddb; }\\n.nb-theme-default :host .warning-container .color {\\n  background-color: #ffa100; }\\n.nb-theme-default :host .warning-container .gradient {\\n  background-image: -webkit-gradient(linear, left top, right top, from(#ffcc00), to(#ffa100));\\n  background-image: linear-gradient(to right, #ffcc00, #ffa100); }\\n.nb-theme-default :host .warning-container .glow {\\n  -webkit-box-shadow: 0 0 0 0 #ffb600;\\n          box-shadow: 0 0 0 0 #ffb600; }\\n.nb-theme-default :host .warning-container .bevel {\\n  -webkit-box-shadow: 0 0 0 0 #db9d00;\\n          box-shadow: 0 0 0 0 #db9d00; }\\n.nb-theme-default :host .success-container .color {\\n  background-color: #40dc7e; }\\n.nb-theme-default :host .success-container .gradient {\\n  background-image: -webkit-gradient(linear, left top, right top, from(#40dcb2), to(#40dc7e));\\n  background-image: linear-gradient(to right, #40dcb2, #40dc7e); }\\n.nb-theme-default :host .success-container .glow {\\n  -webkit-box-shadow: 0 0 0 0 #40dc98;\\n          box-shadow: 0 0 0 0 #40dc98; }\\n.nb-theme-default :host .success-container .bevel {\\n  -webkit-box-shadow: 0 0 0 0 #37bd83;\\n          box-shadow: 0 0 0 0 #37bd83; }\\n.nb-theme-default :host .info-container .color {\\n  background-color: #4ca6ff; }\\n.nb-theme-default :host .info-container .gradient {\\n  background-image: -webkit-gradient(linear, left top, right top, from(#4cc4ff), to(#4ca6ff));\\n  background-image: linear-gradient(to right, #4cc4ff, #4ca6ff); }\\n.nb-theme-default :host .info-container .glow {\\n  -webkit-box-shadow: 0 0 0 0 #4cb5ff;\\n          box-shadow: 0 0 0 0 #4cb5ff; }\\n.nb-theme-default :host .info-container .bevel {\\n  -webkit-box-shadow: 0 0 0 0 #419cdb;\\n          box-shadow: 0 0 0 0 #419cdb; }\\n.nb-theme-default :host .danger-container .color {\\n  background-color: #ff4c6a; }\\n.nb-theme-default :host .danger-container .gradient {\\n  background-image: -webkit-gradient(linear, left top, right top, from(#ff4ca6), to(#ff4c6a));\\n  background-image: linear-gradient(to right, #ff4ca6, #ff4c6a); }\\n.nb-theme-default :host .danger-container .glow {\\n  -webkit-box-shadow: 0 0 0 0 #ff4c88;\\n          box-shadow: 0 0 0 0 #ff4c88; }\\n.nb-theme-default :host .danger-container .bevel {\\n  -webkit-box-shadow: 0 0 0 0 #db4175;\\n          box-shadow: 0 0 0 0 #db4175; }\\n.nb-theme-default :host .secondary-container .color {\\n  background-color: transparent; }\\n.nb-theme-default :host .secondary-container .border {\\n  border: 2px solid #dadfe6; }\\n.nb-theme-default :host .secondary-container .glow {\\n  -webkit-box-shadow: 0 0 0 0 #dadde6;\\n          box-shadow: 0 0 0 0 #dadde6; }\\n.nb-theme-default :host .secondary-container .bevel {\\n  -webkit-box-shadow: 0 0 0 0 #bbbec6;\\n          box-shadow: 0 0 0 0 #bbbec6; }\\n.nb-theme-default :host .example-container {\\n  margin-bottom: 1.5rem; }\\n/*\\n      :host can be prefixed\\n      https://github.com/angular/angular/blob/8d0ee34939f14c07876d222c25b405ed458a34d3/packages/compiler/src/shadow_css.ts#L441\\n\\n      We have to use :host insted of :host-context($theme), to be able to prefix theme class\\n      with something defined inside of @content, by prefixing &.\\n      For example this scss code:\\n        .nb-theme-default {\\n          .some-selector & {\\n            ...\\n          }\\n        }\\n      Will result in next css:\\n        .some-selector .nb-theme-default {\\n          ...\\n        }\\n\\n      It doesn't work with :host-context because angular splitting it in two selectors and removes\\n      prefix in one of the selectors.\\n    */\\n.nb-theme-cosmic :host nb-card-body {\\n  padding-bottom: 0; }\\n.nb-theme-cosmic :host .none {\\n  position: relative;\\n  -webkit-transform: rotate(45deg);\\n          transform: rotate(45deg); }\\n.nb-theme-cosmic :host .none::before, .nb-theme-cosmic :host .none::after {\\n    position: absolute;\\n    content: '';\\n    background: #342e73; }\\n.nb-theme-cosmic :host .none::before {\\n    left: 50%;\\n    top: 10%;\\n    -webkit-transform: translateX(-50%);\\n            transform: translateX(-50%);\\n    width: 1px;\\n    height: 80%; }\\n.nb-theme-cosmic :host .none::after {\\n    top: 50%;\\n    left: 10%;\\n    -webkit-transform: translateY(-50%);\\n            transform: translateY(-50%);\\n    height: 1px;\\n    width: 80%; }\\n.nb-theme-cosmic :host .shadow {\\n  -webkit-box-shadow: 0 4px 10px 0 rgba(33, 7, 77, 0.5);\\n          box-shadow: 0 4px 10px 0 rgba(33, 7, 77, 0.5); }\\n.nb-theme-cosmic :host .primary-container .color {\\n  background-color: #7659ff; }\\n.nb-theme-cosmic :host .primary-container .gradient {\\n  background-image: -webkit-gradient(linear, left top, right top, from(#ad59ff), to(#7659ff));\\n  background-image: linear-gradient(to right, #ad59ff, #7659ff); }\\n.nb-theme-cosmic :host .primary-container .glow {\\n  -webkit-box-shadow: 0 2px 8px 0 #9259ff;\\n          box-shadow: 0 2px 8px 0 #9259ff; }\\n.nb-theme-cosmic :host .primary-container .bevel {\\n  -webkit-box-shadow: 0 3px 0 0 #7e4ddb;\\n          box-shadow: 0 3px 0 0 #7e4ddb; }\\n.nb-theme-cosmic :host .warning-container .color {\\n  background-color: #ffa100; }\\n.nb-theme-cosmic :host .warning-container .gradient {\\n  background-image: -webkit-gradient(linear, left top, right top, from(#ffcc00), to(#ffa100));\\n  background-image: linear-gradient(to right, #ffcc00, #ffa100); }\\n.nb-theme-cosmic :host .warning-container .glow {\\n  -webkit-box-shadow: 0 2px 8px 0 #ffb600;\\n          box-shadow: 0 2px 8px 0 #ffb600; }\\n.nb-theme-cosmic :host .warning-container .bevel {\\n  -webkit-box-shadow: 0 3px 0 0 #db9d00;\\n          box-shadow: 0 3px 0 0 #db9d00; }\\n.nb-theme-cosmic :host .success-container .color {\\n  background-color: #00d977; }\\n.nb-theme-cosmic :host .success-container .gradient {\\n  background-image: -webkit-gradient(linear, left top, right top, from(#00d9bf), to(#00d977));\\n  background-image: linear-gradient(to right, #00d9bf, #00d977); }\\n.nb-theme-cosmic :host .success-container .glow {\\n  -webkit-box-shadow: 0 2px 8px 0 #00d99b;\\n          box-shadow: 0 2px 8px 0 #00d99b; }\\n.nb-theme-cosmic :host .success-container .bevel {\\n  -webkit-box-shadow: 0 3px 0 0 #00bb85;\\n          box-shadow: 0 3px 0 0 #00bb85; }\\n.nb-theme-cosmic :host .info-container .color {\\n  background-color: #0088ff; }\\n.nb-theme-cosmic :host .info-container .gradient {\\n  background-image: -webkit-gradient(linear, left top, right top, from(#00b3ff), to(#0088ff));\\n  background-image: linear-gradient(to right, #00b3ff, #0088ff); }\\n.nb-theme-cosmic :host .info-container .glow {\\n  -webkit-box-shadow: 0 2px 8px 0 #009dff;\\n          box-shadow: 0 2px 8px 0 #009dff; }\\n.nb-theme-cosmic :host .info-container .bevel {\\n  -webkit-box-shadow: 0 3px 0 0 #0087db;\\n          box-shadow: 0 3px 0 0 #0087db; }\\n.nb-theme-cosmic :host .danger-container .color {\\n  background-color: #ff386a; }\\n.nb-theme-cosmic :host .danger-container .gradient {\\n  background-image: -webkit-gradient(linear, left top, right top, from(#ff38ac), to(#ff386a));\\n  background-image: linear-gradient(to right, #ff38ac, #ff386a); }\\n.nb-theme-cosmic :host .danger-container .glow {\\n  -webkit-box-shadow: 0 2px 8px 0 #ff388b;\\n          box-shadow: 0 2px 8px 0 #ff388b; }\\n.nb-theme-cosmic :host .danger-container .bevel {\\n  -webkit-box-shadow: 0 3px 0 0 #db3078;\\n          box-shadow: 0 3px 0 0 #db3078; }\\n.nb-theme-cosmic :host .secondary-container .color {\\n  background-color: transparent; }\\n.nb-theme-cosmic :host .secondary-container .border {\\n  border: 2px solid #7659ff; }\\n.nb-theme-cosmic :host .secondary-container .glow {\\n  -webkit-box-shadow: 0 2px 8px 0 #9259ff;\\n          box-shadow: 0 2px 8px 0 #9259ff; }\\n.nb-theme-cosmic :host .secondary-container .bevel {\\n  -webkit-box-shadow: 0 3px 0 0 #7e4ddb;\\n          box-shadow: 0 3px 0 0 #7e4ddb; }\\n.nb-theme-cosmic :host .example-container {\\n  margin-bottom: 1.5rem; }\\n/*\\n      :host can be prefixed\\n      https://github.com/angular/angular/blob/8d0ee34939f14c07876d222c25b405ed458a34d3/packages/compiler/src/shadow_css.ts#L441\\n\\n      We have to use :host insted of :host-context($theme), to be able to prefix theme class\\n      with something defined inside of @content, by prefixing &.\\n      For example this scss code:\\n        .nb-theme-default {\\n          .some-selector & {\\n            ...\\n          }\\n        }\\n      Will result in next css:\\n        .some-selector .nb-theme-default {\\n          ...\\n        }\\n\\n      It doesn't work with :host-context because angular splitting it in two selectors and removes\\n      prefix in one of the selectors.\\n    */\\n.nb-theme-corporate :host nb-card-body {\\n  padding-bottom: 0; }\\n.nb-theme-corporate :host .none {\\n  position: relative;\\n  -webkit-transform: rotate(45deg);\\n          transform: rotate(45deg); }\\n.nb-theme-corporate :host .none::before, .nb-theme-corporate :host .none::after {\\n    position: absolute;\\n    content: '';\\n    background: #dadfe6; }\\n.nb-theme-corporate :host .none::before {\\n    left: 50%;\\n    top: 10%;\\n    -webkit-transform: translateX(-50%);\\n            transform: translateX(-50%);\\n    width: 1px;\\n    height: 80%; }\\n.nb-theme-corporate :host .none::after {\\n    top: 50%;\\n    left: 10%;\\n    -webkit-transform: translateY(-50%);\\n            transform: translateY(-50%);\\n    height: 1px;\\n    width: 80%; }\\n.nb-theme-corporate :host .shadow {\\n  -webkit-box-shadow: none;\\n          box-shadow: none; }\\n.nb-theme-corporate :host .primary-container .color {\\n  background-color: #73a1ff; }\\n.nb-theme-corporate :host .primary-container .gradient {\\n  background-image: -webkit-gradient(linear, left top, right top, from(#73a1ff), to(#73a1ff));\\n  background-image: linear-gradient(to right, #73a1ff, #73a1ff); }\\n.nb-theme-corporate :host .primary-container .glow {\\n  -webkit-box-shadow: 0 0 20px 0 #73a1ff;\\n          box-shadow: 0 0 20px 0 #73a1ff; }\\n.nb-theme-corporate :host .primary-container .bevel {\\n  -webkit-box-shadow: 0 0 0 0 #638adb;\\n          box-shadow: 0 0 0 0 #638adb; }\\n.nb-theme-corporate :host .warning-container .color {\\n  background-color: #ffa36b; }\\n.nb-theme-corporate :host .warning-container .gradient {\\n  background-image: -webkit-gradient(linear, left top, right top, from(#ffa36b), to(#ffa36b));\\n  background-image: linear-gradient(to right, #ffa36b, #ffa36b); }\\n.nb-theme-corporate :host .warning-container .glow {\\n  -webkit-box-shadow: 0 0 20px 0 #ffa36b;\\n          box-shadow: 0 0 20px 0 #ffa36b; }\\n.nb-theme-corporate :host .warning-container .bevel {\\n  -webkit-box-shadow: 0 0 0 0 #db8c5c;\\n          box-shadow: 0 0 0 0 #db8c5c; }\\n.nb-theme-corporate :host .success-container .color {\\n  background-color: #5dcfe3; }\\n.nb-theme-corporate :host .success-container .gradient {\\n  background-image: -webkit-gradient(linear, left top, right top, from(#5dcfe3), to(#5dcfe3));\\n  background-image: linear-gradient(to right, #5dcfe3, #5dcfe3); }\\n.nb-theme-corporate :host .success-container .glow {\\n  -webkit-box-shadow: 0 0 20px 0 #5dcfe3;\\n          box-shadow: 0 0 20px 0 #5dcfe3; }\\n.nb-theme-corporate :host .success-container .bevel {\\n  -webkit-box-shadow: 0 0 0 0 #50b2c3;\\n          box-shadow: 0 0 0 0 #50b2c3; }\\n.nb-theme-corporate :host .info-container .color {\\n  background-color: #ba7fec; }\\n.nb-theme-corporate :host .info-container .gradient {\\n  background-image: -webkit-gradient(linear, left top, right top, from(#ba7fec), to(#ba7fec));\\n  background-image: linear-gradient(to right, #ba7fec, #ba7fec); }\\n.nb-theme-corporate :host .info-container .glow {\\n  -webkit-box-shadow: 0 0 20px 0 #ba7fec;\\n          box-shadow: 0 0 20px 0 #ba7fec; }\\n.nb-theme-corporate :host .info-container .bevel {\\n  -webkit-box-shadow: 0 0 0 0 #a06dcb;\\n          box-shadow: 0 0 0 0 #a06dcb; }\\n.nb-theme-corporate :host .danger-container .color {\\n  background-color: #ff6b83; }\\n.nb-theme-corporate :host .danger-container .gradient {\\n  background-image: -webkit-gradient(linear, left top, right top, from(#ff6b83), to(#ff6b83));\\n  background-image: linear-gradient(to right, #ff6b83, #ff6b83); }\\n.nb-theme-corporate :host .danger-container .glow {\\n  -webkit-box-shadow: 0 0 20px 0 #ff6b83;\\n          box-shadow: 0 0 20px 0 #ff6b83; }\\n.nb-theme-corporate :host .danger-container .bevel {\\n  -webkit-box-shadow: 0 0 0 0 #db5c71;\\n          box-shadow: 0 0 0 0 #db5c71; }\\n.nb-theme-corporate :host .secondary-container .color {\\n  background-color: #edf2f5; }\\n.nb-theme-corporate :host .secondary-container .border {\\n  border: 2px solid #edf2f5; }\\n.nb-theme-corporate :host .secondary-container .glow {\\n  -webkit-box-shadow: 0 0 0 0 #edf2f5;\\n          box-shadow: 0 0 0 0 #edf2f5; }\\n.nb-theme-corporate :host .secondary-container .bevel {\\n  -webkit-box-shadow: 0 0 0 0 #ccd0d3;\\n          box-shadow: 0 0 0 0 #ccd0d3; }\\n.nb-theme-corporate :host .example-container {\\n  margin-bottom: 1.5rem; }\\n\"","module.exports = \"/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/**\\n * This is a starting point where we declare the maps of themes and globally available functions/mixins\\n */\\n/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/**\\n * This mixin generates keyfames.\\n * Because of all keyframes can't be scoped,\\n * we need to puts unique name in each btn-pulse call.\\n */\\n/*\\n\\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\\n:host and :host-context are pseudo-classes. So we assume they could be combined,\\nlike other pseudo-classes, even same ones.\\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\\n\\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\\nso direction could be overridden on any component level.\\n\\nImplementation code:\\n\\n@mixin nb-rtl() {\\n  // add # to scss interpolation statement.\\n  // it works in comments and we can't use it here\\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\\n    @content;\\n  }\\n}\\n\\nAnd when we call it somewhere:\\n\\n:host {\\n  .some-class {\\n    @include nb-rtl() {\\n      ...\\n    }\\n  }\\n}\\n:host-context(...) {\\n  .some-class {\\n    @include nb-rtl() {\\n      ...\\n    }\\n  }\\n}\\n\\nResult will look like:\\n\\n:host-context([dir=rtl]):host .some-class {\\n  ...\\n}\\n:host-context([dir=rtl]):host-context(...) .some-class {\\n  ...\\n}\\n\\n*\\n  Side note:\\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\\n\\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\\n  so order is not important.\\n*\\n\\n\\nCurrently, there're two problems with this approach:\\n\\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\\nFor the moment of writing, the only possible way is:\\n:host {\\n  :host-context(...) {\\n    ...\\n  }\\n}\\nIt doesn't work for us because mixin could be called somewhere deeper, like:\\n:host {\\n  p {\\n    @include nb-rtl() { ... }\\n  }\\n}\\nWe are not able to go up to :host level to place content passed to mixin.\\n\\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\\n  *\\n    Side note:\\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\\n    :host-context($theme) once we will be able to use multiple shadow selectors.\\n  *\\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\\n  ***\\n    Possible solution\\n    check if we in theme by some theme variables and if so append, otherwise nest like\\n    @at-root :host-context([dir=rtl]) {\\n      // add # to scss interpolation statement.\\n      // it works in comments and we can't use it here\\n      {&} {\\n        @content;\\n      }\\n    }\\n    What if :host specified? Can we add space in :host-context(...) :host?\\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\\n  ***\\n\\n\\nProblems with the current approach.\\n\\n1. Direction can be applied only on document level, because mixin prepends theme class,\\nwhich placed on the body.\\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\\nattribute to [dir=rtl] attribute as well.\\n\\n\\nGeneral problems.\\n\\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\\n*/\\n/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/**\\n * This mixin generates keyfames.\\n * Because of all keyframes can't be scoped,\\n * we need to puts unique name in each btn-pulse call.\\n */\\n/*\\n\\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\\n:host and :host-context are pseudo-classes. So we assume they could be combined,\\nlike other pseudo-classes, even same ones.\\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\\n\\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\\nso direction could be overridden on any component level.\\n\\nImplementation code:\\n\\n@mixin nb-rtl() {\\n  // add # to scss interpolation statement.\\n  // it works in comments and we can't use it here\\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\\n    @content;\\n  }\\n}\\n\\nAnd when we call it somewhere:\\n\\n:host {\\n  .some-class {\\n    @include nb-rtl() {\\n      ...\\n    }\\n  }\\n}\\n:host-context(...) {\\n  .some-class {\\n    @include nb-rtl() {\\n      ...\\n    }\\n  }\\n}\\n\\nResult will look like:\\n\\n:host-context([dir=rtl]):host .some-class {\\n  ...\\n}\\n:host-context([dir=rtl]):host-context(...) .some-class {\\n  ...\\n}\\n\\n*\\n  Side note:\\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\\n\\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\\n  so order is not important.\\n*\\n\\n\\nCurrently, there're two problems with this approach:\\n\\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\\nFor the moment of writing, the only possible way is:\\n:host {\\n  :host-context(...) {\\n    ...\\n  }\\n}\\nIt doesn't work for us because mixin could be called somewhere deeper, like:\\n:host {\\n  p {\\n    @include nb-rtl() { ... }\\n  }\\n}\\nWe are not able to go up to :host level to place content passed to mixin.\\n\\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\\n  *\\n    Side note:\\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\\n    :host-context($theme) once we will be able to use multiple shadow selectors.\\n  *\\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\\n  ***\\n    Possible solution\\n    check if we in theme by some theme variables and if so append, otherwise nest like\\n    @at-root :host-context([dir=rtl]) {\\n      // add # to scss interpolation statement.\\n      // it works in comments and we can't use it here\\n      {&} {\\n        @content;\\n      }\\n    }\\n    What if :host specified? Can we add space in :host-context(...) :host?\\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\\n  ***\\n\\n\\nProblems with the current approach.\\n\\n1. Direction can be applied only on document level, because mixin prepends theme class,\\nwhich placed on the body.\\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\\nattribute to [dir=rtl] attribute as well.\\n\\n\\nGeneral problems.\\n\\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\\n*/\\n/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/**\\n * This mixin generates keyfames.\\n * Because of all keyframes can't be scoped,\\n * we need to puts unique name in each btn-pulse call.\\n */\\n/*\\n\\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\\n:host and :host-context are pseudo-classes. So we assume they could be combined,\\nlike other pseudo-classes, even same ones.\\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\\n\\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\\nso direction could be overridden on any component level.\\n\\nImplementation code:\\n\\n@mixin nb-rtl() {\\n  // add # to scss interpolation statement.\\n  // it works in comments and we can't use it here\\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\\n    @content;\\n  }\\n}\\n\\nAnd when we call it somewhere:\\n\\n:host {\\n  .some-class {\\n    @include nb-rtl() {\\n      ...\\n    }\\n  }\\n}\\n:host-context(...) {\\n  .some-class {\\n    @include nb-rtl() {\\n      ...\\n    }\\n  }\\n}\\n\\nResult will look like:\\n\\n:host-context([dir=rtl]):host .some-class {\\n  ...\\n}\\n:host-context([dir=rtl]):host-context(...) .some-class {\\n  ...\\n}\\n\\n*\\n  Side note:\\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\\n\\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\\n  so order is not important.\\n*\\n\\n\\nCurrently, there're two problems with this approach:\\n\\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\\nFor the moment of writing, the only possible way is:\\n:host {\\n  :host-context(...) {\\n    ...\\n  }\\n}\\nIt doesn't work for us because mixin could be called somewhere deeper, like:\\n:host {\\n  p {\\n    @include nb-rtl() { ... }\\n  }\\n}\\nWe are not able to go up to :host level to place content passed to mixin.\\n\\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\\n  *\\n    Side note:\\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\\n    :host-context($theme) once we will be able to use multiple shadow selectors.\\n  *\\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\\n  ***\\n    Possible solution\\n    check if we in theme by some theme variables and if so append, otherwise nest like\\n    @at-root :host-context([dir=rtl]) {\\n      // add # to scss interpolation statement.\\n      // it works in comments and we can't use it here\\n      {&} {\\n        @content;\\n      }\\n    }\\n    What if :host specified? Can we add space in :host-context(...) :host?\\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\\n  ***\\n\\n\\nProblems with the current approach.\\n\\n1. Direction can be applied only on document level, because mixin prepends theme class,\\nwhich placed on the body.\\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\\nattribute to [dir=rtl] attribute as well.\\n\\n\\nGeneral problems.\\n\\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\\n*/\\n/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/**\\n * This mixin generates keyfames.\\n * Because of all keyframes can't be scoped,\\n * we need to puts unique name in each btn-pulse call.\\n */\\n/*\\n\\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\\n:host and :host-context are pseudo-classes. So we assume they could be combined,\\nlike other pseudo-classes, even same ones.\\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\\n\\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\\nso direction could be overridden on any component level.\\n\\nImplementation code:\\n\\n@mixin nb-rtl() {\\n  // add # to scss interpolation statement.\\n  // it works in comments and we can't use it here\\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\\n    @content;\\n  }\\n}\\n\\nAnd when we call it somewhere:\\n\\n:host {\\n  .some-class {\\n    @include nb-rtl() {\\n      ...\\n    }\\n  }\\n}\\n:host-context(...) {\\n  .some-class {\\n    @include nb-rtl() {\\n      ...\\n    }\\n  }\\n}\\n\\nResult will look like:\\n\\n:host-context([dir=rtl]):host .some-class {\\n  ...\\n}\\n:host-context([dir=rtl]):host-context(...) .some-class {\\n  ...\\n}\\n\\n*\\n  Side note:\\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\\n\\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\\n  so order is not important.\\n*\\n\\n\\nCurrently, there're two problems with this approach:\\n\\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\\nFor the moment of writing, the only possible way is:\\n:host {\\n  :host-context(...) {\\n    ...\\n  }\\n}\\nIt doesn't work for us because mixin could be called somewhere deeper, like:\\n:host {\\n  p {\\n    @include nb-rtl() { ... }\\n  }\\n}\\nWe are not able to go up to :host level to place content passed to mixin.\\n\\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\\n  *\\n    Side note:\\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\\n    :host-context($theme) once we will be able to use multiple shadow selectors.\\n  *\\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\\n  ***\\n    Possible solution\\n    check if we in theme by some theme variables and if so append, otherwise nest like\\n    @at-root :host-context([dir=rtl]) {\\n      // add # to scss interpolation statement.\\n      // it works in comments and we can't use it here\\n      {&} {\\n        @content;\\n      }\\n    }\\n    What if :host specified? Can we add space in :host-context(...) :host?\\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\\n  ***\\n\\n\\nProblems with the current approach.\\n\\n1. Direction can be applied only on document level, because mixin prepends theme class,\\nwhich placed on the body.\\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\\nattribute to [dir=rtl] attribute as well.\\n\\n\\nGeneral problems.\\n\\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\\n*/\\n/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/**\\n * This mixin generates keyfames.\\n * Because of all keyframes can't be scoped,\\n * we need to puts unique name in each btn-pulse call.\\n */\\n/*\\n\\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\\n:host and :host-context are pseudo-classes. So we assume they could be combined,\\nlike other pseudo-classes, even same ones.\\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\\n\\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\\nso direction could be overridden on any component level.\\n\\nImplementation code:\\n\\n@mixin nb-rtl() {\\n  // add # to scss interpolation statement.\\n  // it works in comments and we can't use it here\\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\\n    @content;\\n  }\\n}\\n\\nAnd when we call it somewhere:\\n\\n:host {\\n  .some-class {\\n    @include nb-rtl() {\\n      ...\\n    }\\n  }\\n}\\n:host-context(...) {\\n  .some-class {\\n    @include nb-rtl() {\\n      ...\\n    }\\n  }\\n}\\n\\nResult will look like:\\n\\n:host-context([dir=rtl]):host .some-class {\\n  ...\\n}\\n:host-context([dir=rtl]):host-context(...) .some-class {\\n  ...\\n}\\n\\n*\\n  Side note:\\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\\n\\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\\n  so order is not important.\\n*\\n\\n\\nCurrently, there're two problems with this approach:\\n\\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\\nFor the moment of writing, the only possible way is:\\n:host {\\n  :host-context(...) {\\n    ...\\n  }\\n}\\nIt doesn't work for us because mixin could be called somewhere deeper, like:\\n:host {\\n  p {\\n    @include nb-rtl() { ... }\\n  }\\n}\\nWe are not able to go up to :host level to place content passed to mixin.\\n\\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\\n  *\\n    Side note:\\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\\n    :host-context($theme) once we will be able to use multiple shadow selectors.\\n  *\\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\\n  ***\\n    Possible solution\\n    check if we in theme by some theme variables and if so append, otherwise nest like\\n    @at-root :host-context([dir=rtl]) {\\n      // add # to scss interpolation statement.\\n      // it works in comments and we can't use it here\\n      {&} {\\n        @content;\\n      }\\n    }\\n    What if :host specified? Can we add space in :host-context(...) :host?\\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\\n  ***\\n\\n\\nProblems with the current approach.\\n\\n1. Direction can be applied only on document level, because mixin prepends theme class,\\nwhich placed on the body.\\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\\nattribute to [dir=rtl] attribute as well.\\n\\n\\nGeneral problems.\\n\\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\\n*/\\n/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/**\\n * This mixin generates keyfames.\\n * Because of all keyframes can't be scoped,\\n * we need to puts unique name in each btn-pulse call.\\n */\\n/*\\n\\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\\n:host and :host-context are pseudo-classes. So we assume they could be combined,\\nlike other pseudo-classes, even same ones.\\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\\n\\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\\nso direction could be overridden on any component level.\\n\\nImplementation code:\\n\\n@mixin nb-rtl() {\\n  // add # to scss interpolation statement.\\n  // it works in comments and we can't use it here\\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\\n    @content;\\n  }\\n}\\n\\nAnd when we call it somewhere:\\n\\n:host {\\n  .some-class {\\n    @include nb-rtl() {\\n      ...\\n    }\\n  }\\n}\\n:host-context(...) {\\n  .some-class {\\n    @include nb-rtl() {\\n      ...\\n    }\\n  }\\n}\\n\\nResult will look like:\\n\\n:host-context([dir=rtl]):host .some-class {\\n  ...\\n}\\n:host-context([dir=rtl]):host-context(...) .some-class {\\n  ...\\n}\\n\\n*\\n  Side note:\\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\\n\\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\\n  so order is not important.\\n*\\n\\n\\nCurrently, there're two problems with this approach:\\n\\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\\nFor the moment of writing, the only possible way is:\\n:host {\\n  :host-context(...) {\\n    ...\\n  }\\n}\\nIt doesn't work for us because mixin could be called somewhere deeper, like:\\n:host {\\n  p {\\n    @include nb-rtl() { ... }\\n  }\\n}\\nWe are not able to go up to :host level to place content passed to mixin.\\n\\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\\n  *\\n    Side note:\\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\\n    :host-context($theme) once we will be able to use multiple shadow selectors.\\n  *\\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\\n  ***\\n    Possible solution\\n    check if we in theme by some theme variables and if so append, otherwise nest like\\n    @at-root :host-context([dir=rtl]) {\\n      // add # to scss interpolation statement.\\n      // it works in comments and we can't use it here\\n      {&} {\\n        @content;\\n      }\\n    }\\n    What if :host specified? Can we add space in :host-context(...) :host?\\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\\n  ***\\n\\n\\nProblems with the current approach.\\n\\n1. Direction can be applied only on document level, because mixin prepends theme class,\\nwhich placed on the body.\\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\\nattribute to [dir=rtl] attribute as well.\\n\\n\\nGeneral problems.\\n\\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\\n*/\\n/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/*\\n      :host can be prefixed\\n      https://github.com/angular/angular/blob/8d0ee34939f14c07876d222c25b405ed458a34d3/packages/compiler/src/shadow_css.ts#L441\\n\\n      We have to use :host insted of :host-context($theme), to be able to prefix theme class\\n      with something defined inside of @content, by prefixing &.\\n      For example this scss code:\\n        .nb-theme-default {\\n          .some-selector & {\\n            ...\\n          }\\n        }\\n      Will result in next css:\\n        .some-selector .nb-theme-default {\\n          ...\\n        }\\n\\n      It doesn't work with :host-context because angular splitting it in two selectors and removes\\n      prefix in one of the selectors.\\n    */\\n.nb-theme-default :host nb-actions > nb-action {\\n  padding: 0; }\\n.nb-theme-default :host nb-action i {\\n  color: #a4abb3;\\n  font-size: 2.5rem; }\\n[dir=ltr] .nb-theme-default :host nb-action i {\\n    margin-right: 1rem; }\\n[dir=rtl] .nb-theme-default :host nb-action i {\\n    margin-left: 1rem; }\\n.nb-theme-default :host nb-action span {\\n  font-family: Exo;\\n  font-weight: 600;\\n  color: #2a2a2a;\\n  text-transform: uppercase; }\\n@media (max-width: 991.98px) {\\n  .nb-theme-default :host nb-actions nb-action {\\n    padding: 0 0.75rem; } }\\n@media (max-width: 767.98px) {\\n  .nb-theme-default :host nb-card-body {\\n    padding: 1rem; }\\n  .nb-theme-default :host nb-action {\\n    font-size: 0.75rem; }\\n    .nb-theme-default :host nb-action i {\\n      font-size: 2rem; }\\n      [dir=ltr] .nb-theme-default :host nb-action i {\\n        margin-right: 0.5rem; }\\n      [dir=rtl] .nb-theme-default :host nb-action i {\\n        margin-left: 0.5rem; } }\\n@media (max-width: 575.98px) {\\n  .nb-theme-default :host nb-action i {\\n    font-size: 1.75rem;\\n    margin: 0; }\\n  .nb-theme-default :host span {\\n    display: none; } }\\n/*\\n      :host can be prefixed\\n      https://github.com/angular/angular/blob/8d0ee34939f14c07876d222c25b405ed458a34d3/packages/compiler/src/shadow_css.ts#L441\\n\\n      We have to use :host insted of :host-context($theme), to be able to prefix theme class\\n      with something defined inside of @content, by prefixing &.\\n      For example this scss code:\\n        .nb-theme-default {\\n          .some-selector & {\\n            ...\\n          }\\n        }\\n      Will result in next css:\\n        .some-selector .nb-theme-default {\\n          ...\\n        }\\n\\n      It doesn't work with :host-context because angular splitting it in two selectors and removes\\n      prefix in one of the selectors.\\n    */\\n.nb-theme-cosmic :host nb-actions > nb-action {\\n  padding: 0; }\\n.nb-theme-cosmic :host nb-action i {\\n  color: #a1a1e5;\\n  font-size: 2.5rem; }\\n[dir=ltr] .nb-theme-cosmic :host nb-action i {\\n    margin-right: 1rem; }\\n[dir=rtl] .nb-theme-cosmic :host nb-action i {\\n    margin-left: 1rem; }\\n.nb-theme-cosmic :host nb-action span {\\n  font-family: Exo;\\n  font-weight: 600;\\n  color: #ffffff;\\n  text-transform: uppercase; }\\n@media (max-width: 991.98px) {\\n  .nb-theme-cosmic :host nb-actions nb-action {\\n    padding: 0 0.75rem; } }\\n@media (max-width: 767.98px) {\\n  .nb-theme-cosmic :host nb-card-body {\\n    padding: 1rem; }\\n  .nb-theme-cosmic :host nb-action {\\n    font-size: 0.75rem; }\\n    .nb-theme-cosmic :host nb-action i {\\n      font-size: 2rem; }\\n      [dir=ltr] .nb-theme-cosmic :host nb-action i {\\n        margin-right: 0.5rem; }\\n      [dir=rtl] .nb-theme-cosmic :host nb-action i {\\n        margin-left: 0.5rem; } }\\n@media (max-width: 575.98px) {\\n  .nb-theme-cosmic :host nb-action i {\\n    font-size: 1.75rem;\\n    margin: 0; }\\n  .nb-theme-cosmic :host span {\\n    display: none; } }\\n/*\\n      :host can be prefixed\\n      https://github.com/angular/angular/blob/8d0ee34939f14c07876d222c25b405ed458a34d3/packages/compiler/src/shadow_css.ts#L441\\n\\n      We have to use :host insted of :host-context($theme), to be able to prefix theme class\\n      with something defined inside of @content, by prefixing &.\\n      For example this scss code:\\n        .nb-theme-default {\\n          .some-selector & {\\n            ...\\n          }\\n        }\\n      Will result in next css:\\n        .some-selector .nb-theme-default {\\n          ...\\n        }\\n\\n      It doesn't work with :host-context because angular splitting it in two selectors and removes\\n      prefix in one of the selectors.\\n    */\\n.nb-theme-corporate :host nb-actions > nb-action {\\n  padding: 0; }\\n.nb-theme-corporate :host nb-action i {\\n  color: #a4abb3;\\n  font-size: 2.5rem;\\n  color: #d3dbe5; }\\n[dir=ltr] .nb-theme-corporate :host nb-action i {\\n    margin-right: 1rem; }\\n[dir=rtl] .nb-theme-corporate :host nb-action i {\\n    margin-left: 1rem; }\\n.nb-theme-corporate :host nb-action span {\\n  font-family: Exo;\\n  font-weight: 600;\\n  color: #181818;\\n  text-transform: uppercase; }\\n@media (max-width: 991.98px) {\\n  .nb-theme-corporate :host nb-actions nb-action {\\n    padding: 0 0.75rem; } }\\n@media (max-width: 767.98px) {\\n  .nb-theme-corporate :host nb-card-body {\\n    padding: 1rem; }\\n  .nb-theme-corporate :host nb-action {\\n    font-size: 0.75rem; }\\n    .nb-theme-corporate :host nb-action i {\\n      font-size: 2rem; }\\n      [dir=ltr] .nb-theme-corporate :host nb-action i {\\n        margin-right: 0.5rem; }\\n      [dir=rtl] .nb-theme-corporate :host nb-action i {\\n        margin-left: 0.5rem; } }\\n@media (max-width: 575.98px) {\\n  .nb-theme-corporate :host nb-action i {\\n    font-size: 1.75rem;\\n    margin: 0; }\\n  .nb-theme-corporate :host span {\\n    display: none; } }\\n\"","module.exports = \"<nb-card>\\n  <nb-card-header>Hero Buttons</nb-card-header>\\n  <nb-card-body>\\n    <div class=\\\"row\\\">\\n      <div class=\\\"example-container col-sm-6 col-md-4 col-xl-3 col-xxxl-2\\\" *ngFor=\\\"let hb of settings\\\">\\n        <div class=\\\"container-title\\\">\\n          <span>{{ hb.title }}</span>\\n        </div>\\n        <div class=\\\"container-btn\\\">\\n          <button class=\\\"btn {{ hb.class }} btn-demo\\\">{{ hb.buttonTitle }}</button>\\n        </div>\\n        <div class=\\\"{{ hb.container }}\\\">\\n          <div class=\\\"state-container\\\" *ngIf=\\\"hb[themeName].border\\\">\\n            <div class=\\\"state-value border\\\"></div>\\n            <div class=\\\"state-details\\\">\\n              <span class=\\\"header\\\">Border</span>\\n              <span class=\\\"subheader\\\">{{ hb[themeName].border }}</span>\\n            </div>\\n          </div>\\n          <div class=\\\"state-container\\\" *ngIf=\\\"hb[themeName].color\\\">\\n            <div class=\\\"state-value color\\\"></div>\\n            <div class=\\\"state-details\\\">\\n              <span class=\\\"header\\\">Color</span>\\n              <span class=\\\"subheader\\\">{{ hb[themeName].color }}</span>\\n            </div>\\n          </div>\\n          <div class=\\\"state-container\\\" *ngIf=\\\"hb[themeName].gradientLeft\\\">\\n            <div class=\\\"state-value gradient\\\"></div>\\n            <div class=\\\"state-details\\\">\\n              <span class=\\\"header\\\">Linear Gradient</span>\\n              <span class=\\\"subheader\\\">{{ hb[themeName].gradientLeft }}</span>\\n              <span class=\\\"subheader\\\">{{ hb[themeName].gradientRight }}</span>\\n            </div>\\n          </div>\\n          <div class=\\\"state-container\\\">\\n            <div class=\\\"state-value bevel\\\" [ngClass]=\\\"{ 'none': !hb[themeName].bevel }\\\"></div>\\n            <div class=\\\"state-details\\\" *ngIf=\\\"hb[themeName].bevel\\\">\\n              <span class=\\\"header\\\">Bevel</span>\\n              <span class=\\\"subheader\\\">0 3px 0 0</span>\\n              <span class=\\\"subheader\\\">{{ hb[themeName].bevel }}</span>\\n            </div>\\n            <div class=\\\"state-details\\\" *ngIf=\\\"!hb[themeName].bevel\\\">\\n              <span class=\\\"header\\\">No Bevel</span>\\n            </div>\\n          </div>\\n          <div class=\\\"state-container\\\">\\n            <div class=\\\"state-value shadow\\\" [ngClass]=\\\"{ 'none': !hb[themeName].shadow }\\\"></div>\\n            <div class=\\\"state-details\\\" *ngIf=\\\"hb[themeName].shadow\\\">\\n              <span class=\\\"header\\\">Shadow</span>\\n              <span class=\\\"subheader\\\">0 4px 10px 0</span>\\n              <span class=\\\"subheader\\\">{{ hb[themeName].shadow }}</span>\\n            </div>\\n            <div class=\\\"state-details\\\" *ngIf=\\\"!hb[themeName].shadow\\\">\\n              <span class=\\\"header\\\">No Shadow</span>\\n            </div>\\n          </div>\\n          <div class=\\\"state-container\\\">\\n            <div class=\\\"state-value glow\\\" [ngClass]=\\\"{ 'none': !hb[themeName].glow }\\\"></div>\\n            <div class=\\\"state-details\\\" *ngIf=\\\"hb[themeName].glow\\\">\\n              <span class=\\\"header\\\">Glow</span>\\n              <span class=\\\"subheader\\\">{{ hb[themeName].glow.params }}</span>\\n              <span class=\\\"subheader\\\">{{ hb[themeName].glow.color }}</span>\\n            </div>\\n            <div class=\\\"state-details\\\" *ngIf=\\\"!hb[themeName].glow\\\">\\n              <span class=\\\"header\\\">No Glow</span>\\n            </div>\\n          </div>\\n        </div>\\n      </div>\\n    </div>\\n  </nb-card-body>\\n</nb-card>\\n\"","module.exports = \"/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/**\\n * This is a starting point where we declare the maps of themes and globally available functions/mixins\\n */\\n/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/**\\n * This mixin generates keyfames.\\n * Because of all keyframes can't be scoped,\\n * we need to puts unique name in each btn-pulse call.\\n */\\n/*\\n\\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\\n:host and :host-context are pseudo-classes. So we assume they could be combined,\\nlike other pseudo-classes, even same ones.\\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\\n\\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\\nso direction could be overridden on any component level.\\n\\nImplementation code:\\n\\n@mixin nb-rtl() {\\n  // add # to scss interpolation statement.\\n  // it works in comments and we can't use it here\\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\\n    @content;\\n  }\\n}\\n\\nAnd when we call it somewhere:\\n\\n:host {\\n  .some-class {\\n    @include nb-rtl() {\\n      ...\\n    }\\n  }\\n}\\n:host-context(...) {\\n  .some-class {\\n    @include nb-rtl() {\\n      ...\\n    }\\n  }\\n}\\n\\nResult will look like:\\n\\n:host-context([dir=rtl]):host .some-class {\\n  ...\\n}\\n:host-context([dir=rtl]):host-context(...) .some-class {\\n  ...\\n}\\n\\n*\\n  Side note:\\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\\n\\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\\n  so order is not important.\\n*\\n\\n\\nCurrently, there're two problems with this approach:\\n\\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\\nFor the moment of writing, the only possible way is:\\n:host {\\n  :host-context(...) {\\n    ...\\n  }\\n}\\nIt doesn't work for us because mixin could be called somewhere deeper, like:\\n:host {\\n  p {\\n    @include nb-rtl() { ... }\\n  }\\n}\\nWe are not able to go up to :host level to place content passed to mixin.\\n\\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\\n  *\\n    Side note:\\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\\n    :host-context($theme) once we will be able to use multiple shadow selectors.\\n  *\\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\\n  ***\\n    Possible solution\\n    check if we in theme by some theme variables and if so append, otherwise nest like\\n    @at-root :host-context([dir=rtl]) {\\n      // add # to scss interpolation statement.\\n      // it works in comments and we can't use it here\\n      {&} {\\n        @content;\\n      }\\n    }\\n    What if :host specified? Can we add space in :host-context(...) :host?\\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\\n  ***\\n\\n\\nProblems with the current approach.\\n\\n1. Direction can be applied only on document level, because mixin prepends theme class,\\nwhich placed on the body.\\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\\nattribute to [dir=rtl] attribute as well.\\n\\n\\nGeneral problems.\\n\\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\\n*/\\n/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/**\\n * This mixin generates keyfames.\\n * Because of all keyframes can't be scoped,\\n * we need to puts unique name in each btn-pulse call.\\n */\\n/*\\n\\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\\n:host and :host-context are pseudo-classes. So we assume they could be combined,\\nlike other pseudo-classes, even same ones.\\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\\n\\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\\nso direction could be overridden on any component level.\\n\\nImplementation code:\\n\\n@mixin nb-rtl() {\\n  // add # to scss interpolation statement.\\n  // it works in comments and we can't use it here\\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\\n    @content;\\n  }\\n}\\n\\nAnd when we call it somewhere:\\n\\n:host {\\n  .some-class {\\n    @include nb-rtl() {\\n      ...\\n    }\\n  }\\n}\\n:host-context(...) {\\n  .some-class {\\n    @include nb-rtl() {\\n      ...\\n    }\\n  }\\n}\\n\\nResult will look like:\\n\\n:host-context([dir=rtl]):host .some-class {\\n  ...\\n}\\n:host-context([dir=rtl]):host-context(...) .some-class {\\n  ...\\n}\\n\\n*\\n  Side note:\\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\\n\\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\\n  so order is not important.\\n*\\n\\n\\nCurrently, there're two problems with this approach:\\n\\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\\nFor the moment of writing, the only possible way is:\\n:host {\\n  :host-context(...) {\\n    ...\\n  }\\n}\\nIt doesn't work for us because mixin could be called somewhere deeper, like:\\n:host {\\n  p {\\n    @include nb-rtl() { ... }\\n  }\\n}\\nWe are not able to go up to :host level to place content passed to mixin.\\n\\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\\n  *\\n    Side note:\\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\\n    :host-context($theme) once we will be able to use multiple shadow selectors.\\n  *\\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\\n  ***\\n    Possible solution\\n    check if we in theme by some theme variables and if so append, otherwise nest like\\n    @at-root :host-context([dir=rtl]) {\\n      // add # to scss interpolation statement.\\n      // it works in comments and we can't use it here\\n      {&} {\\n        @content;\\n      }\\n    }\\n    What if :host specified? Can we add space in :host-context(...) :host?\\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\\n  ***\\n\\n\\nProblems with the current approach.\\n\\n1. Direction can be applied only on document level, because mixin prepends theme class,\\nwhich placed on the body.\\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\\nattribute to [dir=rtl] attribute as well.\\n\\n\\nGeneral problems.\\n\\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\\n*/\\n/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/**\\n * This mixin generates keyfames.\\n * Because of all keyframes can't be scoped,\\n * we need to puts unique name in each btn-pulse call.\\n */\\n/*\\n\\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\\n:host and :host-context are pseudo-classes. So we assume they could be combined,\\nlike other pseudo-classes, even same ones.\\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\\n\\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\\nso direction could be overridden on any component level.\\n\\nImplementation code:\\n\\n@mixin nb-rtl() {\\n  // add # to scss interpolation statement.\\n  // it works in comments and we can't use it here\\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\\n    @content;\\n  }\\n}\\n\\nAnd when we call it somewhere:\\n\\n:host {\\n  .some-class {\\n    @include nb-rtl() {\\n      ...\\n    }\\n  }\\n}\\n:host-context(...) {\\n  .some-class {\\n    @include nb-rtl() {\\n      ...\\n    }\\n  }\\n}\\n\\nResult will look like:\\n\\n:host-context([dir=rtl]):host .some-class {\\n  ...\\n}\\n:host-context([dir=rtl]):host-context(...) .some-class {\\n  ...\\n}\\n\\n*\\n  Side note:\\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\\n\\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\\n  so order is not important.\\n*\\n\\n\\nCurrently, there're two problems with this approach:\\n\\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\\nFor the moment of writing, the only possible way is:\\n:host {\\n  :host-context(...) {\\n    ...\\n  }\\n}\\nIt doesn't work for us because mixin could be called somewhere deeper, like:\\n:host {\\n  p {\\n    @include nb-rtl() { ... }\\n  }\\n}\\nWe are not able to go up to :host level to place content passed to mixin.\\n\\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\\n  *\\n    Side note:\\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\\n    :host-context($theme) once we will be able to use multiple shadow selectors.\\n  *\\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\\n  ***\\n    Possible solution\\n    check if we in theme by some theme variables and if so append, otherwise nest like\\n    @at-root :host-context([dir=rtl]) {\\n      // add # to scss interpolation statement.\\n      // it works in comments and we can't use it here\\n      {&} {\\n        @content;\\n      }\\n    }\\n    What if :host specified? Can we add space in :host-context(...) :host?\\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\\n  ***\\n\\n\\nProblems with the current approach.\\n\\n1. Direction can be applied only on document level, because mixin prepends theme class,\\nwhich placed on the body.\\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\\nattribute to [dir=rtl] attribute as well.\\n\\n\\nGeneral problems.\\n\\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\\n*/\\n/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/**\\n * This mixin generates keyfames.\\n * Because of all keyframes can't be scoped,\\n * we need to puts unique name in each btn-pulse call.\\n */\\n/*\\n\\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\\n:host and :host-context are pseudo-classes. So we assume they could be combined,\\nlike other pseudo-classes, even same ones.\\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\\n\\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\\nso direction could be overridden on any component level.\\n\\nImplementation code:\\n\\n@mixin nb-rtl() {\\n  // add # to scss interpolation statement.\\n  // it works in comments and we can't use it here\\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\\n    @content;\\n  }\\n}\\n\\nAnd when we call it somewhere:\\n\\n:host {\\n  .some-class {\\n    @include nb-rtl() {\\n      ...\\n    }\\n  }\\n}\\n:host-context(...) {\\n  .some-class {\\n    @include nb-rtl() {\\n      ...\\n    }\\n  }\\n}\\n\\nResult will look like:\\n\\n:host-context([dir=rtl]):host .some-class {\\n  ...\\n}\\n:host-context([dir=rtl]):host-context(...) .some-class {\\n  ...\\n}\\n\\n*\\n  Side note:\\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\\n\\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\\n  so order is not important.\\n*\\n\\n\\nCurrently, there're two problems with this approach:\\n\\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\\nFor the moment of writing, the only possible way is:\\n:host {\\n  :host-context(...) {\\n    ...\\n  }\\n}\\nIt doesn't work for us because mixin could be called somewhere deeper, like:\\n:host {\\n  p {\\n    @include nb-rtl() { ... }\\n  }\\n}\\nWe are not able to go up to :host level to place content passed to mixin.\\n\\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\\n  *\\n    Side note:\\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\\n    :host-context($theme) once we will be able to use multiple shadow selectors.\\n  *\\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\\n  ***\\n    Possible solution\\n    check if we in theme by some theme variables and if so append, otherwise nest like\\n    @at-root :host-context([dir=rtl]) {\\n      // add # to scss interpolation statement.\\n      // it works in comments and we can't use it here\\n      {&} {\\n        @content;\\n      }\\n    }\\n    What if :host specified? Can we add space in :host-context(...) :host?\\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\\n  ***\\n\\n\\nProblems with the current approach.\\n\\n1. Direction can be applied only on document level, because mixin prepends theme class,\\nwhich placed on the body.\\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\\nattribute to [dir=rtl] attribute as well.\\n\\n\\nGeneral problems.\\n\\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\\n*/\\n/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/**\\n * This mixin generates keyfames.\\n * Because of all keyframes can't be scoped,\\n * we need to puts unique name in each btn-pulse call.\\n */\\n/*\\n\\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\\n:host and :host-context are pseudo-classes. So we assume they could be combined,\\nlike other pseudo-classes, even same ones.\\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\\n\\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\\nso direction could be overridden on any component level.\\n\\nImplementation code:\\n\\n@mixin nb-rtl() {\\n  // add # to scss interpolation statement.\\n  // it works in comments and we can't use it here\\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\\n    @content;\\n  }\\n}\\n\\nAnd when we call it somewhere:\\n\\n:host {\\n  .some-class {\\n    @include nb-rtl() {\\n      ...\\n    }\\n  }\\n}\\n:host-context(...) {\\n  .some-class {\\n    @include nb-rtl() {\\n      ...\\n    }\\n  }\\n}\\n\\nResult will look like:\\n\\n:host-context([dir=rtl]):host .some-class {\\n  ...\\n}\\n:host-context([dir=rtl]):host-context(...) .some-class {\\n  ...\\n}\\n\\n*\\n  Side note:\\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\\n\\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\\n  so order is not important.\\n*\\n\\n\\nCurrently, there're two problems with this approach:\\n\\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\\nFor the moment of writing, the only possible way is:\\n:host {\\n  :host-context(...) {\\n    ...\\n  }\\n}\\nIt doesn't work for us because mixin could be called somewhere deeper, like:\\n:host {\\n  p {\\n    @include nb-rtl() { ... }\\n  }\\n}\\nWe are not able to go up to :host level to place content passed to mixin.\\n\\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\\n  *\\n    Side note:\\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\\n    :host-context($theme) once we will be able to use multiple shadow selectors.\\n  *\\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\\n  ***\\n    Possible solution\\n    check if we in theme by some theme variables and if so append, otherwise nest like\\n    @at-root :host-context([dir=rtl]) {\\n      // add # to scss interpolation statement.\\n      // it works in comments and we can't use it here\\n      {&} {\\n        @content;\\n      }\\n    }\\n    What if :host specified? Can we add space in :host-context(...) :host?\\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\\n  ***\\n\\n\\nProblems with the current approach.\\n\\n1. Direction can be applied only on document level, because mixin prepends theme class,\\nwhich placed on the body.\\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\\nattribute to [dir=rtl] attribute as well.\\n\\n\\nGeneral problems.\\n\\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\\n*/\\n/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/**\\n * This mixin generates keyfames.\\n * Because of all keyframes can't be scoped,\\n * we need to puts unique name in each btn-pulse call.\\n */\\n/*\\n\\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\\n:host and :host-context are pseudo-classes. So we assume they could be combined,\\nlike other pseudo-classes, even same ones.\\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\\n\\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\\nso direction could be overridden on any component level.\\n\\nImplementation code:\\n\\n@mixin nb-rtl() {\\n  // add # to scss interpolation statement.\\n  // it works in comments and we can't use it here\\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\\n    @content;\\n  }\\n}\\n\\nAnd when we call it somewhere:\\n\\n:host {\\n  .some-class {\\n    @include nb-rtl() {\\n      ...\\n    }\\n  }\\n}\\n:host-context(...) {\\n  .some-class {\\n    @include nb-rtl() {\\n      ...\\n    }\\n  }\\n}\\n\\nResult will look like:\\n\\n:host-context([dir=rtl]):host .some-class {\\n  ...\\n}\\n:host-context([dir=rtl]):host-context(...) .some-class {\\n  ...\\n}\\n\\n*\\n  Side note:\\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\\n\\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\\n  so order is not important.\\n*\\n\\n\\nCurrently, there're two problems with this approach:\\n\\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\\nFor the moment of writing, the only possible way is:\\n:host {\\n  :host-context(...) {\\n    ...\\n  }\\n}\\nIt doesn't work for us because mixin could be called somewhere deeper, like:\\n:host {\\n  p {\\n    @include nb-rtl() { ... }\\n  }\\n}\\nWe are not able to go up to :host level to place content passed to mixin.\\n\\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\\n  *\\n    Side note:\\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\\n    :host-context($theme) once we will be able to use multiple shadow selectors.\\n  *\\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\\n  ***\\n    Possible solution\\n    check if we in theme by some theme variables and if so append, otherwise nest like\\n    @at-root :host-context([dir=rtl]) {\\n      // add # to scss interpolation statement.\\n      // it works in comments and we can't use it here\\n      {&} {\\n        @content;\\n      }\\n    }\\n    What if :host specified? Can we add space in :host-context(...) :host?\\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\\n  ***\\n\\n\\nProblems with the current approach.\\n\\n1. Direction can be applied only on document level, because mixin prepends theme class,\\nwhich placed on the body.\\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\\nattribute to [dir=rtl] attribute as well.\\n\\n\\nGeneral problems.\\n\\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\\n*/\\n/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/*\\n      :host can be prefixed\\n      https://github.com/angular/angular/blob/8d0ee34939f14c07876d222c25b405ed458a34d3/packages/compiler/src/shadow_css.ts#L441\\n\\n      We have to use :host insted of :host-context($theme), to be able to prefix theme class\\n      with something defined inside of @content, by prefixing &.\\n      For example this scss code:\\n        .nb-theme-default {\\n          .some-selector & {\\n            ...\\n          }\\n        }\\n      Will result in next css:\\n        .some-selector .nb-theme-default {\\n          ...\\n        }\\n\\n      It doesn't work with :host-context because angular splitting it in two selectors and removes\\n      prefix in one of the selectors.\\n    */\\n.nb-theme-default :host /deep/ .container-title {\\n  color: #a4abb3;\\n  font-family: Exo;\\n  margin-bottom: 0.5rem; }\\n.nb-theme-default :host /deep/ .header {\\n  font-size: 0.875rem; }\\n.nb-theme-default :host /deep/ .subheader {\\n  font-size: 0.75rem;\\n  font-weight: 300;\\n  color: #a4abb3; }\\n.nb-theme-default :host /deep/ .btn-demo {\\n  width: 180px; }\\n.nb-theme-default :host /deep/ .state-container {\\n  display: -webkit-box;\\n  display: -ms-flexbox;\\n  display: flex; }\\n.nb-theme-default :host /deep/ .state-container:not(:last-child) {\\n    margin-bottom: 1rem; }\\n.nb-theme-default :host /deep/ .state-container .state-value {\\n    width: 50px;\\n    height: 50px;\\n    border-radius: 0.375rem; }\\n.nb-theme-default :host /deep/ .state-container .state-details {\\n    display: -webkit-box;\\n    display: -ms-flexbox;\\n    display: flex;\\n    -webkit-box-orient: vertical;\\n    -webkit-box-direction: normal;\\n        -ms-flex-direction: column;\\n            flex-direction: column;\\n    -webkit-box-pack: center;\\n        -ms-flex-pack: center;\\n            justify-content: center;\\n    margin-left: 1rem;\\n    margin-right: 1rem;\\n    height: 50px; }\\n[dir=ltr] .nb-theme-default :host /deep/ .example-container {\\n  padding-right: 0; }\\n[dir=rtl] .nb-theme-default :host /deep/ .example-container {\\n  padding-left: 0; }\\n.nb-theme-default :host /deep/ .example-container .container-btn {\\n  margin-bottom: 1.5rem; }\\n.nb-theme-default :host /deep/ .block-level-buttons .btn-group {\\n  margin-bottom: 1rem; }\\n@media (max-width: 575.98px) {\\n  .nb-theme-default :host ngx-default-buttons /deep/ nb-card-header {\\n    -webkit-box-orient: vertical;\\n    -webkit-box-direction: normal;\\n        -ms-flex-direction: column;\\n            flex-direction: column;\\n    -webkit-box-align: left;\\n        -ms-flex-align: left;\\n            align-items: left; }\\n    .nb-theme-default :host ngx-default-buttons /deep/ nb-card-header span {\\n      margin-bottom: 1rem; } }\\n@media (max-width: 399.98px) {\\n  [dir=ltr] .nb-theme-default :host /deep/.icon-buttons .icon-button-examples button {\\n    margin-right: 1rem; }\\n  [dir=rtl] .nb-theme-default :host /deep/.icon-buttons .icon-button-examples button {\\n    margin-left: 1rem; }\\n  .nb-theme-default :host ngx-default-buttons /deep/ nb-card-header {\\n    -webkit-box-orient: vertical;\\n    -webkit-box-direction: normal;\\n        -ms-flex-direction: column;\\n            flex-direction: column;\\n    margin-bottom: 0.5rem; }\\n  .nb-theme-default :host ngx-block-level-buttons /deep/ .btn-primary {\\n    padding: 0.75rem 1rem; } }\\n/*\\n      :host can be prefixed\\n      https://github.com/angular/angular/blob/8d0ee34939f14c07876d222c25b405ed458a34d3/packages/compiler/src/shadow_css.ts#L441\\n\\n      We have to use :host insted of :host-context($theme), to be able to prefix theme class\\n      with something defined inside of @content, by prefixing &.\\n      For example this scss code:\\n        .nb-theme-default {\\n          .some-selector & {\\n            ...\\n          }\\n        }\\n      Will result in next css:\\n        .some-selector .nb-theme-default {\\n          ...\\n        }\\n\\n      It doesn't work with :host-context because angular splitting it in two selectors and removes\\n      prefix in one of the selectors.\\n    */\\n.nb-theme-cosmic :host /deep/ .container-title {\\n  color: #a1a1e5;\\n  font-family: Exo;\\n  margin-bottom: 0.5rem; }\\n.nb-theme-cosmic :host /deep/ .header {\\n  font-size: 0.875rem; }\\n.nb-theme-cosmic :host /deep/ .subheader {\\n  font-size: 0.75rem;\\n  font-weight: 300;\\n  color: #a1a1e5; }\\n.nb-theme-cosmic :host /deep/ .btn-demo {\\n  width: 180px; }\\n.nb-theme-cosmic :host /deep/ .state-container {\\n  display: -webkit-box;\\n  display: -ms-flexbox;\\n  display: flex; }\\n.nb-theme-cosmic :host /deep/ .state-container:not(:last-child) {\\n    margin-bottom: 1rem; }\\n.nb-theme-cosmic :host /deep/ .state-container .state-value {\\n    width: 50px;\\n    height: 50px;\\n    border-radius: 0.5rem; }\\n.nb-theme-cosmic :host /deep/ .state-container .state-details {\\n    display: -webkit-box;\\n    display: -ms-flexbox;\\n    display: flex;\\n    -webkit-box-orient: vertical;\\n    -webkit-box-direction: normal;\\n        -ms-flex-direction: column;\\n            flex-direction: column;\\n    -webkit-box-pack: center;\\n        -ms-flex-pack: center;\\n            justify-content: center;\\n    margin-left: 1rem;\\n    margin-right: 1rem;\\n    height: 50px; }\\n[dir=ltr] .nb-theme-cosmic :host /deep/ .example-container {\\n  padding-right: 0; }\\n[dir=rtl] .nb-theme-cosmic :host /deep/ .example-container {\\n  padding-left: 0; }\\n.nb-theme-cosmic :host /deep/ .example-container .container-btn {\\n  margin-bottom: 1.5rem; }\\n.nb-theme-cosmic :host /deep/ .block-level-buttons .btn-group {\\n  margin-bottom: 1rem; }\\n@media (max-width: 575.98px) {\\n  .nb-theme-cosmic :host ngx-default-buttons /deep/ nb-card-header {\\n    -webkit-box-orient: vertical;\\n    -webkit-box-direction: normal;\\n        -ms-flex-direction: column;\\n            flex-direction: column;\\n    -webkit-box-align: left;\\n        -ms-flex-align: left;\\n            align-items: left; }\\n    .nb-theme-cosmic :host ngx-default-buttons /deep/ nb-card-header span {\\n      margin-bottom: 1rem; } }\\n@media (max-width: 399.98px) {\\n  [dir=ltr] .nb-theme-cosmic :host /deep/.icon-buttons .icon-button-examples button {\\n    margin-right: 1rem; }\\n  [dir=rtl] .nb-theme-cosmic :host /deep/.icon-buttons .icon-button-examples button {\\n    margin-left: 1rem; }\\n  .nb-theme-cosmic :host ngx-default-buttons /deep/ nb-card-header {\\n    -webkit-box-orient: vertical;\\n    -webkit-box-direction: normal;\\n        -ms-flex-direction: column;\\n            flex-direction: column;\\n    margin-bottom: 0.5rem; }\\n  .nb-theme-cosmic :host ngx-block-level-buttons /deep/ .btn-primary {\\n    padding: 0.75rem 1rem; } }\\n/*\\n      :host can be prefixed\\n      https://github.com/angular/angular/blob/8d0ee34939f14c07876d222c25b405ed458a34d3/packages/compiler/src/shadow_css.ts#L441\\n\\n      We have to use :host insted of :host-context($theme), to be able to prefix theme class\\n      with something defined inside of @content, by prefixing &.\\n      For example this scss code:\\n        .nb-theme-default {\\n          .some-selector & {\\n            ...\\n          }\\n        }\\n      Will result in next css:\\n        .some-selector .nb-theme-default {\\n          ...\\n        }\\n\\n      It doesn't work with :host-context because angular splitting it in two selectors and removes\\n      prefix in one of the selectors.\\n    */\\n.nb-theme-corporate :host /deep/ .container-title {\\n  color: #a4abb3;\\n  font-family: Exo;\\n  margin-bottom: 0.5rem; }\\n.nb-theme-corporate :host /deep/ .header {\\n  font-size: 0.875rem; }\\n.nb-theme-corporate :host /deep/ .subheader {\\n  font-size: 0.75rem;\\n  font-weight: 300;\\n  color: #a4abb3; }\\n.nb-theme-corporate :host /deep/ .btn-demo {\\n  width: 180px; }\\n.nb-theme-corporate :host /deep/ .state-container {\\n  display: -webkit-box;\\n  display: -ms-flexbox;\\n  display: flex; }\\n.nb-theme-corporate :host /deep/ .state-container:not(:last-child) {\\n    margin-bottom: 1rem; }\\n.nb-theme-corporate :host /deep/ .state-container .state-value {\\n    width: 50px;\\n    height: 50px;\\n    border-radius: 0.75rem;\\n    border-radius: 0.75rem; }\\n.nb-theme-corporate :host /deep/ .state-container .state-details {\\n    display: -webkit-box;\\n    display: -ms-flexbox;\\n    display: flex;\\n    -webkit-box-orient: vertical;\\n    -webkit-box-direction: normal;\\n        -ms-flex-direction: column;\\n            flex-direction: column;\\n    -webkit-box-pack: center;\\n        -ms-flex-pack: center;\\n            justify-content: center;\\n    margin-left: 1rem;\\n    margin-right: 1rem;\\n    height: 50px; }\\n[dir=ltr] .nb-theme-corporate :host /deep/ .example-container {\\n  padding-right: 0; }\\n[dir=rtl] .nb-theme-corporate :host /deep/ .example-container {\\n  padding-left: 0; }\\n.nb-theme-corporate :host /deep/ .example-container .container-btn {\\n  margin-bottom: 1.5rem; }\\n.nb-theme-corporate :host /deep/ .block-level-buttons .btn-group {\\n  margin-bottom: 1rem; }\\n@media (max-width: 575.98px) {\\n  .nb-theme-corporate :host ngx-default-buttons /deep/ nb-card-header {\\n    -webkit-box-orient: vertical;\\n    -webkit-box-direction: normal;\\n        -ms-flex-direction: column;\\n            flex-direction: column;\\n    -webkit-box-align: left;\\n        -ms-flex-align: left;\\n            align-items: left; }\\n    .nb-theme-corporate :host ngx-default-buttons /deep/ nb-card-header span {\\n      margin-bottom: 1rem; } }\\n@media (max-width: 399.98px) {\\n  [dir=ltr] .nb-theme-corporate :host /deep/.icon-buttons .icon-button-examples button {\\n    margin-right: 1rem; }\\n  [dir=rtl] .nb-theme-corporate :host /deep/.icon-buttons .icon-button-examples button {\\n    margin-left: 1rem; }\\n  .nb-theme-corporate :host ngx-default-buttons /deep/ nb-card-header {\\n    -webkit-box-orient: vertical;\\n    -webkit-box-direction: normal;\\n        -ms-flex-direction: column;\\n            flex-direction: column;\\n    margin-bottom: 0.5rem; }\\n  .nb-theme-corporate :host ngx-block-level-buttons /deep/ .btn-primary {\\n    padding: 0.75rem 1rem; } }\\n\"","module.exports = \"/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/**\\n * This is a starting point where we declare the maps of themes and globally available functions/mixins\\n */\\n/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/**\\n * This mixin generates keyfames.\\n * Because of all keyframes can't be scoped,\\n * we need to puts unique name in each btn-pulse call.\\n */\\n/*\\n\\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\\n:host and :host-context are pseudo-classes. So we assume they could be combined,\\nlike other pseudo-classes, even same ones.\\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\\n\\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\\nso direction could be overridden on any component level.\\n\\nImplementation code:\\n\\n@mixin nb-rtl() {\\n  // add # to scss interpolation statement.\\n  // it works in comments and we can't use it here\\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\\n    @content;\\n  }\\n}\\n\\nAnd when we call it somewhere:\\n\\n:host {\\n  .some-class {\\n    @include nb-rtl() {\\n      ...\\n    }\\n  }\\n}\\n:host-context(...) {\\n  .some-class {\\n    @include nb-rtl() {\\n      ...\\n    }\\n  }\\n}\\n\\nResult will look like:\\n\\n:host-context([dir=rtl]):host .some-class {\\n  ...\\n}\\n:host-context([dir=rtl]):host-context(...) .some-class {\\n  ...\\n}\\n\\n*\\n  Side note:\\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\\n\\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\\n  so order is not important.\\n*\\n\\n\\nCurrently, there're two problems with this approach:\\n\\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\\nFor the moment of writing, the only possible way is:\\n:host {\\n  :host-context(...) {\\n    ...\\n  }\\n}\\nIt doesn't work for us because mixin could be called somewhere deeper, like:\\n:host {\\n  p {\\n    @include nb-rtl() { ... }\\n  }\\n}\\nWe are not able to go up to :host level to place content passed to mixin.\\n\\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\\n  *\\n    Side note:\\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\\n    :host-context($theme) once we will be able to use multiple shadow selectors.\\n  *\\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\\n  ***\\n    Possible solution\\n    check if we in theme by some theme variables and if so append, otherwise nest like\\n    @at-root :host-context([dir=rtl]) {\\n      // add # to scss interpolation statement.\\n      // it works in comments and we can't use it here\\n      {&} {\\n        @content;\\n      }\\n    }\\n    What if :host specified? Can we add space in :host-context(...) :host?\\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\\n  ***\\n\\n\\nProblems with the current approach.\\n\\n1. Direction can be applied only on document level, because mixin prepends theme class,\\nwhich placed on the body.\\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\\nattribute to [dir=rtl] attribute as well.\\n\\n\\nGeneral problems.\\n\\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\\n*/\\n/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/**\\n * This mixin generates keyfames.\\n * Because of all keyframes can't be scoped,\\n * we need to puts unique name in each btn-pulse call.\\n */\\n/*\\n\\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\\n:host and :host-context are pseudo-classes. So we assume they could be combined,\\nlike other pseudo-classes, even same ones.\\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\\n\\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\\nso direction could be overridden on any component level.\\n\\nImplementation code:\\n\\n@mixin nb-rtl() {\\n  // add # to scss interpolation statement.\\n  // it works in comments and we can't use it here\\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\\n    @content;\\n  }\\n}\\n\\nAnd when we call it somewhere:\\n\\n:host {\\n  .some-class {\\n    @include nb-rtl() {\\n      ...\\n    }\\n  }\\n}\\n:host-context(...) {\\n  .some-class {\\n    @include nb-rtl() {\\n      ...\\n    }\\n  }\\n}\\n\\nResult will look like:\\n\\n:host-context([dir=rtl]):host .some-class {\\n  ...\\n}\\n:host-context([dir=rtl]):host-context(...) .some-class {\\n  ...\\n}\\n\\n*\\n  Side note:\\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\\n\\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\\n  so order is not important.\\n*\\n\\n\\nCurrently, there're two problems with this approach:\\n\\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\\nFor the moment of writing, the only possible way is:\\n:host {\\n  :host-context(...) {\\n    ...\\n  }\\n}\\nIt doesn't work for us because mixin could be called somewhere deeper, like:\\n:host {\\n  p {\\n    @include nb-rtl() { ... }\\n  }\\n}\\nWe are not able to go up to :host level to place content passed to mixin.\\n\\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\\n  *\\n    Side note:\\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\\n    :host-context($theme) once we will be able to use multiple shadow selectors.\\n  *\\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\\n  ***\\n    Possible solution\\n    check if we in theme by some theme variables and if so append, otherwise nest like\\n    @at-root :host-context([dir=rtl]) {\\n      // add # to scss interpolation statement.\\n      // it works in comments and we can't use it here\\n      {&} {\\n        @content;\\n      }\\n    }\\n    What if :host specified? Can we add space in :host-context(...) :host?\\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\\n  ***\\n\\n\\nProblems with the current approach.\\n\\n1. Direction can be applied only on document level, because mixin prepends theme class,\\nwhich placed on the body.\\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\\nattribute to [dir=rtl] attribute as well.\\n\\n\\nGeneral problems.\\n\\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\\n*/\\n/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/**\\n * This mixin generates keyfames.\\n * Because of all keyframes can't be scoped,\\n * we need to puts unique name in each btn-pulse call.\\n */\\n/*\\n\\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\\n:host and :host-context are pseudo-classes. So we assume they could be combined,\\nlike other pseudo-classes, even same ones.\\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\\n\\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\\nso direction could be overridden on any component level.\\n\\nImplementation code:\\n\\n@mixin nb-rtl() {\\n  // add # to scss interpolation statement.\\n  // it works in comments and we can't use it here\\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\\n    @content;\\n  }\\n}\\n\\nAnd when we call it somewhere:\\n\\n:host {\\n  .some-class {\\n    @include nb-rtl() {\\n      ...\\n    }\\n  }\\n}\\n:host-context(...) {\\n  .some-class {\\n    @include nb-rtl() {\\n      ...\\n    }\\n  }\\n}\\n\\nResult will look like:\\n\\n:host-context([dir=rtl]):host .some-class {\\n  ...\\n}\\n:host-context([dir=rtl]):host-context(...) .some-class {\\n  ...\\n}\\n\\n*\\n  Side note:\\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\\n\\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\\n  so order is not important.\\n*\\n\\n\\nCurrently, there're two problems with this approach:\\n\\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\\nFor the moment of writing, the only possible way is:\\n:host {\\n  :host-context(...) {\\n    ...\\n  }\\n}\\nIt doesn't work for us because mixin could be called somewhere deeper, like:\\n:host {\\n  p {\\n    @include nb-rtl() { ... }\\n  }\\n}\\nWe are not able to go up to :host level to place content passed to mixin.\\n\\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\\n  *\\n    Side note:\\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\\n    :host-context($theme) once we will be able to use multiple shadow selectors.\\n  *\\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\\n  ***\\n    Possible solution\\n    check if we in theme by some theme variables and if so append, otherwise nest like\\n    @at-root :host-context([dir=rtl]) {\\n      // add # to scss interpolation statement.\\n      // it works in comments and we can't use it here\\n      {&} {\\n        @content;\\n      }\\n    }\\n    What if :host specified? Can we add space in :host-context(...) :host?\\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\\n  ***\\n\\n\\nProblems with the current approach.\\n\\n1. Direction can be applied only on document level, because mixin prepends theme class,\\nwhich placed on the body.\\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\\nattribute to [dir=rtl] attribute as well.\\n\\n\\nGeneral problems.\\n\\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\\n*/\\n/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/**\\n * This mixin generates keyfames.\\n * Because of all keyframes can't be scoped,\\n * we need to puts unique name in each btn-pulse call.\\n */\\n/*\\n\\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\\n:host and :host-context are pseudo-classes. So we assume they could be combined,\\nlike other pseudo-classes, even same ones.\\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\\n\\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\\nso direction could be overridden on any component level.\\n\\nImplementation code:\\n\\n@mixin nb-rtl() {\\n  // add # to scss interpolation statement.\\n  // it works in comments and we can't use it here\\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\\n    @content;\\n  }\\n}\\n\\nAnd when we call it somewhere:\\n\\n:host {\\n  .some-class {\\n    @include nb-rtl() {\\n      ...\\n    }\\n  }\\n}\\n:host-context(...) {\\n  .some-class {\\n    @include nb-rtl() {\\n      ...\\n    }\\n  }\\n}\\n\\nResult will look like:\\n\\n:host-context([dir=rtl]):host .some-class {\\n  ...\\n}\\n:host-context([dir=rtl]):host-context(...) .some-class {\\n  ...\\n}\\n\\n*\\n  Side note:\\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\\n\\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\\n  so order is not important.\\n*\\n\\n\\nCurrently, there're two problems with this approach:\\n\\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\\nFor the moment of writing, the only possible way is:\\n:host {\\n  :host-context(...) {\\n    ...\\n  }\\n}\\nIt doesn't work for us because mixin could be called somewhere deeper, like:\\n:host {\\n  p {\\n    @include nb-rtl() { ... }\\n  }\\n}\\nWe are not able to go up to :host level to place content passed to mixin.\\n\\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\\n  *\\n    Side note:\\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\\n    :host-context($theme) once we will be able to use multiple shadow selectors.\\n  *\\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\\n  ***\\n    Possible solution\\n    check if we in theme by some theme variables and if so append, otherwise nest like\\n    @at-root :host-context([dir=rtl]) {\\n      // add # to scss interpolation statement.\\n      // it works in comments and we can't use it here\\n      {&} {\\n        @content;\\n      }\\n    }\\n    What if :host specified? Can we add space in :host-context(...) :host?\\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\\n  ***\\n\\n\\nProblems with the current approach.\\n\\n1. Direction can be applied only on document level, because mixin prepends theme class,\\nwhich placed on the body.\\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\\nattribute to [dir=rtl] attribute as well.\\n\\n\\nGeneral problems.\\n\\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\\n*/\\n/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/**\\n * This mixin generates keyfames.\\n * Because of all keyframes can't be scoped,\\n * we need to puts unique name in each btn-pulse call.\\n */\\n/*\\n\\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\\n:host and :host-context are pseudo-classes. So we assume they could be combined,\\nlike other pseudo-classes, even same ones.\\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\\n\\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\\nso direction could be overridden on any component level.\\n\\nImplementation code:\\n\\n@mixin nb-rtl() {\\n  // add # to scss interpolation statement.\\n  // it works in comments and we can't use it here\\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\\n    @content;\\n  }\\n}\\n\\nAnd when we call it somewhere:\\n\\n:host {\\n  .some-class {\\n    @include nb-rtl() {\\n      ...\\n    }\\n  }\\n}\\n:host-context(...) {\\n  .some-class {\\n    @include nb-rtl() {\\n      ...\\n    }\\n  }\\n}\\n\\nResult will look like:\\n\\n:host-context([dir=rtl]):host .some-class {\\n  ...\\n}\\n:host-context([dir=rtl]):host-context(...) .some-class {\\n  ...\\n}\\n\\n*\\n  Side note:\\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\\n\\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\\n  so order is not important.\\n*\\n\\n\\nCurrently, there're two problems with this approach:\\n\\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\\nFor the moment of writing, the only possible way is:\\n:host {\\n  :host-context(...) {\\n    ...\\n  }\\n}\\nIt doesn't work for us because mixin could be called somewhere deeper, like:\\n:host {\\n  p {\\n    @include nb-rtl() { ... }\\n  }\\n}\\nWe are not able to go up to :host level to place content passed to mixin.\\n\\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\\n  *\\n    Side note:\\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\\n    :host-context($theme) once we will be able to use multiple shadow selectors.\\n  *\\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\\n  ***\\n    Possible solution\\n    check if we in theme by some theme variables and if so append, otherwise nest like\\n    @at-root :host-context([dir=rtl]) {\\n      // add # to scss interpolation statement.\\n      // it works in comments and we can't use it here\\n      {&} {\\n        @content;\\n      }\\n    }\\n    What if :host specified? Can we add space in :host-context(...) :host?\\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\\n  ***\\n\\n\\nProblems with the current approach.\\n\\n1. Direction can be applied only on document level, because mixin prepends theme class,\\nwhich placed on the body.\\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\\nattribute to [dir=rtl] attribute as well.\\n\\n\\nGeneral problems.\\n\\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\\n*/\\n/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/**\\n * This mixin generates keyfames.\\n * Because of all keyframes can't be scoped,\\n * we need to puts unique name in each btn-pulse call.\\n */\\n/*\\n\\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\\n:host and :host-context are pseudo-classes. So we assume they could be combined,\\nlike other pseudo-classes, even same ones.\\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\\n\\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\\nso direction could be overridden on any component level.\\n\\nImplementation code:\\n\\n@mixin nb-rtl() {\\n  // add # to scss interpolation statement.\\n  // it works in comments and we can't use it here\\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\\n    @content;\\n  }\\n}\\n\\nAnd when we call it somewhere:\\n\\n:host {\\n  .some-class {\\n    @include nb-rtl() {\\n      ...\\n    }\\n  }\\n}\\n:host-context(...) {\\n  .some-class {\\n    @include nb-rtl() {\\n      ...\\n    }\\n  }\\n}\\n\\nResult will look like:\\n\\n:host-context([dir=rtl]):host .some-class {\\n  ...\\n}\\n:host-context([dir=rtl]):host-context(...) .some-class {\\n  ...\\n}\\n\\n*\\n  Side note:\\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\\n\\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\\n  so order is not important.\\n*\\n\\n\\nCurrently, there're two problems with this approach:\\n\\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\\nFor the moment of writing, the only possible way is:\\n:host {\\n  :host-context(...) {\\n    ...\\n  }\\n}\\nIt doesn't work for us because mixin could be called somewhere deeper, like:\\n:host {\\n  p {\\n    @include nb-rtl() { ... }\\n  }\\n}\\nWe are not able to go up to :host level to place content passed to mixin.\\n\\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\\n  *\\n    Side note:\\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\\n    :host-context($theme) once we will be able to use multiple shadow selectors.\\n  *\\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\\n  ***\\n    Possible solution\\n    check if we in theme by some theme variables and if so append, otherwise nest like\\n    @at-root :host-context([dir=rtl]) {\\n      // add # to scss interpolation statement.\\n      // it works in comments and we can't use it here\\n      {&} {\\n        @content;\\n      }\\n    }\\n    What if :host specified? Can we add space in :host-context(...) :host?\\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\\n  ***\\n\\n\\nProblems with the current approach.\\n\\n1. Direction can be applied only on document level, because mixin prepends theme class,\\nwhich placed on the body.\\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\\nattribute to [dir=rtl] attribute as well.\\n\\n\\nGeneral problems.\\n\\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\\n*/\\n/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/*\\n      :host can be prefixed\\n      https://github.com/angular/angular/blob/8d0ee34939f14c07876d222c25b405ed458a34d3/packages/compiler/src/shadow_css.ts#L441\\n\\n      We have to use :host insted of :host-context($theme), to be able to prefix theme class\\n      with something defined inside of @content, by prefixing &.\\n      For example this scss code:\\n        .nb-theme-default {\\n          .some-selector & {\\n            ...\\n          }\\n        }\\n      Will result in next css:\\n        .some-selector .nb-theme-default {\\n          ...\\n        }\\n\\n      It doesn't work with :host-context because angular splitting it in two selectors and removes\\n      prefix in one of the selectors.\\n    */\\n.nb-theme-default :host nb-card-body {\\n  padding: 0 0 29px;\\n  display: -webkit-box;\\n  display: -ms-flexbox;\\n  display: flex;\\n  -ms-flex-wrap: wrap;\\n      flex-wrap: wrap;\\n  -webkit-box-pack: justify;\\n      -ms-flex-pack: justify;\\n          justify-content: space-between; }\\n.nb-theme-default :host .shape-container {\\n  margin: 1.25rem 1.25rem 0; }\\n.nb-theme-default :host .container-title {\\n  margin-bottom: 0.25rem; }\\n.nb-theme-default :host .subheader {\\n  margin-bottom: 1rem;\\n  font-size: 0.875rem; }\\n.nb-theme-default :host .subheader span:nth-child(2) {\\n    color: #2a2a2a;\\n    font-weight: 600; }\\n/*\\n      :host can be prefixed\\n      https://github.com/angular/angular/blob/8d0ee34939f14c07876d222c25b405ed458a34d3/packages/compiler/src/shadow_css.ts#L441\\n\\n      We have to use :host insted of :host-context($theme), to be able to prefix theme class\\n      with something defined inside of @content, by prefixing &.\\n      For example this scss code:\\n        .nb-theme-default {\\n          .some-selector & {\\n            ...\\n          }\\n        }\\n      Will result in next css:\\n        .some-selector .nb-theme-default {\\n          ...\\n        }\\n\\n      It doesn't work with :host-context because angular splitting it in two selectors and removes\\n      prefix in one of the selectors.\\n    */\\n.nb-theme-cosmic :host nb-card-body {\\n  padding: 0 0 29px;\\n  display: -webkit-box;\\n  display: -ms-flexbox;\\n  display: flex;\\n  -ms-flex-wrap: wrap;\\n      flex-wrap: wrap;\\n  -webkit-box-pack: justify;\\n      -ms-flex-pack: justify;\\n          justify-content: space-between; }\\n.nb-theme-cosmic :host .shape-container {\\n  margin: 1.25rem 1.25rem 0; }\\n.nb-theme-cosmic :host .container-title {\\n  margin-bottom: 0.25rem; }\\n.nb-theme-cosmic :host .subheader {\\n  margin-bottom: 1rem;\\n  font-size: 0.875rem; }\\n.nb-theme-cosmic :host .subheader span:nth-child(2) {\\n    color: #ffffff;\\n    font-weight: 600; }\\n/*\\n      :host can be prefixed\\n      https://github.com/angular/angular/blob/8d0ee34939f14c07876d222c25b405ed458a34d3/packages/compiler/src/shadow_css.ts#L441\\n\\n      We have to use :host insted of :host-context($theme), to be able to prefix theme class\\n      with something defined inside of @content, by prefixing &.\\n      For example this scss code:\\n        .nb-theme-default {\\n          .some-selector & {\\n            ...\\n          }\\n        }\\n      Will result in next css:\\n        .some-selector .nb-theme-default {\\n          ...\\n        }\\n\\n      It doesn't work with :host-context because angular splitting it in two selectors and removes\\n      prefix in one of the selectors.\\n    */\\n.nb-theme-corporate :host nb-card-body {\\n  padding: 0 0 29px;\\n  display: -webkit-box;\\n  display: -ms-flexbox;\\n  display: flex;\\n  -ms-flex-wrap: wrap;\\n      flex-wrap: wrap;\\n  -webkit-box-pack: justify;\\n      -ms-flex-pack: justify;\\n          justify-content: space-between; }\\n.nb-theme-corporate :host .shape-container {\\n  margin: 1.25rem 1.25rem 0; }\\n.nb-theme-corporate :host .container-title {\\n  margin-bottom: 0.25rem; }\\n.nb-theme-corporate :host .subheader {\\n  margin-bottom: 1rem;\\n  font-size: 0.875rem; }\\n.nb-theme-corporate :host .subheader span:nth-child(2) {\\n    color: #181818;\\n    font-weight: 600; }\\n\"","module.exports = \"<nb-card>\\n  <nb-card-header>Button Shapes</nb-card-header>\\n  <nb-card-body>\\n    <div class=\\\"shape-container\\\">\\n      <div class=\\\"container-title\\\">\\n        <span>Rectangle Button</span>\\n      </div>\\n      <div class=\\\"subheader\\\">\\n        <span>Border radius:</span>\\n        <span>4px</span>\\n      </div>\\n      <div>\\n        <button class=\\\"btn btn-success btn-rectangle btn-demo\\\">Rectangle</button>\\n      </div>\\n    </div>\\n\\n    <div class=\\\"shape-container\\\">\\n      <div class=\\\"container-title\\\">\\n        <span>Semi-round Button</span>\\n      </div>\\n      <div class=\\\"subheader\\\">\\n        <span>Border radius:</span>\\n        <span>12px</span>\\n      </div>\\n      <div>\\n        <button class=\\\"btn btn-success btn-semi-round btn-demo\\\">Semi-round</button>\\n      </div>\\n    </div>\\n\\n    <div class=\\\"shape-container\\\">\\n      <div class=\\\"container-title\\\">\\n        <span>Rounded Button</span>\\n      </div>\\n      <div class=\\\"subheader\\\">\\n        <span>Border radius:</span>\\n        <span>round</span>\\n      </div>\\n      <div>\\n        <button class=\\\"btn btn-success btn-round btn-demo\\\">Round</button>\\n      </div>\\n    </div>\\n  </nb-card-body>\\n</nb-card>\\n\"","module.exports = \"<nb-card>\\n  <nb-card-header>Button Groups</nb-card-header>\\n  <nb-card-body>\\n    <div class=\\\"row\\\">\\n      <div class=\\\"col-md-12\\\">\\n        <div class=\\\"example-container toggle-types\\\">\\n          <div class=\\\"container-title\\\">Toggle Types</div>\\n          <div [(ngModel)]=\\\"radioModel\\\" ngbRadioGroup\\n               class=\\\"btn-group btn-group-toggle btn-outline-toggle-group btn-group-full-width btn-toggle-radio-group\\\">\\n            <label ngbButtonLabel class=\\\"btn btn-outline-primary\\\">\\n              <input ngbButton type=\\\"radio\\\" value=\\\"left\\\"> Left\\n            </label>\\n            <label ngbButtonLabel class=\\\"btn btn-outline-primary\\\">\\n              <input ngbButton type=\\\"radio\\\" value=\\\"middle\\\"> Middle\\n            </label>\\n            <label ngbButtonLabel class=\\\"btn btn-outline-primary\\\">\\n              <input ngbButton type=\\\"radio\\\" value=\\\"right\\\"> Right\\n            </label>\\n          </div>\\n          <div class=\\\"btn-group btn-group-toggle btn-group-full-width\\\" data-toggle=\\\"buttons\\\">\\n            <label ngbButtonLabel class=\\\"btn btn-primary\\\" [class.active]=\\\"checkboxModel.left\\\">\\n              <input ngbButton type=\\\"checkbox\\\" [(ngModel)]=\\\"checkboxModel.left\\\"> Left\\n            </label>\\n            <label ngbButtonLabel class=\\\"btn btn-primary\\\" [class.active]=\\\"checkboxModel.middle\\\">\\n              <input ngbButton type=\\\"checkbox\\\" [(ngModel)]=\\\"checkboxModel.middle\\\"> Middle\\n            </label>\\n            <label ngbButtonLabel class=\\\"btn btn-primary\\\" [class.active]=\\\"checkboxModel.right\\\">\\n              <input ngbButton type=\\\"checkbox\\\" [(ngModel)]=\\\"checkboxModel.right\\\"> Right\\n            </label>\\n          </div>\\n        </div>\\n        <div class=\\\"example-container toolbars-container\\\">\\n          <div class=\\\"pagination-container\\\">\\n            <div class=\\\"container-title\\\">Pagination</div>\\n            <div class=\\\"btn-group btn-group-toggle btn-outline-toggle-group\\\" data-toggle=\\\"buttons\\\"\\n                 [(ngModel)]=\\\"paginationModel\\\" ngbRadioGroup>\\n              <label ngbButtonLabel class=\\\"btn btn-outline-success\\\">\\n                <input ngbButton type=\\\"radio\\\" [value]=\\\"1\\\"> 1\\n              </label>\\n              <label ngbButtonLabel class=\\\"btn btn-outline-success\\\">\\n                <input ngbButton type=\\\"radio\\\" [value]=\\\"2\\\"> 2\\n              </label>\\n              <label ngbButtonLabel class=\\\"btn btn-outline-success\\\">\\n                <input ngbButton type=\\\"radio\\\" [value]=\\\"3\\\"> 3\\n              </label>\\n              <label ngbButtonLabel class=\\\"btn btn-outline-success\\\">\\n                <input ngbButton type=\\\"radio\\\" [value]=\\\"4\\\"> 4\\n              </label>\\n              <label ngbButtonLabel class=\\\"btn btn-outline-success\\\">\\n                <input ngbButton type=\\\"radio\\\" [value]=\\\"5\\\"> 5\\n              </label>\\n            </div>\\n          </div>\\n\\n          <div class=\\\"icon-toolbar-container\\\">\\n            <div class=\\\"container-title\\\">Icon Toolbar</div>\\n            <div class=\\\"btn-group btn-group-toggle\\\" data-toggle=\\\"buttons\\\">\\n              <label ngbButtonLabel class=\\\"btn btn-success\\\" [class.active]=\\\"iconToolbarModel.one\\\">\\n                <input ngbButton type=\\\"checkbox\\\" [(ngModel)]=\\\"iconToolbarModel.one\\\"> 1\\n              </label>\\n              <label ngbButtonLabel class=\\\"btn btn-success\\\" [class.active]=\\\"iconToolbarModel.two\\\">\\n                <input ngbButton type=\\\"checkbox\\\" [(ngModel)]=\\\"iconToolbarModel.two\\\"> 2\\n              </label>\\n              <label ngbButtonLabel class=\\\"btn btn-success\\\" [class.active]=\\\"iconToolbarModel.three\\\">\\n                <input ngbButton type=\\\"checkbox\\\" [(ngModel)]=\\\"iconToolbarModel.three\\\"> 3\\n              </label>\\n              <label ngbButtonLabel class=\\\"btn btn-success\\\" [class.active]=\\\"iconToolbarModel.four\\\">\\n                <input ngbButton type=\\\"checkbox\\\" [(ngModel)]=\\\"iconToolbarModel.four\\\"> 4\\n              </label>\\n              <label ngbButtonLabel class=\\\"btn btn-success\\\" [class.active]=\\\"iconToolbarModel.five\\\">\\n                <input ngbButton type=\\\"checkbox\\\" [(ngModel)]=\\\"iconToolbarModel.five\\\"> 5\\n              </label>\\n            </div>\\n          </div>\\n        </div>\\n        <div class=\\\"example-container\\\">\\n          <div class=\\\"container-title divided-button-group\\\">Divided Button Group</div>\\n          <div class=\\\"btn-group btn-group-toggle btn-divided-group btn-outline-divided-group btn-group-full-width btn-divided-checkbox-group \\\"\\n            data-toggle=\\\"buttons\\\">\\n            <label ngbButtonLabel class=\\\"btn btn-outline-success btn-icon\\\" [class.active]=\\\"dividedCheckboxModel.monday\\\">\\n              <input ngbButton type=\\\"checkbox\\\" [(ngModel)]=\\\"dividedCheckboxModel.monday\\\"> <i\\n              class=\\\"nb-arrow-thin-down\\\"></i>\\n            </label>\\n            <label ngbButtonLabel class=\\\"btn btn-outline-success btn-icon\\\" [class.active]=\\\"dividedCheckboxModel.tuesday\\\">\\n              <input ngbButton type=\\\"checkbox\\\" [(ngModel)]=\\\"dividedCheckboxModel.tuesday\\\"> <i\\n              class=\\\"nb-arrow-thin-up\\\"></i>\\n            </label>\\n            <label ngbButtonLabel class=\\\"btn btn-outline-success btn-icon\\\" [class.active]=\\\"dividedCheckboxModel.wednesday\\\">\\n              <input ngbButton type=\\\"checkbox\\\" [(ngModel)]=\\\"dividedCheckboxModel.wednesday\\\"> <i class=\\\"nb-arrow-thin-left\\\"></i>\\n            </label>\\n            <label ngbButtonLabel class=\\\"btn btn-outline-success btn-icon\\\" [class.active]=\\\"dividedCheckboxModel.thursday\\\">\\n              <input ngbButton type=\\\"checkbox\\\" [(ngModel)]=\\\"dividedCheckboxModel.thursday\\\"> <i\\n              class=\\\"nb-arrow-thin-right\\\"></i>\\n            </label>\\n            <label ngbButtonLabel class=\\\"btn btn-outline-success btn-icon\\\" [class.active]=\\\"dividedCheckboxModel.friday\\\">\\n              <input ngbButton type=\\\"checkbox\\\" [(ngModel)]=\\\"dividedCheckboxModel.friday\\\"> <i class=\\\"nb-arrow-left\\\"></i>\\n            </label>\\n            <label ngbButtonLabel class=\\\"btn btn-outline-success btn-icon\\\" [class.active]=\\\"dividedCheckboxModel.saturday\\\">\\n              <input ngbButton type=\\\"checkbox\\\" [(ngModel)]=\\\"dividedCheckboxModel.saturday\\\"> <i\\n              class=\\\"nb-arrow-right\\\"></i>\\n            </label>\\n          </div>\\n        </div>\\n        <div class=\\\"example-container\\\">\\n          <div class=\\\"container-title\\\">Divided Button Group</div>\\n          <div class=\\\"row\\\">\\n            <div [(ngModel)]=\\\"dividedButtonGroupOne\\\" ngbRadioGroup\\n                 class=\\\"btn-group btn-group-toggle btn-divided-group btn-outline-divided-group btn-group-full-width col-md-12\\\">\\n              <label ngbButtonLabel class=\\\"btn btn-outline-primary\\\">\\n                <input ngbButton type=\\\"radio\\\" value=\\\"left\\\"> Left\\n              </label>\\n              <label ngbButtonLabel class=\\\"btn btn-outline-primary\\\">\\n                <input ngbButton type=\\\"radio\\\" value=\\\"middle\\\"> Middle\\n              </label>\\n              <label ngbButtonLabel class=\\\"btn btn-outline-primary\\\">\\n                <input ngbButton type=\\\"radio\\\" value=\\\"right\\\"> Right\\n              </label>\\n            </div>\\n          </div>\\n          <div class=\\\"btn-group btn-group-toggle btn-divided-group btn-group-full-width\\\" data-toggle=\\\"buttons\\\">\\n            <label ngbButtonLabel\\n                   class=\\\"btn btn-primary\\\"\\n                   [class.active]=\\\"dividedButtonGroupTwo.left\\\"\\n                   [class.focus]=\\\"dividedButtonGroupTwo.left\\\">\\n              <input ngbButton type=\\\"checkbox\\\" [(ngModel)]=\\\"dividedButtonGroupTwo.left\\\"> Left\\n            </label>\\n            <label ngbButtonLabel\\n                   class=\\\"btn btn-primary\\\"\\n                   [class.active]=\\\"dividedButtonGroupTwo.middle\\\"\\n                   [class.focus]=\\\"dividedButtonGroupTwo.middle\\\">\\n              <input ngbButton type=\\\"checkbox\\\" [(ngModel)]=\\\"dividedButtonGroupTwo.middle\\\"> Middle\\n            </label>\\n            <label ngbButtonLabel\\n                   class=\\\"btn btn-primary\\\"\\n                   [class.active]=\\\"dividedButtonGroupTwo.right\\\"\\n                   [class.focus]=\\\"dividedButtonGroupTwo.right\\\">\\n              <input ngbButton type=\\\"checkbox\\\" [(ngModel)]=\\\"dividedButtonGroupTwo.right\\\"> Right\\n            </label>\\n          </div>\\n        </div>\\n      </div>\\n    </div>\\n  </nb-card-body>\\n</nb-card>\\n\"","module.exports = \"/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/**\\n * This is a starting point where we declare the maps of themes and globally available functions/mixins\\n */\\n/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/**\\n * This mixin generates keyfames.\\n * Because of all keyframes can't be scoped,\\n * we need to puts unique name in each btn-pulse call.\\n */\\n/*\\n\\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\\n:host and :host-context are pseudo-classes. So we assume they could be combined,\\nlike other pseudo-classes, even same ones.\\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\\n\\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\\nso direction could be overridden on any component level.\\n\\nImplementation code:\\n\\n@mixin nb-rtl() {\\n  // add # to scss interpolation statement.\\n  // it works in comments and we can't use it here\\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\\n    @content;\\n  }\\n}\\n\\nAnd when we call it somewhere:\\n\\n:host {\\n  .some-class {\\n    @include nb-rtl() {\\n      ...\\n    }\\n  }\\n}\\n:host-context(...) {\\n  .some-class {\\n    @include nb-rtl() {\\n      ...\\n    }\\n  }\\n}\\n\\nResult will look like:\\n\\n:host-context([dir=rtl]):host .some-class {\\n  ...\\n}\\n:host-context([dir=rtl]):host-context(...) .some-class {\\n  ...\\n}\\n\\n*\\n  Side note:\\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\\n\\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\\n  so order is not important.\\n*\\n\\n\\nCurrently, there're two problems with this approach:\\n\\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\\nFor the moment of writing, the only possible way is:\\n:host {\\n  :host-context(...) {\\n    ...\\n  }\\n}\\nIt doesn't work for us because mixin could be called somewhere deeper, like:\\n:host {\\n  p {\\n    @include nb-rtl() { ... }\\n  }\\n}\\nWe are not able to go up to :host level to place content passed to mixin.\\n\\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\\n  *\\n    Side note:\\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\\n    :host-context($theme) once we will be able to use multiple shadow selectors.\\n  *\\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\\n  ***\\n    Possible solution\\n    check if we in theme by some theme variables and if so append, otherwise nest like\\n    @at-root :host-context([dir=rtl]) {\\n      // add # to scss interpolation statement.\\n      // it works in comments and we can't use it here\\n      {&} {\\n        @content;\\n      }\\n    }\\n    What if :host specified? Can we add space in :host-context(...) :host?\\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\\n  ***\\n\\n\\nProblems with the current approach.\\n\\n1. Direction can be applied only on document level, because mixin prepends theme class,\\nwhich placed on the body.\\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\\nattribute to [dir=rtl] attribute as well.\\n\\n\\nGeneral problems.\\n\\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\\n*/\\n/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/**\\n * This mixin generates keyfames.\\n * Because of all keyframes can't be scoped,\\n * we need to puts unique name in each btn-pulse call.\\n */\\n/*\\n\\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\\n:host and :host-context are pseudo-classes. So we assume they could be combined,\\nlike other pseudo-classes, even same ones.\\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\\n\\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\\nso direction could be overridden on any component level.\\n\\nImplementation code:\\n\\n@mixin nb-rtl() {\\n  // add # to scss interpolation statement.\\n  // it works in comments and we can't use it here\\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\\n    @content;\\n  }\\n}\\n\\nAnd when we call it somewhere:\\n\\n:host {\\n  .some-class {\\n    @include nb-rtl() {\\n      ...\\n    }\\n  }\\n}\\n:host-context(...) {\\n  .some-class {\\n    @include nb-rtl() {\\n      ...\\n    }\\n  }\\n}\\n\\nResult will look like:\\n\\n:host-context([dir=rtl]):host .some-class {\\n  ...\\n}\\n:host-context([dir=rtl]):host-context(...) .some-class {\\n  ...\\n}\\n\\n*\\n  Side note:\\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\\n\\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\\n  so order is not important.\\n*\\n\\n\\nCurrently, there're two problems with this approach:\\n\\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\\nFor the moment of writing, the only possible way is:\\n:host {\\n  :host-context(...) {\\n    ...\\n  }\\n}\\nIt doesn't work for us because mixin could be called somewhere deeper, like:\\n:host {\\n  p {\\n    @include nb-rtl() { ... }\\n  }\\n}\\nWe are not able to go up to :host level to place content passed to mixin.\\n\\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\\n  *\\n    Side note:\\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\\n    :host-context($theme) once we will be able to use multiple shadow selectors.\\n  *\\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\\n  ***\\n    Possible solution\\n    check if we in theme by some theme variables and if so append, otherwise nest like\\n    @at-root :host-context([dir=rtl]) {\\n      // add # to scss interpolation statement.\\n      // it works in comments and we can't use it here\\n      {&} {\\n        @content;\\n      }\\n    }\\n    What if :host specified? Can we add space in :host-context(...) :host?\\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\\n  ***\\n\\n\\nProblems with the current approach.\\n\\n1. Direction can be applied only on document level, because mixin prepends theme class,\\nwhich placed on the body.\\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\\nattribute to [dir=rtl] attribute as well.\\n\\n\\nGeneral problems.\\n\\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\\n*/\\n/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/**\\n * This mixin generates keyfames.\\n * Because of all keyframes can't be scoped,\\n * we need to puts unique name in each btn-pulse call.\\n */\\n/*\\n\\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\\n:host and :host-context are pseudo-classes. So we assume they could be combined,\\nlike other pseudo-classes, even same ones.\\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\\n\\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\\nso direction could be overridden on any component level.\\n\\nImplementation code:\\n\\n@mixin nb-rtl() {\\n  // add # to scss interpolation statement.\\n  // it works in comments and we can't use it here\\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\\n    @content;\\n  }\\n}\\n\\nAnd when we call it somewhere:\\n\\n:host {\\n  .some-class {\\n    @include nb-rtl() {\\n      ...\\n    }\\n  }\\n}\\n:host-context(...) {\\n  .some-class {\\n    @include nb-rtl() {\\n      ...\\n    }\\n  }\\n}\\n\\nResult will look like:\\n\\n:host-context([dir=rtl]):host .some-class {\\n  ...\\n}\\n:host-context([dir=rtl]):host-context(...) .some-class {\\n  ...\\n}\\n\\n*\\n  Side note:\\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\\n\\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\\n  so order is not important.\\n*\\n\\n\\nCurrently, there're two problems with this approach:\\n\\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\\nFor the moment of writing, the only possible way is:\\n:host {\\n  :host-context(...) {\\n    ...\\n  }\\n}\\nIt doesn't work for us because mixin could be called somewhere deeper, like:\\n:host {\\n  p {\\n    @include nb-rtl() { ... }\\n  }\\n}\\nWe are not able to go up to :host level to place content passed to mixin.\\n\\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\\n  *\\n    Side note:\\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\\n    :host-context($theme) once we will be able to use multiple shadow selectors.\\n  *\\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\\n  ***\\n    Possible solution\\n    check if we in theme by some theme variables and if so append, otherwise nest like\\n    @at-root :host-context([dir=rtl]) {\\n      // add # to scss interpolation statement.\\n      // it works in comments and we can't use it here\\n      {&} {\\n        @content;\\n      }\\n    }\\n    What if :host specified? Can we add space in :host-context(...) :host?\\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\\n  ***\\n\\n\\nProblems with the current approach.\\n\\n1. Direction can be applied only on document level, because mixin prepends theme class,\\nwhich placed on the body.\\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\\nattribute to [dir=rtl] attribute as well.\\n\\n\\nGeneral problems.\\n\\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\\n*/\\n/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/**\\n * This mixin generates keyfames.\\n * Because of all keyframes can't be scoped,\\n * we need to puts unique name in each btn-pulse call.\\n */\\n/*\\n\\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\\n:host and :host-context are pseudo-classes. So we assume they could be combined,\\nlike other pseudo-classes, even same ones.\\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\\n\\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\\nso direction could be overridden on any component level.\\n\\nImplementation code:\\n\\n@mixin nb-rtl() {\\n  // add # to scss interpolation statement.\\n  // it works in comments and we can't use it here\\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\\n    @content;\\n  }\\n}\\n\\nAnd when we call it somewhere:\\n\\n:host {\\n  .some-class {\\n    @include nb-rtl() {\\n      ...\\n    }\\n  }\\n}\\n:host-context(...) {\\n  .some-class {\\n    @include nb-rtl() {\\n      ...\\n    }\\n  }\\n}\\n\\nResult will look like:\\n\\n:host-context([dir=rtl]):host .some-class {\\n  ...\\n}\\n:host-context([dir=rtl]):host-context(...) .some-class {\\n  ...\\n}\\n\\n*\\n  Side note:\\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\\n\\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\\n  so order is not important.\\n*\\n\\n\\nCurrently, there're two problems with this approach:\\n\\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\\nFor the moment of writing, the only possible way is:\\n:host {\\n  :host-context(...) {\\n    ...\\n  }\\n}\\nIt doesn't work for us because mixin could be called somewhere deeper, like:\\n:host {\\n  p {\\n    @include nb-rtl() { ... }\\n  }\\n}\\nWe are not able to go up to :host level to place content passed to mixin.\\n\\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\\n  *\\n    Side note:\\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\\n    :host-context($theme) once we will be able to use multiple shadow selectors.\\n  *\\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\\n  ***\\n    Possible solution\\n    check if we in theme by some theme variables and if so append, otherwise nest like\\n    @at-root :host-context([dir=rtl]) {\\n      // add # to scss interpolation statement.\\n      // it works in comments and we can't use it here\\n      {&} {\\n        @content;\\n      }\\n    }\\n    What if :host specified? Can we add space in :host-context(...) :host?\\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\\n  ***\\n\\n\\nProblems with the current approach.\\n\\n1. Direction can be applied only on document level, because mixin prepends theme class,\\nwhich placed on the body.\\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\\nattribute to [dir=rtl] attribute as well.\\n\\n\\nGeneral problems.\\n\\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\\n*/\\n/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/**\\n * This mixin generates keyfames.\\n * Because of all keyframes can't be scoped,\\n * we need to puts unique name in each btn-pulse call.\\n */\\n/*\\n\\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\\n:host and :host-context are pseudo-classes. So we assume they could be combined,\\nlike other pseudo-classes, even same ones.\\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\\n\\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\\nso direction could be overridden on any component level.\\n\\nImplementation code:\\n\\n@mixin nb-rtl() {\\n  // add # to scss interpolation statement.\\n  // it works in comments and we can't use it here\\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\\n    @content;\\n  }\\n}\\n\\nAnd when we call it somewhere:\\n\\n:host {\\n  .some-class {\\n    @include nb-rtl() {\\n      ...\\n    }\\n  }\\n}\\n:host-context(...) {\\n  .some-class {\\n    @include nb-rtl() {\\n      ...\\n    }\\n  }\\n}\\n\\nResult will look like:\\n\\n:host-context([dir=rtl]):host .some-class {\\n  ...\\n}\\n:host-context([dir=rtl]):host-context(...) .some-class {\\n  ...\\n}\\n\\n*\\n  Side note:\\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\\n\\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\\n  so order is not important.\\n*\\n\\n\\nCurrently, there're two problems with this approach:\\n\\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\\nFor the moment of writing, the only possible way is:\\n:host {\\n  :host-context(...) {\\n    ...\\n  }\\n}\\nIt doesn't work for us because mixin could be called somewhere deeper, like:\\n:host {\\n  p {\\n    @include nb-rtl() { ... }\\n  }\\n}\\nWe are not able to go up to :host level to place content passed to mixin.\\n\\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\\n  *\\n    Side note:\\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\\n    :host-context($theme) once we will be able to use multiple shadow selectors.\\n  *\\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\\n  ***\\n    Possible solution\\n    check if we in theme by some theme variables and if so append, otherwise nest like\\n    @at-root :host-context([dir=rtl]) {\\n      // add # to scss interpolation statement.\\n      // it works in comments and we can't use it here\\n      {&} {\\n        @content;\\n      }\\n    }\\n    What if :host specified? Can we add space in :host-context(...) :host?\\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\\n  ***\\n\\n\\nProblems with the current approach.\\n\\n1. Direction can be applied only on document level, because mixin prepends theme class,\\nwhich placed on the body.\\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\\nattribute to [dir=rtl] attribute as well.\\n\\n\\nGeneral problems.\\n\\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\\n*/\\n/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/**\\n * This mixin generates keyfames.\\n * Because of all keyframes can't be scoped,\\n * we need to puts unique name in each btn-pulse call.\\n */\\n/*\\n\\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\\n:host and :host-context are pseudo-classes. So we assume they could be combined,\\nlike other pseudo-classes, even same ones.\\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\\n\\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\\nso direction could be overridden on any component level.\\n\\nImplementation code:\\n\\n@mixin nb-rtl() {\\n  // add # to scss interpolation statement.\\n  // it works in comments and we can't use it here\\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\\n    @content;\\n  }\\n}\\n\\nAnd when we call it somewhere:\\n\\n:host {\\n  .some-class {\\n    @include nb-rtl() {\\n      ...\\n    }\\n  }\\n}\\n:host-context(...) {\\n  .some-class {\\n    @include nb-rtl() {\\n      ...\\n    }\\n  }\\n}\\n\\nResult will look like:\\n\\n:host-context([dir=rtl]):host .some-class {\\n  ...\\n}\\n:host-context([dir=rtl]):host-context(...) .some-class {\\n  ...\\n}\\n\\n*\\n  Side note:\\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\\n\\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\\n  so order is not important.\\n*\\n\\n\\nCurrently, there're two problems with this approach:\\n\\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\\nFor the moment of writing, the only possible way is:\\n:host {\\n  :host-context(...) {\\n    ...\\n  }\\n}\\nIt doesn't work for us because mixin could be called somewhere deeper, like:\\n:host {\\n  p {\\n    @include nb-rtl() { ... }\\n  }\\n}\\nWe are not able to go up to :host level to place content passed to mixin.\\n\\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\\n  *\\n    Side note:\\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\\n    :host-context($theme) once we will be able to use multiple shadow selectors.\\n  *\\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\\n  ***\\n    Possible solution\\n    check if we in theme by some theme variables and if so append, otherwise nest like\\n    @at-root :host-context([dir=rtl]) {\\n      // add # to scss interpolation statement.\\n      // it works in comments and we can't use it here\\n      {&} {\\n        @content;\\n      }\\n    }\\n    What if :host specified? Can we add space in :host-context(...) :host?\\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\\n  ***\\n\\n\\nProblems with the current approach.\\n\\n1. Direction can be applied only on document level, because mixin prepends theme class,\\nwhich placed on the body.\\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\\nattribute to [dir=rtl] attribute as well.\\n\\n\\nGeneral problems.\\n\\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\\n*/\\n/*\\n      :host can be prefixed\\n      https://github.com/angular/angular/blob/8d0ee34939f14c07876d222c25b405ed458a34d3/packages/compiler/src/shadow_css.ts#L441\\n\\n      We have to use :host insted of :host-context($theme), to be able to prefix theme class\\n      with something defined inside of @content, by prefixing &.\\n      For example this scss code:\\n        .nb-theme-default {\\n          .some-selector & {\\n            ...\\n          }\\n        }\\n      Will result in next css:\\n        .some-selector .nb-theme-default {\\n          ...\\n        }\\n\\n      It doesn't work with :host-context because angular splitting it in two selectors and removes\\n      prefix in one of the selectors.\\n    */\\n.nb-theme-default :host {\\n  text-align: center; }\\n.nb-theme-default :host .dropdown,\\n  .nb-theme-default :host .dropup,\\n  .nb-theme-default :host .btn-group {\\n    margin-bottom: 1rem; }\\n.nb-theme-default :host nb-card-body {\\n    overflow: visible; }\\n/*\\n      :host can be prefixed\\n      https://github.com/angular/angular/blob/8d0ee34939f14c07876d222c25b405ed458a34d3/packages/compiler/src/shadow_css.ts#L441\\n\\n      We have to use :host insted of :host-context($theme), to be able to prefix theme class\\n      with something defined inside of @content, by prefixing &.\\n      For example this scss code:\\n        .nb-theme-default {\\n          .some-selector & {\\n            ...\\n          }\\n        }\\n      Will result in next css:\\n        .some-selector .nb-theme-default {\\n          ...\\n        }\\n\\n      It doesn't work with :host-context because angular splitting it in two selectors and removes\\n      prefix in one of the selectors.\\n    */\\n.nb-theme-cosmic :host {\\n  text-align: center; }\\n.nb-theme-cosmic :host .dropdown,\\n  .nb-theme-cosmic :host .dropup,\\n  .nb-theme-cosmic :host .btn-group {\\n    margin-bottom: 1rem; }\\n.nb-theme-cosmic :host nb-card-body {\\n    overflow: visible; }\\n/*\\n      :host can be prefixed\\n      https://github.com/angular/angular/blob/8d0ee34939f14c07876d222c25b405ed458a34d3/packages/compiler/src/shadow_css.ts#L441\\n\\n      We have to use :host insted of :host-context($theme), to be able to prefix theme class\\n      with something defined inside of @content, by prefixing &.\\n      For example this scss code:\\n        .nb-theme-default {\\n          .some-selector & {\\n            ...\\n          }\\n        }\\n      Will result in next css:\\n        .some-selector .nb-theme-default {\\n          ...\\n        }\\n\\n      It doesn't work with :host-context because angular splitting it in two selectors and removes\\n      prefix in one of the selectors.\\n    */\\n.nb-theme-corporate :host {\\n  text-align: center; }\\n.nb-theme-corporate :host .dropdown,\\n  .nb-theme-corporate :host .dropup,\\n  .nb-theme-corporate :host .btn-group {\\n    margin-bottom: 1rem; }\\n.nb-theme-corporate :host nb-card-body {\\n    overflow: visible; }\\n\"","module.exports = \"/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/**\\n * This is a starting point where we declare the maps of themes and globally available functions/mixins\\n */\\n/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/**\\n * This mixin generates keyfames.\\n * Because of all keyframes can't be scoped,\\n * we need to puts unique name in each btn-pulse call.\\n */\\n/*\\n\\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\\n:host and :host-context are pseudo-classes. So we assume they could be combined,\\nlike other pseudo-classes, even same ones.\\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\\n\\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\\nso direction could be overridden on any component level.\\n\\nImplementation code:\\n\\n@mixin nb-rtl() {\\n  // add # to scss interpolation statement.\\n  // it works in comments and we can't use it here\\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\\n    @content;\\n  }\\n}\\n\\nAnd when we call it somewhere:\\n\\n:host {\\n  .some-class {\\n    @include nb-rtl() {\\n      ...\\n    }\\n  }\\n}\\n:host-context(...) {\\n  .some-class {\\n    @include nb-rtl() {\\n      ...\\n    }\\n  }\\n}\\n\\nResult will look like:\\n\\n:host-context([dir=rtl]):host .some-class {\\n  ...\\n}\\n:host-context([dir=rtl]):host-context(...) .some-class {\\n  ...\\n}\\n\\n*\\n  Side note:\\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\\n\\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\\n  so order is not important.\\n*\\n\\n\\nCurrently, there're two problems with this approach:\\n\\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\\nFor the moment of writing, the only possible way is:\\n:host {\\n  :host-context(...) {\\n    ...\\n  }\\n}\\nIt doesn't work for us because mixin could be called somewhere deeper, like:\\n:host {\\n  p {\\n    @include nb-rtl() { ... }\\n  }\\n}\\nWe are not able to go up to :host level to place content passed to mixin.\\n\\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\\n  *\\n    Side note:\\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\\n    :host-context($theme) once we will be able to use multiple shadow selectors.\\n  *\\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\\n  ***\\n    Possible solution\\n    check if we in theme by some theme variables and if so append, otherwise nest like\\n    @at-root :host-context([dir=rtl]) {\\n      // add # to scss interpolation statement.\\n      // it works in comments and we can't use it here\\n      {&} {\\n        @content;\\n      }\\n    }\\n    What if :host specified? Can we add space in :host-context(...) :host?\\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\\n  ***\\n\\n\\nProblems with the current approach.\\n\\n1. Direction can be applied only on document level, because mixin prepends theme class,\\nwhich placed on the body.\\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\\nattribute to [dir=rtl] attribute as well.\\n\\n\\nGeneral problems.\\n\\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\\n*/\\n/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/**\\n * This mixin generates keyfames.\\n * Because of all keyframes can't be scoped,\\n * we need to puts unique name in each btn-pulse call.\\n */\\n/*\\n\\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\\n:host and :host-context are pseudo-classes. So we assume they could be combined,\\nlike other pseudo-classes, even same ones.\\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\\n\\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\\nso direction could be overridden on any component level.\\n\\nImplementation code:\\n\\n@mixin nb-rtl() {\\n  // add # to scss interpolation statement.\\n  // it works in comments and we can't use it here\\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\\n    @content;\\n  }\\n}\\n\\nAnd when we call it somewhere:\\n\\n:host {\\n  .some-class {\\n    @include nb-rtl() {\\n      ...\\n    }\\n  }\\n}\\n:host-context(...) {\\n  .some-class {\\n    @include nb-rtl() {\\n      ...\\n    }\\n  }\\n}\\n\\nResult will look like:\\n\\n:host-context([dir=rtl]):host .some-class {\\n  ...\\n}\\n:host-context([dir=rtl]):host-context(...) .some-class {\\n  ...\\n}\\n\\n*\\n  Side note:\\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\\n\\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\\n  so order is not important.\\n*\\n\\n\\nCurrently, there're two problems with this approach:\\n\\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\\nFor the moment of writing, the only possible way is:\\n:host {\\n  :host-context(...) {\\n    ...\\n  }\\n}\\nIt doesn't work for us because mixin could be called somewhere deeper, like:\\n:host {\\n  p {\\n    @include nb-rtl() { ... }\\n  }\\n}\\nWe are not able to go up to :host level to place content passed to mixin.\\n\\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\\n  *\\n    Side note:\\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\\n    :host-context($theme) once we will be able to use multiple shadow selectors.\\n  *\\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\\n  ***\\n    Possible solution\\n    check if we in theme by some theme variables and if so append, otherwise nest like\\n    @at-root :host-context([dir=rtl]) {\\n      // add # to scss interpolation statement.\\n      // it works in comments and we can't use it here\\n      {&} {\\n        @content;\\n      }\\n    }\\n    What if :host specified? Can we add space in :host-context(...) :host?\\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\\n  ***\\n\\n\\nProblems with the current approach.\\n\\n1. Direction can be applied only on document level, because mixin prepends theme class,\\nwhich placed on the body.\\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\\nattribute to [dir=rtl] attribute as well.\\n\\n\\nGeneral problems.\\n\\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\\n*/\\n/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/**\\n * This mixin generates keyfames.\\n * Because of all keyframes can't be scoped,\\n * we need to puts unique name in each btn-pulse call.\\n */\\n/*\\n\\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\\n:host and :host-context are pseudo-classes. So we assume they could be combined,\\nlike other pseudo-classes, even same ones.\\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\\n\\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\\nso direction could be overridden on any component level.\\n\\nImplementation code:\\n\\n@mixin nb-rtl() {\\n  // add # to scss interpolation statement.\\n  // it works in comments and we can't use it here\\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\\n    @content;\\n  }\\n}\\n\\nAnd when we call it somewhere:\\n\\n:host {\\n  .some-class {\\n    @include nb-rtl() {\\n      ...\\n    }\\n  }\\n}\\n:host-context(...) {\\n  .some-class {\\n    @include nb-rtl() {\\n      ...\\n    }\\n  }\\n}\\n\\nResult will look like:\\n\\n:host-context([dir=rtl]):host .some-class {\\n  ...\\n}\\n:host-context([dir=rtl]):host-context(...) .some-class {\\n  ...\\n}\\n\\n*\\n  Side note:\\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\\n\\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\\n  so order is not important.\\n*\\n\\n\\nCurrently, there're two problems with this approach:\\n\\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\\nFor the moment of writing, the only possible way is:\\n:host {\\n  :host-context(...) {\\n    ...\\n  }\\n}\\nIt doesn't work for us because mixin could be called somewhere deeper, like:\\n:host {\\n  p {\\n    @include nb-rtl() { ... }\\n  }\\n}\\nWe are not able to go up to :host level to place content passed to mixin.\\n\\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\\n  *\\n    Side note:\\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\\n    :host-context($theme) once we will be able to use multiple shadow selectors.\\n  *\\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\\n  ***\\n    Possible solution\\n    check if we in theme by some theme variables and if so append, otherwise nest like\\n    @at-root :host-context([dir=rtl]) {\\n      // add # to scss interpolation statement.\\n      // it works in comments and we can't use it here\\n      {&} {\\n        @content;\\n      }\\n    }\\n    What if :host specified? Can we add space in :host-context(...) :host?\\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\\n  ***\\n\\n\\nProblems with the current approach.\\n\\n1. Direction can be applied only on document level, because mixin prepends theme class,\\nwhich placed on the body.\\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\\nattribute to [dir=rtl] attribute as well.\\n\\n\\nGeneral problems.\\n\\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\\n*/\\n/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/**\\n * This mixin generates keyfames.\\n * Because of all keyframes can't be scoped,\\n * we need to puts unique name in each btn-pulse call.\\n */\\n/*\\n\\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\\n:host and :host-context are pseudo-classes. So we assume they could be combined,\\nlike other pseudo-classes, even same ones.\\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\\n\\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\\nso direction could be overridden on any component level.\\n\\nImplementation code:\\n\\n@mixin nb-rtl() {\\n  // add # to scss interpolation statement.\\n  // it works in comments and we can't use it here\\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\\n    @content;\\n  }\\n}\\n\\nAnd when we call it somewhere:\\n\\n:host {\\n  .some-class {\\n    @include nb-rtl() {\\n      ...\\n    }\\n  }\\n}\\n:host-context(...) {\\n  .some-class {\\n    @include nb-rtl() {\\n      ...\\n    }\\n  }\\n}\\n\\nResult will look like:\\n\\n:host-context([dir=rtl]):host .some-class {\\n  ...\\n}\\n:host-context([dir=rtl]):host-context(...) .some-class {\\n  ...\\n}\\n\\n*\\n  Side note:\\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\\n\\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\\n  so order is not important.\\n*\\n\\n\\nCurrently, there're two problems with this approach:\\n\\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\\nFor the moment of writing, the only possible way is:\\n:host {\\n  :host-context(...) {\\n    ...\\n  }\\n}\\nIt doesn't work for us because mixin could be called somewhere deeper, like:\\n:host {\\n  p {\\n    @include nb-rtl() { ... }\\n  }\\n}\\nWe are not able to go up to :host level to place content passed to mixin.\\n\\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\\n  *\\n    Side note:\\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\\n    :host-context($theme) once we will be able to use multiple shadow selectors.\\n  *\\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\\n  ***\\n    Possible solution\\n    check if we in theme by some theme variables and if so append, otherwise nest like\\n    @at-root :host-context([dir=rtl]) {\\n      // add # to scss interpolation statement.\\n      // it works in comments and we can't use it here\\n      {&} {\\n        @content;\\n      }\\n    }\\n    What if :host specified? Can we add space in :host-context(...) :host?\\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\\n  ***\\n\\n\\nProblems with the current approach.\\n\\n1. Direction can be applied only on document level, because mixin prepends theme class,\\nwhich placed on the body.\\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\\nattribute to [dir=rtl] attribute as well.\\n\\n\\nGeneral problems.\\n\\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\\n*/\\n/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/**\\n * This mixin generates keyfames.\\n * Because of all keyframes can't be scoped,\\n * we need to puts unique name in each btn-pulse call.\\n */\\n/*\\n\\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\\n:host and :host-context are pseudo-classes. So we assume they could be combined,\\nlike other pseudo-classes, even same ones.\\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\\n\\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\\nso direction could be overridden on any component level.\\n\\nImplementation code:\\n\\n@mixin nb-rtl() {\\n  // add # to scss interpolation statement.\\n  // it works in comments and we can't use it here\\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\\n    @content;\\n  }\\n}\\n\\nAnd when we call it somewhere:\\n\\n:host {\\n  .some-class {\\n    @include nb-rtl() {\\n      ...\\n    }\\n  }\\n}\\n:host-context(...) {\\n  .some-class {\\n    @include nb-rtl() {\\n      ...\\n    }\\n  }\\n}\\n\\nResult will look like:\\n\\n:host-context([dir=rtl]):host .some-class {\\n  ...\\n}\\n:host-context([dir=rtl]):host-context(...) .some-class {\\n  ...\\n}\\n\\n*\\n  Side note:\\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\\n\\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\\n  so order is not important.\\n*\\n\\n\\nCurrently, there're two problems with this approach:\\n\\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\\nFor the moment of writing, the only possible way is:\\n:host {\\n  :host-context(...) {\\n    ...\\n  }\\n}\\nIt doesn't work for us because mixin could be called somewhere deeper, like:\\n:host {\\n  p {\\n    @include nb-rtl() { ... }\\n  }\\n}\\nWe are not able to go up to :host level to place content passed to mixin.\\n\\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\\n  *\\n    Side note:\\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\\n    :host-context($theme) once we will be able to use multiple shadow selectors.\\n  *\\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\\n  ***\\n    Possible solution\\n    check if we in theme by some theme variables and if so append, otherwise nest like\\n    @at-root :host-context([dir=rtl]) {\\n      // add # to scss interpolation statement.\\n      // it works in comments and we can't use it here\\n      {&} {\\n        @content;\\n      }\\n    }\\n    What if :host specified? Can we add space in :host-context(...) :host?\\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\\n  ***\\n\\n\\nProblems with the current approach.\\n\\n1. Direction can be applied only on document level, because mixin prepends theme class,\\nwhich placed on the body.\\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\\nattribute to [dir=rtl] attribute as well.\\n\\n\\nGeneral problems.\\n\\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\\n*/\\n/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/**\\n * This mixin generates keyfames.\\n * Because of all keyframes can't be scoped,\\n * we need to puts unique name in each btn-pulse call.\\n */\\n/*\\n\\nAccording to the specification (https://www.w3.org/TR/css-scoping-1/#host-selector)\\n:host and :host-context are pseudo-classes. So we assume they could be combined,\\nlike other pseudo-classes, even same ones.\\nFor example: ':nth-of-type(2n):nth-of-type(even)'.\\n\\nIdeal solution would be to prepend any selector with :host-context([dir=rtl]).\\nThen nebular components will behave as an html element and respond to [dir] attribute on any level,\\nso direction could be overridden on any component level.\\n\\nImplementation code:\\n\\n@mixin nb-rtl() {\\n  // add # to scss interpolation statement.\\n  // it works in comments and we can't use it here\\n  @at-root {selector-append(':host-context([dir=rtl])', &)} {\\n    @content;\\n  }\\n}\\n\\nAnd when we call it somewhere:\\n\\n:host {\\n  .some-class {\\n    @include nb-rtl() {\\n      ...\\n    }\\n  }\\n}\\n:host-context(...) {\\n  .some-class {\\n    @include nb-rtl() {\\n      ...\\n    }\\n  }\\n}\\n\\nResult will look like:\\n\\n:host-context([dir=rtl]):host .some-class {\\n  ...\\n}\\n:host-context([dir=rtl]):host-context(...) .some-class {\\n  ...\\n}\\n\\n*\\n  Side note:\\n  :host-context():host selector are valid. https://lists.w3.org/Archives/Public/www-style/2015Feb/0305.html\\n\\n  :host-context([dir=rtl]):host-context(...) should match any permutation,\\n  so order is not important.\\n*\\n\\n\\nCurrently, there're two problems with this approach:\\n\\nFirst, is that we can't combine :host, :host-context. Angular bugs #14349, #19199.\\nFor the moment of writing, the only possible way is:\\n:host {\\n  :host-context(...) {\\n    ...\\n  }\\n}\\nIt doesn't work for us because mixin could be called somewhere deeper, like:\\n:host {\\n  p {\\n    @include nb-rtl() { ... }\\n  }\\n}\\nWe are not able to go up to :host level to place content passed to mixin.\\n\\nThe second problem is that we only can be sure that we appending :host-context([dir=rtl]) to another\\n:host/:host-context pseudo-class when called in theme files (*.theme.scss).\\n  *\\n    Side note:\\n    Currently, nb-install-component uses another approach where :host prepended with the theme name\\n    (https://github.com/angular/angular/blob/5b96078624b0a4760f2dbcf6fdf0bd62791be5bb/packages/compiler/src/shadow_css.ts#L441),\\n    but it was made to be able to use current realization of rtl and it can be rewritten back to\\n    :host-context($theme) once we will be able to use multiple shadow selectors.\\n  *\\nBut when it's called in *.component.scss we can't be sure, that selector starts with :host/:host-context,\\nbecause angular allows omitting pseudo-classes if we don't need to style :host component itself.\\nWe can break such selectors, by just appending :host-context([dir=rtl]) to them.\\n  ***\\n    Possible solution\\n    check if we in theme by some theme variables and if so append, otherwise nest like\\n    @at-root :host-context([dir=rtl]) {\\n      // add # to scss interpolation statement.\\n      // it works in comments and we can't use it here\\n      {&} {\\n        @content;\\n      }\\n    }\\n    What if :host specified? Can we add space in :host-context(...) :host?\\n    Or maybe add :host selector anyway? If multiple :host selectors are allowed\\n  ***\\n\\n\\nProblems with the current approach.\\n\\n1. Direction can be applied only on document level, because mixin prepends theme class,\\nwhich placed on the body.\\n2. *.component.scss styles should be in :host selector. Otherwise angular will add host\\nattribute to [dir=rtl] attribute as well.\\n\\n\\nGeneral problems.\\n\\nLtr is default document direction, but for proper work of nb-ltr (means ltr only),\\n[dir=ltr] should be specified at least somewhere. ':not([dir=rtl]' not applicable here,\\nbecause it's satisfy any parent, that don't have [dir=rtl] attribute.\\nPrevious approach was to use single rtl mixin and reset ltr properties to initial value.\\nBut sometimes it's hard to find, what the previous value should be. And such mixin call looks too verbose.\\n*/\\n/**\\n * @license\\n * Copyright Akveo. All Rights Reserved.\\n * Licensed under the MIT License. See License.txt in the project root for license information.\\n */\\n/*\\n      :host can be prefixed\\n      https://github.com/angular/angular/blob/8d0ee34939f14c07876d222c25b405ed458a34d3/packages/compiler/src/shadow_css.ts#L441\\n\\n      We have to use :host insted of :host-context($theme), to be able to prefix theme class\\n      with something defined inside of @content, by prefixing &.\\n      For example this scss code:\\n        .nb-theme-default {\\n          .some-selector & {\\n            ...\\n          }\\n        }\\n      Will result in next css:\\n        .some-selector .nb-theme-default {\\n          ...\\n        }\\n\\n      It doesn't work with :host-context because angular splitting it in two selectors and removes\\n      prefix in one of the selectors.\\n    */\\n.nb-theme-default :host nb-tabset {\\n  height: 100%;\\n  display: -webkit-box;\\n  display: -ms-flexbox;\\n  display: flex;\\n  -webkit-box-orient: vertical;\\n  -webkit-box-direction: normal;\\n      -ms-flex-direction: column;\\n          flex-direction: column; }\\n.nb-theme-default :host nb-tab {\\n  padding: 1.25rem; }\\n.nb-theme-default :host /deep/ ngx-tab1,\\n.nb-theme-default :host /deep/ ngx-tab2 {\\n  display: block;\\n  padding: 1.25rem; }\\n@media (max-width: 399.98px) {\\n  .nb-theme-default :host nb-tabset /deep/ ul {\\n    font-size: 1rem;\\n    padding: 0 0.25rem; } }\\n/*\\n      :host can be prefixed\\n      https://github.com/angular/angular/blob/8d0ee34939f14c07876d222c25b405ed458a34d3/packages/compiler/src/shadow_css.ts#L441\\n\\n      We have to use :host insted of :host-context($theme), to be able to prefix theme class\\n      with something defined inside of @content, by prefixing &.\\n      For example this scss code:\\n        .nb-theme-default {\\n          .some-selector & {\\n            ...\\n          }\\n        }\\n      Will result in next css:\\n        .some-selector .nb-theme-default {\\n          ...\\n        }\\n\\n      It doesn't work with :host-context because angular splitting it in two selectors and removes\\n      prefix in one of the selectors.\\n    */\\n.nb-theme-cosmic :host nb-tabset {\\n  height: 100%;\\n  display: -webkit-box;\\n  display: -ms-flexbox;\\n  display: flex;\\n  -webkit-box-orient: vertical;\\n  -webkit-box-direction: normal;\\n      -ms-flex-direction: column;\\n          flex-direction: column; }\\n.nb-theme-cosmic :host nb-tab {\\n  padding: 1.25rem; }\\n.nb-theme-cosmic :host /deep/ ngx-tab1,\\n.nb-theme-cosmic :host /deep/ ngx-tab2 {\\n  display: block;\\n  padding: 1.25rem; }\\n@media (max-width: 399.98px) {\\n  .nb-theme-cosmic :host nb-tabset /deep/ ul {\\n    font-size: 1rem;\\n    padding: 0 0.25rem; } }\\n/*\\n      :host can be prefixed\\n      https://github.com/angular/angular/blob/8d0ee34939f14c07876d222c25b405ed458a34d3/packages/compiler/src/shadow_css.ts#L441\\n\\n      We have to use :host insted of :host-context($theme), to be able to prefix theme class\\n      with something defined inside of @content, by prefixing &.\\n      For example this scss code:\\n        .nb-theme-default {\\n          .some-selector & {\\n            ...\\n          }\\n        }\\n      Will result in next css:\\n        .some-selector .nb-theme-default {\\n          ...\\n        }\\n\\n      It doesn't work with :host-context because angular splitting it in two selectors and removes\\n      prefix in one of the selectors.\\n    */\\n.nb-theme-corporate :host nb-tabset {\\n  height: 100%;\\n  display: -webkit-box;\\n  display: -ms-flexbox;\\n  display: flex;\\n  -webkit-box-orient: vertical;\\n  -webkit-box-direction: normal;\\n      -ms-flex-direction: column;\\n          flex-direction: column; }\\n.nb-theme-corporate :host nb-tab {\\n  padding: 1.25rem; }\\n.nb-theme-corporate :host /deep/ ngx-tab1,\\n.nb-theme-corporate :host /deep/ ngx-tab2 {\\n  display: block;\\n  padding: 1.25rem; }\\n@media (max-width: 399.98px) {\\n  .nb-theme-corporate :host nb-tabset /deep/ ul {\\n    font-size: 1rem;\\n    padding: 0 0.25rem; } }\\n\"","module.exports = \"<div class=\\\"row\\\">\\n  <div class=\\\"col-md-6\\\">\\n    <nb-card>\\n      <nb-card-header>\\n        Layout Rotate Search\\n      </nb-card-header>\\n      <nb-card-body>\\n        <nb-search type=\\\"rotate-layout\\\" tag=\\\"rotate-layout\\\"></nb-search>\\n      </nb-card-body>\\n    </nb-card>\\n  </div>\\n  <div class=\\\"col-md-6\\\">\\n    <nb-card>\\n      <nb-card-header>\\n        Modal Zoomin Search\\n      </nb-card-header>\\n      <nb-card-body>\\n        <nb-search type=\\\"modal-zoomin\\\" tag=\\\"modal-zoomin\\\"></nb-search>\\n      </nb-card-body>\\n    </nb-card>\\n  </div>\\n  <div class=\\\"col-md-6\\\">\\n    <nb-card>\\n      <nb-card-header>\\n        Modal Move Search\\n      </nb-card-header>\\n      <nb-card-body>\\n        <nb-search type=\\\"modal-move\\\" tag=\\\"modal-move\\\"></nb-search>\\n      </nb-card-body>\\n    </nb-card>\\n  </div>\\n  <div class=\\\"col-md-6\\\">\\n    <nb-card>\\n      <nb-card-header>\\n        Modal Drop Search\\n      </nb-card-header>\\n      <nb-card-body>\\n        <nb-search type=\\\"modal-drop\\\" tag=\\\"modal-drop\\\"></nb-search>\\n      </nb-card-body>\\n    </nb-card>\\n  </div>\\n  <div class=\\\"col-md-6\\\">\\n    <nb-card>\\n      <nb-card-header>\\n        Modal Half Search\\n      </nb-card-header>\\n      <nb-card-body>\\n        <nb-search type=\\\"modal-half\\\" tag=\\\"modal-half\\\"></nb-search>\\n      </nb-card-body>\\n    </nb-card>\\n  </div>\\n  <div class=\\\"col-md-6\\\">\\n    <nb-card>\\n      <nb-card-header>\\n        Curtain Search\\n      </nb-card-header>\\n      <nb-card-body>\\n        <nb-search type=\\\"curtain\\\" tag=\\\"curtain\\\"></nb-search>\\n      </nb-card-body>\\n    </nb-card>\\n  </div>\\n  <div class=\\\"col-md-6\\\">\\n    <nb-card>\\n      <nb-card-header>\\n        Column Curtain Search\\n      </nb-card-header>\\n      <nb-card-body>\\n        <nb-search type=\\\"column-curtain\\\" tag=\\\"column-curtain\\\"></nb-search>\\n      </nb-card-body>\\n    </nb-card>\\n  </div>\\n</div>\\n\\n\""],"sourceRoot":""}